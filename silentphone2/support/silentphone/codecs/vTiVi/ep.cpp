/*
Created by Janis Narbuts
Copyright (C) 2004-2012, Tivi LTD, www.tiviphone.com. All rights reserved.
Copyright (C) 2012-2015, Silent Circle, LLC.  All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Any redistribution, use, or modification is done solely for personal
      benefit and not for any commercial purpose or for monetary gain
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name Silent Circle nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL SILENT CIRCLE, LLC BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#if 1

#define T_CAN_TEST_V
//#undef T_CAN_TEST_V
//ndef __SYMBIAN32__
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
static int g_iSkipLoop=0;

void debugss(char *,int ,int);
void debugsi(char *c, int a);
void debugs2i(char *c, int a, int b);
int setFSTabVal(int a, int t0, int t1, int fs);
int testFStrenght(int a,int b, int c, int d);
int setFTabA(int a, int iPic);
#ifndef max
#define max(A,B) ((A)>(B)?(A):(B))
#define min(A,B) ((A)<(B)?(A):(B))
#endif 
//#define _T_MPG
/*
  0,  2,  3,  6,  9, 11, 14, 17, 20, 24, 30, 35, 40, 48, 56, 68,
  1,  7, 18, 31, 43, 49, 55, 59, 66, 71, 79, 72, 90,105,135,155,
  4, 23, 47, 65, 85, 92,104,106,113,110,129,108,133,142,173,211,
 10, 42, 74, 96,118,137,146,145,150,153,158,141,164,169,221,231,
  5,  8, 13, 16, 19, 22, 25, 26, 29, 32, 33, 34, 36, 38, 45, 52,
 12, 44, 61, 84, 97,107,123,120,119,124,114,100, 99, 91,127,181,
 39, 93,132,149,172,167,191,165,175,184,163,152,147,130,161,232,
 50,138,180,192,220,219,230,210,218,209,201,183,178,159,205,233,
 27, 80, 54, 70, 87, 95,126,122, 15, 21,234,235,236,237,238,239,
 53, 58, 60, 64, 62, 67, 73, 76, 77, 82, 89, 94,103,112,115,117,
128,134,136,139,144,154,151,157,189,174,204,182,187,227,200,240,
226,225,229,241,228,242,243,244,245,246,247,248,249,250,251,252,
253,254,168,224,217,216, 28, 37, 41, 46, 51, 57, 63, 69, 75, 78,
 81, 83, 86, 88, 98,102,109,111,116,121,125,131,140,143,148,156,
160,162,171,166,170,179,177,190,186,188,176,199,185,207,203,198,
197,196,193,195,206,194,223,202,222,208,255,215,214,212,213,101,

  0, 16,  1,  2, 32, 64,  3, 17, 65,  4, 48,  5, 80, 66,  6,136,
 67,  7, 18, 68,  8,137, 69, 33,  9, 70, 71,128,198, 72, 10, 19,
 73, 74, 75, 11, 76,199, 77, 96, 12,200, 49, 20, 81, 78,201, 34,
 13, 21,112,202, 79,144,130, 22, 14,203,145, 23,146, 82,148,204,
147, 35, 24,149, 15,205,131, 25, 27,150, 50,206,151,152,207, 26,
129,208,153,209, 83, 36,210,132,211,154, 28, 93, 37, 97,155,133,
 51, 84,212, 92, 91,255,213,156, 38, 29, 39, 85, 43,214, 41,215,
157, 40, 90,158,216,159, 52, 88, 87,217,135, 86, 89,218,134, 94,
160, 42,109,219, 98, 44,161, 30,162, 53,113,163,220, 59, 45,221,
164, 55, 54,108,222, 99, 56,166,107, 57,165, 31,223,167, 58,125,
224,110,225,106, 60,103,227,101,194, 61,228,226,100, 46,169,104,
234,230,124,229,114, 95,171,123,105,236,232,172,233,168,231,102,
115,242,245,243,241,240,239,235,174,122,247,238,170,126,244,237,
249,121,119, 47,253,254,252,251,197,196,120,117,116, 62,248,246,
195,177,176,173,180,178,118, 63,111,127,138,139,140,141,142,143,
175,179,181,182,183,184,185,186,187,188,189,190,191,192,193,250,
*/
#if 0
const int dif_tbl[]=
{
//enc

  0,  2,  4,  8, 10, 14, 20, 26, 34, 39, 47, 52, 59, 66, 74, 88,
  1,  7, 16, 27, 38, 44, 53, 61, 76, 80, 94,107,116,131,124,148,
  5, 17, 41, 50, 69, 78, 91, 99,119,114,134,146,159,182,171,200,
  9, 35, 57, 81, 98,109,121,130,156,158,172,170,187,207,199,217,
  3,  6, 13, 15, 18, 23, 25, 28, 31, 32, 36, 37, 43, 46, 51, 67,
 11, 29, 45, 54, 64, 71, 83, 85, 96, 92,104,105,112,115,127,169,
 21, 65, 86,111,118,122,143,141,154,151,161,152,164,165,191,216,
 40,106,120,153,160,162,181,198,180,186,215,179,190,197,194,218,
 22, 55, 48, 58, 70, 79,101,103, 12, 19,219,220,221,222,223,224,
 60, 63, 73, 75, 72, 82, 89, 95, 90, 97,108,123,135,137,139,133,
147,155,145,173,174,192,206,185,205,225,226,204,203,214,227,228,
229,213,230,231,232,233,234,235,212,236,237,238,239,240,241,242,
243,244,129,163,184,168, 24, 33, 30, 42, 49, 56, 62, 68, 77, 84,
 87, 93,100,102,110,113,117,125,128,126,132,136,138,142,140,144,
150,157,149,166,176,167,189,178,183,211,193,177,188,245,208,246,
196,202,247,248,209,195,249,250,201,251,210,252,253,254,255,175,
//dec
  0, 16,  1, 64,  2, 32, 65, 17,  3, 48,  4, 80,136, 66,  5, 67,
 18, 33, 68,137,  6, 96,128, 69,198, 70,  7, 19, 71, 81,200, 72,
 73,199,  8, 49, 74, 75, 20,  9,112, 34,201, 76, 21, 82, 77, 10,
130,202, 35, 78, 11, 22, 83,129,203, 50,131, 12,144, 23,204,145,
 84, 97, 13, 79,205, 36,132, 85,148,146, 14,147, 24,206, 37,133,
 25, 51,149, 86,207, 87, 98,208, 15,150,152, 38, 89,209, 26,151,
 88,153, 52, 39,210,134,211,135, 90, 91,113, 27,154, 53,212, 99,
 92,213, 41, 93, 28,214,100, 40,114, 54,101,155, 30,215,217, 94,
216,194, 55, 29,218,159, 42,156,219,157,220,158,222,103,221,102,
223,162, 43,160, 31,226,224,105,107,115,104,161, 56,225, 57, 44,
116,106,117,195,108,109,227,229,197, 95, 59, 46, 58,163,164,255,
228,235,231,123,120,118, 45,232,196,167,121, 60,236,230,124,110,
165,234,126,245,240,125,119, 62, 47,248,241,172,171,168,166, 61,
238,244,250,233,184,177,173,122,111, 63,127,138,139,140,141,142,
143,169,170,174,175,176,178,179,180,181,182,183,185,186,187,188,
189,190,191,192,193,237,239,242,243,246,247,249,251,252,253,254,

   /* dct4x4
//enc
  0,  2,  6,  9, 13, 11, 12, 21, 23, 19, 22, 27, 28, 17, 15,  1,
  3, 14, 29, 31, 39, 40, 38, 60, 49, 43, 45, 55, 58, 34, 32, 10,
  7, 30, 56, 57, 68, 65, 53, 78, 72, 61, 62, 76, 77, 54, 50, 24,
 16, 48, 79, 75, 90, 89, 64, 93, 94, 70, 81, 98, 97, 71, 69, 41,
 18, 25, 36, 42, 37, 44, 52, 85, 91,109,112,123,139,146,161,  5,
 47, 67, 86, 96, 87, 82,103,130,121,167,155,176,177,173,178, 20,
 84,102,111,114,108,105,120,153,138,179,180,181,182,183,184, 35,
104,119,127,129,126,117,135,172,149,185,175,186,187,188,189, 59,
  4, 74, 66, 80, 95, 99, 88, 26,  8, 33,190,191,192,193,194,195,
196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,
212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,
228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,
244,245,134,148,152,145, 46, 51, 63, 73, 83, 92,100,101,106,107,
110,113,115,116,118,122,125,124,128,131,136,132,137,142,141,133,
140,147,144,143,150,151,154,156,159,157,164,171,158,163,160,166,
165,170,246,247,162,169,168,248,249,250,174,251,252,253,254,255,
//dec
  0, 15,  1, 16,128, 79,  2, 32,136,  3, 31,  5,  6,  4, 17, 14,
 48, 13, 64,  9, 95,  7, 10,  8, 47, 65,135, 11, 12, 18, 33, 19,
 30,137, 29,111, 66, 68, 22, 20, 21, 63, 67, 25, 69, 26,198, 80,
 49, 24, 46,199, 70, 38, 45, 27, 34, 35, 28,127, 23, 41, 42,200,
 54, 37,130, 81, 36, 62, 57, 61, 40,201,129, 51, 43, 44, 39, 50,
131, 58, 85,202, 96, 71, 82, 84,134, 53, 52, 72,203, 55, 56,132,
 83, 60, 59,133,204,205, 97, 86,112,101,206,207,100, 73,208, 98,
 74,209, 99,210,211,117,212,113,102, 88,213, 75,215,214,116,114,
216,115, 87,217,219,223,194,118,218,220,104, 76,224,222,221,227,
226,197, 77,225,195,120,228,229,196,103,230, 90,231,233,236,232,
238, 78,244,237,234,240,239, 89,246,245,241,235,119, 93,250,122,
 91, 92, 94,105,106,107,108,109,110,121,123,124,125,126,138,139,
140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,
156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,
172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,
188,189,190,191,192,193,242,243,247,248,249,251,252,253,254,255,
*/
};/// 
const int non_dif_tbl[]={
//enc
//enc
  0, 16, 32,128, 64, 48,  1,136, 17, 65, 80,137,  2,198, 96,200,
};
const int uv_tab[]={
//enc
  1, 11, 23, 39, 55, 69, 74, 92, 90, 95,110,111,109,112,113,114,
  3, 20, 31, 63, 86,115,116,117,118,119,120,121,122,123,124,125,
  6, 28, 48, 85,126,127,128,129,130,131,132,133,134,135,136,137,
 10, 35, 62,108,138,139,140,141,142,143,144,145,146,147,148,149,
  2,  5, 17, 16, 26, 71, 83, 89,107,106,105,150,151,152,153, 99,
  0, 13, 24, 34, 45, 81,154,155,156,157,158,159,160,161,162,163,
  4, 27, 38, 64, 78,164,165,166,167,168,169,170,171,172,173,174,
  7, 33, 58, 82, 94,175,176,177,178,179,180,181,182,183,184,185,
  8, 51, 42, 50, 56, 73,186,187, 14, 19,188,189,190,191,192,193,
104,194,195,196,197,198,199,200,201,202,203,103,204,205,206,207,
208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,
224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,
240,241, 46, 59, 66, 72, 15, 18,  9, 12, 21, 22, 25, 29, 30, 32,
 36, 37, 40, 41, 44, 47, 43, 49, 53, 54, 52, 57, 60, 61, 65, 67,
 68, 70, 75, 76, 80, 77, 84, 88, 79, 87, 91,102, 98, 97, 93,242,
 96,243,244,100,101,245,246,247,248,249,250,251,252,253,254,255,
//dec
 80,  0, 64, 16, 96, 65, 32,112,128,200, 48,  1,201, 81,136,198,
 67, 66,199,137, 17,202,203,  2, 82,204, 68, 97, 33,205,206, 18,
207,113, 83, 49,208,209, 98,  3,210,211,130,214,212, 84,194,213,
 34,215,131,129,218,216,217,  4,132,219,114,195,220,221, 50, 19,
 99,222,196,223,224,  5,225, 69,197,133,  6,226,227,229,100,232,
228, 85,115, 70,230, 35, 20,233,231, 71,  8,234,  7,238,116,  9,
240,237,236, 79,243,244,235,155,144, 74, 73, 72, 51, 12, 10, 11,
 13, 14, 15, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 36, 37,
 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 52, 53, 54, 55, 56, 57,
 58, 59, 60, 61, 62, 63, 75, 76, 77, 78, 86, 87, 88, 89, 90, 91,
 92, 93, 94, 95,101,102,103,104,105,106,107,108,109,110,111,117,
118,119,120,121,122,123,124,125,126,127,134,135,138,139,140,141,
142,143,145,146,147,148,149,150,151,152,153,154,156,157,158,159,
160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,
176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,
192,193,239,241,242,245,246,247,248,249,250,251,252,253,254,255,
};

const int tab5x[]={
//enc //q=85
//enc
120,  0,  1,  5, 16, 31, 54,120, 57,  3, 14, 38, 59, 80, 98,121,
122,  2,  8, 23, 47, 69, 97,123,124,  6, 32, 63, 96,125,126,127,
128,  4, 17, 43, 66, 93,129,130,131,  9, 42, 79,102,119,132,133,
134,  7, 25, 53, 75, 92,135,136,137, 10, 44, 78,103,138,139,140,
141, 11, 36, 64, 88,114,142,143,144, 12, 49, 83,118,145,146,147,
148, 13, 40, 71,101,149,150,151,152, 15, 52, 89,153,154,155,156,
157, 19, 48, 81,100,158,159,160,161, 18, 60, 95,162,163,164,165,
166, 21, 51, 77,109,167,168,169,170, 20, 67,108,171,172,173,174,
175, 24, 56, 86,117,176,177,178,179, 22, 70,112,180,181,182,183,
184, 28, 58, 84,116,185,186,187,188, 27, 68,115,189,190,191,192,
193, 35, 62, 99,194,195,196,197,198, 30, 76,111,199,200,201,202,
203, 37, 61, 91,204,205,206,207,208, 29, 72,107,209,210,211,212,
213, 41, 74,105,214,215,216,217,218, 33, 73,106,219,220,221,222,
223, 46, 82,110,224,225,226,227,228, 34, 65, 94,229,230,231,232,
233, 50, 87,234,235,236,237,238,239, 39, 85,113,240,241,242,243,
 26, 55, 90,244,245,246,247,248,249, 45,104,250,251,252,253,254,
//dec
  1,  2, 17,  9, 33,  3, 25, 49, 18, 41, 57, 65, 73, 81, 10, 89,
  4, 34,105, 97,121,113,137, 19,129, 50,240,153,145,185,169,  5,
 26,201,217,161, 66,177, 11,233, 82,193, 42, 35, 58,249,209, 20,
 98, 74,225,114, 90, 51,  6,241,130,  8,146, 12,106,178,162, 27,
 67,218, 36,122,154, 21,138, 83,186,202,194, 52,170,115, 59, 43,
 13, 99,210, 75,147,234,131,226, 68, 91,242,179, 53, 37,219,107,
 28, 22, 14,163,100, 84, 44, 60,250,195,203,187,123,116,211,171,
139,235, 69,155,148,132, 76, 45,  7, 15, 16, 23, 24, 29, 30, 31,
 32, 38, 39, 40, 46, 47, 48, 54, 55, 56, 61, 62, 63, 64, 70, 71,
 72, 77, 78, 79, 80, 85, 86, 87, 88, 92, 93, 94, 95, 96,101,102,
103,104,108,109,110,111,112,117,118,119,120,124,125,126,127,128,
133,134,135,136,140,141,142,143,144,149,150,151,152,156,157,158,
159,160,164,165,166,167,168,172,173,174,175,176,180,181,182,183,
184,188,189,190,191,192,196,197,198,199,200,204,205,206,207,208,
212,213,214,215,216,220,221,222,223,224,227,228,229,230,231,232,
236,237,238,239,243,244,245,246,247,248,251,252,253,254,255,  0,
};

const int tab5x_uv[]={

//enc
//enc
 70,  1,  4,  6, 14, 40, 70, 71, 15,  0,  2,  7, 17, 41, 52, 72,
 73,  5, 19, 50, 57, 74, 75, 76, 77,  3, 18, 51, 62, 78, 79, 80,
 81, 10, 33, 59, 82, 83, 84, 85, 86,  8, 37, 56, 87, 88, 89, 90,
 91, 13, 47, 92, 93, 94, 95, 96, 97,  9, 46, 58, 98, 99,100,101,
102, 16, 49,103,104,105,106,107,108, 11, 48,109,110,111,112,113,
114, 20, 54,115,116,117,118,119,120, 26, 53,121,122,123,124,125,
126, 21, 61,127,128,129,130,131,132, 31, 69,133,134,135,136,137,
138, 22, 55,139,140,141,142,143,144, 29,145,146,147,148,149,150,
151, 23, 68,152,153,154,155,156,157, 34, 64,158,159,160,161,162,
163, 24, 60,164,165,166,167,168,169, 36, 67,170,171,172,173,174,
175, 25, 63,176,177,178,179,180,181, 38,182,183,184,185,186,187,
188, 27,189,190,191,192,193,194,195, 39,196,197,198,199,200,201,
202, 28, 66,203,204,205,206,207,208, 42,209,210,211,212,213,214,
215, 30, 65,216,217,218,219,220,221, 43,222,223,224,225,226,227,
228, 32,229,230,231,232,233,234,235, 45,236,237,238,239,240,241,
 12, 35,242,243,244,245,246,247,248, 44,249,250,251,252,253,254,
//dec
  9,  1, 10, 25,  2, 17,  3, 11, 41, 57, 33, 73,240, 49,  4,  8,
 65, 12, 26, 18, 81, 97,113,129,145,161, 89,177,193,121,209,105,
225, 34,137,241,153, 42,169,185,  5, 13,201,217,249,233, 58, 50,
 74, 66, 19, 27, 14, 90, 82,114, 43, 20, 59, 35,146, 98, 28,162,
138,210,194,154,130,106,  6,  7, 15, 16, 21, 22, 23, 24, 29, 30,
 31, 32, 36, 37, 38, 39, 40, 44, 45, 46, 47, 48, 51, 52, 53, 54,
 55, 56, 60, 61, 62, 63, 64, 67, 68, 69, 70, 71, 72, 75, 76, 77,
 78, 79, 80, 83, 84, 85, 86, 87, 88, 91, 92, 93, 94, 95, 96, 99,
100,101,102,103,104,107,108,109,110,111,112,115,116,117,118,119,
120,122,123,124,125,126,127,128,131,132,133,134,135,136,139,140,
141,142,143,144,147,148,149,150,151,152,155,156,157,158,159,160,
163,164,165,166,167,168,170,171,172,173,174,175,176,178,179,180,
181,182,183,184,186,187,188,189,190,191,192,195,196,197,198,199,
200,202,203,204,205,206,207,208,211,212,213,214,215,216,218,219,
220,221,222,223,224,226,227,228,229,230,231,232,234,235,236,237,
238,239,242,243,244,245,246,247,248,250,251,252,253,254,255,  0,
};
const int tab6x_uv[]={
//enc
 83, 18, 19, 21, 27, 30,  0,  1,  4,  2, 10,  6, 11, 14, 16, 20,
 81, 43, 48, 65, 82, 83,  3,  7,  8, 15, 22, 25, 28, 32, 41, 44,
 84, 61, 80, 85, 86, 87,  5,  9, 17, 23, 29, 37, 42, 52, 58, 68,
 88, 89, 90, 91, 92, 93, 12, 24, 31, 45, 49, 67, 70, 94, 95, 79,
 96, 97, 98, 99,100,101, 13, 26, 35, 46, 56, 62, 78,102, 77,103,
104,105,106,107,108,109, 33, 47, 54, 59, 64,110,111, 76,112,113,
114,115,116,117,118,119, 36, 63, 73,120,121,122,123,124,125,126,
127,128,129,130,131,132, 38, 72, 69,133,134,135,136,137,138,139,
140,141,142,143,144,145, 39, 66,146,147,148,149,150,151,152,153,
154,155,156,157,158,159, 34, 75,160,161,162,163,164,165,166,167,
168,169,170,171,172,173, 51,174,175,176,177,178,179,180,181,182,
183,184,185,186,187,188, 53,189,190,191,192,193,194,195,196,197,
198,199,200,201,202,203, 50,204,205,206,207,208,209,210,211,212,
213,214,215,216,217,218, 55, 74,219,220,221,222,223,224,225,226,
227,228,229,230,231,232, 60,233,234,235,236,237,238,239,240,241,
 40,242,243,244,245,246, 71,247,248,249,250,251,252,253,254,255,
//dec
  6,  7,  9, 22,  8, 38, 11, 23, 24, 39, 10, 12, 54, 70, 13, 25,
 14, 40,  1,  2, 15,  3, 26, 41, 55, 27, 71,  4, 28, 42,  5, 56,
 29, 86,150, 72,102, 43,118,134,240, 30, 44, 17, 31, 57, 73, 87,
 18, 58,198,166, 45,182, 88,214, 74,262, 46, 89,230, 33, 75,103,
 90, 19,135, 59, 47,120, 60,246,119,104,215,151, 93, 78, 76, 63,
 34, 16, 20, 21, 32, 35, 36, 37, 48, 49, 50, 51, 52, 53, 61, 62,
 64, 65, 66, 67, 68, 69, 77, 79, 80, 81, 82, 83, 84, 85, 91, 92,
 94, 95, 96, 97, 98, 99,100,101,105,106,107,108,109,110,111,112,
113,114,115,116,117,121,122,123,124,125,126,127,128,129,130,131,
132,133,136,137,138,139,140,141,142,143,144,145,146,147,148,149,
152,153,154,155,156,157,158,159,160,161,162,163,164,165,167,168,
169,170,171,172,173,174,175,176,177,178,179,180,181,183,184,185,
186,187,188,189,190,191,192,193,194,195,196,197,199,200,201,202,
203,204,205,206,207,208,209,210,211,212,213,216,217,218,219,220,
221,222,223,224,225,226,227,228,229,231,232,233,234,235,236,237,
238,239,241,242,243,244,245,247,248,249,250,251,252,253,254,255,
};
const int tab6x[]={
//enc
213, 17, 15, 18, 29, 43,  0,  1,  3,  4,  7,  8, 12, 14, 19, 21,
211, 53, 54, 65, 84,110,  2,  6, 10, 16, 23, 30, 37, 40, 51, 56,
212, 83, 89,106,125,168,  5, 13, 24, 32, 39, 52, 58, 67, 77, 86,
213,119,123,150,177,214,  9, 25, 36, 50, 63, 70, 85, 95,105,121,
215,108,116,159,172,216, 11, 26, 35, 47, 57, 68, 82, 93,102,113,
217,183,186,198,218,219, 20, 38, 61, 80, 94,109,132,143,164,171,
220,153,155,182,221,222, 22, 41, 62, 75, 90,100,112,130,139,156,
223,149,163,170,224,225, 27, 46, 64, 76, 91,101,118,129,134,148,
226,146,162,175,227,228, 28, 44, 60, 74, 92, 99,120,127,145,158,
229,142,152,167,230,231, 31, 45, 59, 73, 87, 96,115,124,133,141,
232,210,209,233,234,235, 42, 81,107,136,157,185,176,187,236,208,
237,197,207,238,239,240, 48, 78, 97,122,137,161,166,191,181,206,
241,190,205,242,243,244, 34, 55, 72, 88,103,128,135,151,154,180,
245,204,184,196,246,247, 49, 79, 98,117,131,144,160,173,195,179,
248,249,250,251,252,253, 66,111,138,169,189,188,254,201,255,256,
 33,257,258,259,260,261, 71,114,140,174,194,193,192,199,262,263,
//dec
  6,  7, 22,  8,  9, 38, 23, 10, 11, 54, 24, 70, 12, 39, 13,  2,
 25,  1,  3, 14, 86, 15,102, 26, 40, 55, 71,118,134,  4, 27,150,
 41,240,198, 72, 56, 28, 87, 42, 29,103,166,  5,135,151,119, 73,
182,214, 57, 30, 43, 17, 18,199, 31, 74, 44,152,136, 88,104, 58,
120, 19,230, 45, 75,262, 59,246,200,153,137,105,121, 46,183,215,
 89,167, 76, 33, 20, 60, 47,154,201, 34,106,122,138, 77, 90, 61,
155,184,216,139,107,123, 78,202,263, 62, 35,168, 65, 91, 21,231,
108, 79,247,156, 66,217,124, 49,140, 63,185, 50,157, 36,264,141,
203,125,109,218, 92,158,126,204,169,186,232,110,248,159,145, 93,
219,142,129,265,127,113, 51,205,146, 97,206, 98,111,170,143, 67,
220,187,130,114, 94,266,188,147, 37,233,115, 95, 68,221,249,131,
172, 52,267,223,207,190, 99, 81,210,171, 82,173,235,234,193,189,
252,251,250,222,211,177, 83,253,268,237,270,269,209,194,191,178,
175,162,161, 16, 32, 48, 53, 64, 69, 80, 84, 85, 96,100,101,112,
116,117,128,132,133,144,148,149,160,163,164,165,174,176,179,180,
181,192,195,196,197,208,212,213,224,225,226,227,228,229,236,238,
};
const int t6x_uv_tivi[]={
//enc
 57, 26, 28, 43, 55, 56,  0,  2,  3,  7, 14, 19, 23, 24, 25, 27,
 57, 58, 59, 60, 61, 62,  4, 29, 54, 63, 64, 65, 66, 67, 68, 69,
 70, 71, 72, 73, 74, 75,  5, 32, 53, 76, 77, 78, 79, 80, 81, 82,
 83, 84, 85, 86, 87, 88,  9, 33, 48, 89, 90, 91, 92, 93, 94, 95,
 96, 97, 98, 99,100,101,  6, 31, 39,102, 47, 44,103,104,105,106,
107,108,109,110,111,112,  8, 30, 52,113,114,115,116,117,118,119,
120,121,122,123,124,125, 13, 40,126,127,128,129,130,131,132,133,
134,135,136,137,138,139, 15, 35, 51,140,141,142,143,144,145,146,
147,148,149,150,151,152, 11, 38,153,154,155,156,157,158,159,160,
161,162,163,164,165,166, 10, 34, 50,167,168,169,170,171,172,173,
174,175,176,177,178,179, 16, 42,180,181,182,183,184,185,186,187,
188,189,190,191,192,193, 17, 37,194,195,196,197,198,199,200,201,
202,203,204,205,206,207, 12, 36,208,209,210,211,212,213,214,215,
216,217,218,219,220,221, 18, 41,222,223,224,225,226,227,228,229,
230,231,232,233,234,235, 21, 49,236,237,238,239,240,241,242,243,
  1,244,245,246,247,248, 20, 45,249,250,251,252,253,254,255,256,
//dec
  6,240,  7,  8, 22, 38, 70,  9, 86, 54,150,134,198,102, 10,118,
166,182,214, 11,246,230,262, 12, 13, 14,  1, 15,  2, 23, 87, 71,
 39, 55,151,119,199,183,135, 72,103,215,167,  3, 75,247,263, 74,
 56,231,152,120, 88, 40, 24,  4,  5, 16, 17, 18, 19, 20, 21, 25,
 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 41, 42, 43, 44,
 45, 46, 47, 48, 49, 50, 51, 52, 53, 57, 58, 59, 60, 61, 62, 63,
 64, 65, 66, 67, 68, 69, 73, 76, 77, 78, 79, 80, 81, 82, 83, 84,
 85, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,100,101,104,105,
106,107,108,109,110,111,112,113,114,115,116,117,121,122,123,124,
125,126,127,128,129,130,131,132,133,136,137,138,139,140,141,142,
143,144,145,146,147,148,149,153,154,155,156,157,158,159,160,161,
162,163,164,165,168,169,170,171,172,173,174,175,176,177,178,179,
180,181,184,185,186,187,188,189,190,191,192,193,194,195,196,197,
200,201,202,203,204,205,206,207,208,209,210,211,212,213,216,217,
218,219,220,221,222,223,224,225,226,227,228,229,232,233,234,235,
236,237,238,239,241,242,243,244,245,248,249,250,251,252,253,254,
};
const int t6x_y_tivi[]={
//enc
195, 46, 52, 62, 87,193,  0,  1,  5, 10, 17, 23, 29, 33, 40, 47,
194, 88,107,169,195,196,  2,  9, 19, 30, 38, 48, 57, 65, 73, 82,
197,119,153,192,198,199,  4, 16, 31, 43, 54, 67, 78, 89, 99,116,
200,131,168,191,201,202,  6, 22, 36, 50, 66, 77, 91,103,115,128,
203,144,159,204,205,206,  7, 25, 41, 56, 71, 83,100,113,124,134,
207,148,179,190,208,209,  8, 27, 44, 61, 76, 93,109,121,135,156,
210,167,189,211,212,213, 11, 32, 51, 69, 86,101,112,133,146,173,
214,178,188,215,216,217, 12, 34, 53, 74, 90,102,127,145,150,158,
218,172,219,220,221,222, 14, 37, 59, 79, 96,110,130,142,166,187,
223,165,224,225,226,227, 13, 35, 58, 75, 92,105,122,136,155,157,
228,229,186,230,231,232, 15, 39, 63, 80, 97,114,132,139,171,164,
233,234,235,236,237,238, 18, 42, 64, 84, 98,118,123,138,154,163,
239,177,240,241,242,243, 21, 49, 72, 94,111,126,137,149,152,170,
244,176,180,245,246,247, 20, 45, 68, 85,104,120,125,141,151,162,
248,249,181,250,251,252, 24, 55, 81,106,147,143,161,182,253,254,
  3,255,256,257,258,259, 26, 60, 95,117,140,175,260,174,183,261,
//dec
  6,  7, 22,240, 38,  8, 54, 70, 86, 23,  9,102,118,150,134,166,
 39, 10,182, 24,214,198, 55, 11,230, 71,246, 87,262, 12, 25, 40,
103, 13,119,151, 56,135, 26,167, 14, 72,183, 41, 88,215,  1, 15,
 27,199, 57,104,  2,120, 42,231, 73, 28,152,136,247, 89,  3,168,
184, 29, 58, 43,216,105,263, 74,200, 30,121,153, 90, 59, 44,137,
169,232, 31, 75,185,217,106,  4, 17, 45,122, 60,154, 91,201,248,
138,170,186, 46, 76,107,123, 61,218,155,233, 18,264, 92,139,202,
108, 77,171, 62, 47,249,187, 33,219, 93,156,188, 78,220,203,124,
 63,265,140, 49,172,109, 79, 94,157,204,189,173,250,221,141,235,
 65,125,110,234, 81,205,126,222,206, 34,190,158, 95,159,127, 66,
266,236,223,191,175,145,142, 97, 50, 19,207,174,129,111,253,251,
209,193,113, 82,210,226,237,254,268,267,162,143,114, 98, 83, 51,
 35,  5, 16, 20, 21, 32, 36, 37, 48, 52, 53, 64, 67, 68, 69, 80,
 84, 85, 96, 99,100,101,112,115,116,117,128,130,131,132,133,144,
146,147,148,149,160,161,163,164,165,176,177,178,179,180,181,192,
194,195,196,197,208,211,212,213,224,225,227,228,229,238,239,241,
};
#endif
//dec
/*
void testTr(){
   int i,j;
   int tab_enc_dct[256];
   int iLast;//=256-25;
   //memset(tab_dec_dct,
   for(i=0;i<256;i++){if(tab_dec_dct[i]==0 && tab_dec_dct[i+1]==0){iLast=i;break;}}
   
   for(i=0;i<256;i++)
   {
      tab_enc_dct[i]=900009;
      for(j=0;j<256;j++)
      {
         if(tab_dec_dct[j]==i){tab_enc_dct[i]=j;break;}
      }
      if(j==256)
      {
         tab_dec_dct[iLast]=i;//iLast++;
         tab_enc_dct[i]=iLast;
         iLast++;
      }
   }

   puts("//enc");
   for(i=0;i<256;i++)
   {
      printf("%3d,",tab_enc_dct[i]);if((i&15)==15)puts("");
   }
   puts("//dec");
   for(i=0;i<256;i++)
   {
      printf("%3d,",tab_dec_dct[i]);if((i&15)==15)puts("");
   }
}*/

static const  int j2_cb_quant_tbl[] = {
   /*
 17,  18,  24,  47,  99,  99,  99,  99,
 18,  21,  26,  66,  99,  99,  99,  99,
 24,  26,  56,  99,  99,  99,  99,  99,
 47,  66,  99,  99,  99,  99,  99,  99,
 99,  99,  99,  99,  99,  99,  99,  99,
 99,  99,  99,  99,  99,  99,  99,  99,
 99,  99,  99,  99,  99,  99,  99,  99,
 99,  99,  99,  99,  99,  99,  99,  99
 */

   18,  18,  32,  70,  99,  99,  99,  99,
   18,  22,  40,  60,  99,  99,  99,  99,
   32,  40,  60,  99,  99,  99,  99,  99,
   70,  60,  99,  99,  99,  99,  99,  99,
   99,  99,  99,  99,  99,  99,  99,  99,
   99,  99,  99,  99,  99,  99,  99,  99,
   99,  99,  99,  99,  99,  99,  99,  99,
   99,  99,  99,  99,  99,  99,  99,  99
};
static const  int j2_y_quant_tbl[] = {
   /*
    16,  11,  10,  16,  24,  40,  51,  61,
    12,  12,  14,  19,  26,  58,  60,  55,
    14,  13,  16,  24,  40,  57,  69,  56,
    14,  17,  22,  29,  51,  87,  80,  62,
    18,  22,  37,  56,  68, 109, 103,  77,
    24,  35,  55,  64,  81, 104, 113,  92,
    49,  64,  78,  87, 103, 121, 120, 101,
    72,  92,  95,  98, 112, 100, 103,  99,
    
   
	14, 17, 20, 26, 27, 28, 30, 31,
	17, 19, 25, 27, 28, 30, 31, 33,
	20, 25, 27, 28, 29, 32, 32, 34,
	26, 27, 29, 30, 31, 33, 34, 35,
	28, 30, 31, 31, 31, 34, 35, 36,
	28, 30, 31, 31, 31, 32, 35, 38,
	29, 31, 31, 32, 32, 35, 38, 41,
	30, 32, 32, 32, 35, 38, 41, 45
   */
   /*
	14, 16, 19, 21, 22, 23, 25, 27,
	16, 18, 20, 22, 23, 25, 27, 28,
	19, 20, 22, 23, 24, 26, 28, 30,
	21, 22, 23, 24, 26, 28, 30, 32,
	22, 23, 24, 26, 28, 30, 32, 35,
	23, 24, 26, 28, 30, 32, 35, 38,
	25, 26, 28, 30, 32, 35, 38, 41,
	27, 28, 30, 32, 35, 38, 41, 45
   
   
    //mpeg
   
  16, 17, 19, 21, 26, 27, 29, 34,
  17, 18, 20, 24, 27, 29, 34, 37,
  19, 20, 26, 27, 29, 34, 34, 38,
  21, 22, 26, 27, 29, 34, 37, 40,
  22, 26, 27, 29, 32, 35, 40, 48,
  26, 27, 29, 32, 35, 40, 48, 58,
  26, 27, 29, 34, 38, 46, 56, 69,
  27, 29, 35, 38, 46, 56, 69, 83
  
   */

    16,  12,  16,  20,  24,  28,  32,  36,
    12,  14,  18,  24,  28,  32,  36,  48,
    16,  18,  24,  28,  32,  36,  48,  48,
    20,  24,  28,  32,  36,  48,  48,  40,
    24,  28,  32,  36,  48,  48,  40,  40,
    28,  32,  36,  48,  48,  40,  40,  64,
    32,  36,  48,  48,  40,  40,  64,  64,
    36,  48,  48,  40,  40,  64,  64,  64
    /*
    8,10,12,12,14,14,14,14,
10,10,12,12,14,14,14,14,
12,12,12,12,14,14,14,14,
12,12,12,12,14,14,14,14,
14,14, 14,14, 16, 16, 16, 16,
14,14,14,14, 16, 16, 16, 16,
14,14,14,14, 16, 16,16, 16,
14,14,14,14, 16, 16, 16, 16
   
    16,  12,  14,  18,  22,  28,  32,  40,
    12,  14,  18,  22,  28,  32,  40,  48,
    14,  18,  22,  28,  32,  40,  48,  64,
    18,  22,  28,  32,  40,  48,  64,  64,
    22,  28,  32,  40,  48,  64,  64,  64,
    28,  32,  40,  48,  64,  64,  64,  96,
    32,  40,  48,  64,  64,  64,  96,  128,
    40,  48,  64,  64,  64,  96,  128, 128
    */
/*
    16,  12,  16,  20,  16,  228,  16,  240,
    12,  14,  20,  16,  228,  16,  240,  16,
    16,  20,  16,  228,  16,  240,  16,  264,
    20,  16,  228,  16,  240,  16,  264,  16,
    16,  228,  16,  240,  16,  264,  16,  264,
    228,  16,  240,  16,  264,  16,  264,  16,
    16,  240,  16,  264,  16,  264,  16,  2128,
    240,  16,  264,  16,  264,  16,  2128, 16
    */
    /*
	16, 17, 18, 19, 20, 21, 22, 23,
	17, 18, 19, 20, 21, 22, 23, 24,
	18, 19, 20, 21, 22, 23, 24, 25,
	19, 20, 21, 22, 23, 24, 26, 27,
	20, 21, 22, 23, 25, 26, 27, 28,
	21, 22, 23, 24, 26, 27, 28, 30,
	22, 23, 24, 26, 27, 28, 30, 31,
	23, 24, 25, 27, 28, 30, 31, 33
 */
   /*
	22, 23, 24, 26, 27, 28, 30, 31,
	23, 24, 25, 27, 28, 30, 31, 33,
	24, 25, 27, 28, 29, 32, 32, 34,
	26, 27, 29, 30, 31, 33, 34, 35,
	28, 30, 31, 31, 31, 34, 35, 36,
	28, 30, 31, 31, 31, 32, 35, 38,
	29, 31, 31, 32, 32, 35, 38, 41,
	30, 32, 32, 32, 35, 38, 41, 45
   */
};

static const int zzzff_zigzag_direct[64] = {
   
    0,   1,  8, 16,  9,  2,  3, 10,
    17, 24, 32, 25, 18, 11,  4,  5,
    12, 19, 26, 33, 40, 48, 41, 34,
    27, 20, 13,  6,  7, 14, 21, 28,
    35, 42, 49, 56, 57, 50, 43, 36,
    29, 22, 15, 23, 30, 37, 44, 51,
    58, 59, 52, 45, 38, 31, 39, 46,
    53, 60, 61, 54, 47, 55, 62, 63
    /*
 0, 1, 8, 9, 2,16,10,17,
 3,18,24,11,25, 4,26,32,
19,33, 5,12,27, 6,34,35,
40,20,41,13,28,42,36, 7,
43,21,48,14,29,44,49,50,
37,45,22,51,15,57,52,56,
30,38,58,23,59,53,31,46,
60,54,39,61,47,62,55,63,
*/
/*
    0,   1,  8, 16,  9,  2,  3, 10,
    17, 24, 32, 25, 18, 11,  4, 48, 41, 34,
    27, 20, 13,  6,  7, 14, 21, 28,
    35, 42, 49,  23, 30, 37, 44, 51,
     39, 46,
    53, 55
    ,5,12, 19, 26, 33, 40,
    56, 57, 50, 43, 36,
    29, 22, 15,58, 59, 52, 45, 38, 31
    , 60, 61, 54, 47, 62, 63
*/
};   //

const int ff_alternate_h_scan[64] = {
    0,  1,   2,  3,  8,  9, 16, 17,
    10, 11,  4,  5,  6,  7, 15, 14,
    13, 12, 19, 18, 24, 25, 32, 33,
    26, 27, 20, 21, 22, 23, 28, 29,
    30, 31, 34, 35, 40, 41, 48, 49,
    42, 43, 36, 37, 38, 39, 44, 45,
    46, 47, 50, 51, 56, 57, 58, 59,
    52, 53, 54, 55, 60, 61, 62, 63,
};

const int ff_alternate_v_scan[64] = {
    0,  8,  16, 24,  1,  9,  2, 10,
    17, 25, 32, 40, 48, 56, 57, 49,
    41, 33, 26, 18,  3, 11,  4, 12,
    19, 27, 34, 42, 50, 58, 35, 43,
    51, 59, 20, 28,  5, 13,  6, 14,
    21, 29, 36, 44, 52, 60, 37, 45,
    53, 61, 22, 30,  7, 15, 23, 31,
    38, 46, 54, 62, 39, 47, 55, 63,
};

static const int tabzz4x4[]={
   /*
 0, 1, 4, 2, 3, 5,12, 8,
 6, 9,10, 7,13,11,14,15,
16,17,20,18,19,21,24,28,
25,22,26,23,29,27,30,31,
32,33,36,37,34,35,40,44,
38,41,42,45,39,46,43,47,
48,49,52,53,51,50,60,56,
54,57,58,55,61,59,62,63,
*/

   /*
 0, 1, 2, 4, 5, 3, 8, 6,
 9, 7,12,10,13,11,14,15,
16,17,18,20,21,19,24,22,
25,23,28,26,29,27,30,31,
32,33,34,36,37,35,40,38,
41,39,44,42,45,43,46,47,
48,49,50,52,53,51,56,54,
57,55,60,58,61,59,62,63,
*/
/*
 0, 1, 4, 2, 3, 5, 6, 7,
 8, 9,10,11,12,13,14,15,
16,17,20,18,19,21,22,23,
24,25,26,27,28,29,30,31,
32,33,36,34,35,37,38,39,
40,41,42,43,44,45,46,47,
48,49,52,50,51,53,54,55,
56,57,58,59,60,61,62,63,
*/
   /*
   0  1  2  3
   4  5  6  7 
   8  9  10 11
   12 13 14 15
   */
/*   
   0,1,4,5, 2,3,6,7, 8,9,12,13, 10,11,14,15,
   0+16,1+16,4+16,5+16, 2+16,3+16,6+16,7+16, 8+16,9+16,12+16,13+16, 10+16,11+16,14+16,15+16,
   0+32,1+32,4+32,5+32, 2+32,3+32,6+32,7+32, 8+32,9+32,12+32,13+32, 10+32,11+32,14+32,15+32,
   0+48,1+48,4+48,5+48, 2+48,3+48,6+48,7+48, 8+48,9+48,12+48,13+48, 10+48,11+48,14+48,15+48,
  */ 
   /*
     0,     8,    16,    24,
       1,     9,    17,     2,
      25,    10,    18,     3,
      26,    11,    19,    27

      0, 4, 8,12,
      1, 5, 9, 2,
      13,6,10, 3,
      14,7,11,15,
   */
   
   //vc1
   /*
      0, 4, 8,12,
      1, 5, 9, 2,
      13,6,10, 3,
      14,7,11,15,

      0+16, 4+16, 8+16,12+16,
      1+16, 5+16, 9+16, 2+16,
      13+16,6+16,10+16, 3+16,
      14+16,7+16,11+16,15+16,

      0+32, 4+32, 8+32,12+32,
      1+32, 5+32, 9+32, 2+32,
      13+32,6+32,10+32, 3+32,
      14+32,7+32,11+32,15+32,

      0+48, 4+48, 8+48,12+48,
      1+48, 5+48, 9+48, 2+48,
      13+48,6+48,10+48, 3+48,
      14+48,7+48,11+48,15+48,
     */
  
    //264
   /*
 0, 4, 1, 5, 2, 8,12, 9,
 6, 3, 7,10,13,14,11,15,
16,20,17,21,18,24,28,25,
22,19,23,26,29,30,27,31,
32,36,33,37,34,40,44,41,
38,35,39,42,45,46,43,47,
48,52,49,53,50,56,60,57,
54,51,55,58,61,62,59,63,
*/
   /*
   0  1  2  3
   4  5  6  7 
   8  9  10 11
   12 13 14 15
   */
   
0,   1,   4,   5,    2,   8,   6,   9,    3,   12,   7,   10,    13,   11,   14,   15,
0+16,1+16,4+16,5+16, 2+16,8+16,6+16,9+16, 3+16,12+16,7+16,10+16, 13+16,11+16,14+16,15+16,
0+32,1+32,4+32,5+32, 2+32,8+32,6+32,9+32, 3+32,12+32,7+32,10+32, 13+32,11+32,14+32,15+32,
0+48,1+48,4+48,5+48, 2+48,8+48,6+48,9+48, 3+48,12+48,7+48,10+48, 13+48,11+48,14+48,15+48,

/*
0,1,2,4, 8,5,6,9, 3,12,7,10, 13,11,14,15,
0+16,1+16,2+16,4+16, 8+16,5+16,6+16,9+16, 3+16,12+16,7+16,10+16, 13+16,11+16,14+16,15+16,
0+32,1+32,2+32,4+32, 8+32,5+32,6+32,9+32, 3+32,12+32,7+32,10+32, 13+32,11+32,14+32,15+32,
0+48,1+48,2+48,4+48, 8+48,5+48,6+48,9+48, 3+48,12+48,7+48,10+48, 13+48,11+48,14+48,15+48,
*/
   /*
   0,1,4,8, 5,2,3,6, 9,12,13,10, 7,11,14,15,
   0+16,1+16,4+16,8+16, 5+16,2+16,3+16,6+16, 9+16,12+16,13+16,10+16, 7+16,11+16,14+16,15+16,
   0+32,1+32,4+32,8+32, 5+32,2+32,3+32,6+32, 9+32,12+32,13+32,10+32, 7+32,11+32,14+32,15+32,
   0+48,1+48,4+48,8+48, 5+48,2+48,3+48,6+48, 9+48,12+48,13+48,10+48, 7+48,11+48,14+48,15+48,
*/
};
const int tabzz4x4_second[]={
0, 16,32,48, 4,20,36,52,
17, 1,49,33,24, 8,56,40,
 2,21, 5,18,28,53,12,37,
34,50,60,44,19, 3,35,51,
 6,22,25,54, 9,38,57,41,
23, 7,29,55,39,13,61,45,
26,10,58,42,27,11,14,59,
30,43,62,46,15,31,63,47,
};
const int zig_zag_haar[]={
 0,32, 4,36,52, 2,20,34,
 6,38, 1,23,17, 7, 5,21,
39, 3,33,19,55,49,37,53,
51,35,48,18,50,54,22,16,
56,58,62,60, 8,42,40,10,
14,12,44,46,24,28,30,26,
57,63, 9,11,15,61,59,13,
31,41,47,25,45,29,27,43,
};
const int zig_zag_dctx[]={
 0, 1, 8, 9, 3, 2,24,16,
11,25,10,17, 4,32, 5,40,
12,33,13, 7,27,41,56,19,
26, 6,18,28,48,35,29,20,
15,43,34,57,21,14,36,42,
49,37,44,45,31,59,30,23,
51,22,58,50,39,60,38,47,
52,61,46,53,63,55,62,54,
};
const int zig_zag_t_tr[]={
 0, 1, 2, 3, 4, 5, 6, 7,
 8, 9,10,11,12,13,14,15,
16,17,18,19,20,21,22,23,
24,25,26,27,28,29,30,31,
32,33,34,35,36,37,38,39,
40,41,42,43,44,45,46,47,
48,49,50,51,52,53,54,55,
56,57,58,59,60,61,62,63,
};
const int zig_zag_twave[]={
   /*
 0, 1, 8, 3,24, 9, 2,16,
11,25,10,17,27, 6, 7,19,
26,48, 5,56,40, 4,18,32,
14,49,15,57,13,41,30,51,
31,59,12,22,33,50,29,43,
23,58,21,54,42,28,55,35,
62,63,20,53,46,34,47,61,
52,45,38,60,39,44,37,36,
*/
   /*
 0, 8, 1, 3, 9,24, 2,16,
11,25,10,17,27,26,19,18,
 6, 7, 5,48,14,56,15,40,
54, 4,30,49,13,55,62,57,
31,32,51,22,41,63,59,50,
46,29,53,23,12,47,58,61,
43,21,33,28,42,52,45,38,
60,35,39,20,44,34,37,36,
*/
63,31,59,27,55,62,15,57,
30,51,11,47,61,25, 7,58,
23,29,43,54,56,14,49,26,
 3,19, 0,53,46,24, 9,13,
50,41,22,45,48, 5,60,17,
 6,39,10,42, 1,40,21,35,
 8,28,16,18, 4,52,38,33,
 2,37,12,44,32,34,20,36,
};
const int zig_zag_haar2d[]={
27,31,59,63,43,15,11, 9,
57,29,25,23,58,19,26,47,
51,30,61, 0,45,13,41,62,
55, 7,42,10, 3,14,39,46,
35,21, 1, 8,56,53,60,17,
24,49,28,18,22,50, 2,16,
 5,44,33,40,37,12,54,34,
 6,20,52,48,38,36,32, 4,
};
//utils
#ifdef _CREATE_ZZ_TBL
#include <stdlib.h>
int compare_ints( const void* a, const void* b ) {
   //int  arg1 = *(int*) a;
   //int  arg2 = *(int*) b;
   if( *(int*)a < *(int*)b ) return -1;
   else if( *(int*)a == *(int*)b ) return 0;
   else return 1;
}  

inline void sortval(int *a, int iCnt)
{
   qsort( a, iCnt, sizeof(int), compare_ints ); 
}

void createZigZag(int *in, int *out)
{   
   int tmp[64];
   int i,j;
   for(i=0;i<64;i++){tmp[i]=in[i];out[i]=99;}
   sortval(&tmp[0],64);
   
   for(i=0;i<64;i++){
      for(j=0;j<64;j++)
      {
         if(tmp[j]==in[i] && out[63-j]==99){out[63-j]=i;break;}
      }
   }
}


#endif
#define T_MAX_AVAL 2048
#define T_MAX_AVAL_H 1024



/****************************************************************************
 * 8x8 prediction for intra luma block
 ****************************************************************************/
#define uint8_t unsigned char
#define MB_TOPLEFT 1
#define MB_TOPRIGHT 2

#define SRC(x,y) src[(x)*3+(y)*i_stride]
#define PL(y) \
    const int l##y = (SRC(-1,y-1) + 2*SRC(-1,y) + SRC(-1,y+1) + 2) >> 2;
#define PREDICT_8x8_LOAD_LEFT \
    const int l0 = ((i_neighbor&MB_TOPLEFT ? SRC(-1,-1) : SRC(-1,0)) \
                     + 2*SRC(-1,0) + SRC(-1,1) + 2) >> 2; \
    PL(1) PL(2) PL(3) PL(4) PL(5) PL(6) \
    const int l7 = (SRC(-1,6) + 3*SRC(-1,7) + 2) >> 2;

#define PT(x) \
    const int t##x = (SRC(x-1,-1) + 2*SRC(x,-1) + SRC(x+1,-1) + 2) >> 2;
#define PREDICT_8x8_LOAD_TOP \
    const int t0 = ((i_neighbor&MB_TOPLEFT ? SRC(-1,-1) : SRC(0,-1)) \
                     + 2*SRC(0,-1) + SRC(1,-1) + 2) >> 2; \
    PT(1) PT(2) PT(3) PT(4) PT(5) PT(6) \
    const int t7 = ((i_neighbor&MB_TOPRIGHT ? SRC(8,-1) : SRC(7,-1)) \
                     + 2*SRC(7,-1) + SRC(6,-1) + 2) >> 2; \

#define PTR(x) \
    t##x = (SRC(x-1,-1) + 2*SRC(x,-1) + SRC(x+1,-1) + 2) >> 2;
#define PREDICT_8x8_LOAD_TOPRIGHT \
    int t8, t9, t10, t11, t12, t13, t14, t15; \
    if(i_neighbor&MB_TOPRIGHT) { \
        PTR(8) PTR(9) PTR(10) PTR(11) PTR(12) PTR(13) PTR(14) \
        t15 = (SRC(14,-1) + 3*SRC(15,-1) + 2) >> 2; \
    } else t8=t9=t10=t11=t12=t13=t14=t15= SRC(7,-1);

#define PREDICT_8x8_LOAD_TOPLEFT \
    const int lt = (SRC(-1,0) + 2*SRC(-1,-1) + SRC(0,-1) + 2) >> 2;

#define PREDICT_8x8_DC(v) \
   int _i,_j;\
   for(_i=0;_i<8;_i++)\
      for(_j=0;_j<24;_j+=3){\
         src[_i*i_stride+_j]=v;\
         }

#define uint32_t unsigned int
static void predict_8x8_dc_128( uint8_t *src, int i_stride, int i_neighbor )
{
    PREDICT_8x8_DC(0x80);
    /*
   int i,j;
   for(j=0;j<8;j++){
      for(i=0;i<8;i++){
         SRC(i,j)=((int)(SRC(-1,j))*(8-i)+(int)(SRC(i,-1))*(8-j)+
                    (int)(SRC(8,j))*(i)+(int)(SRC(i,8))*(1)+8)>>4;
      }
   }
   */

}
static void predict_8x8_dc_left( uint8_t *src, int i_stride, int i_neighbor )
{
    PREDICT_8x8_LOAD_LEFT
    const uint32_t dc = ((l0+l1+l2+l3+l4+l5+l6+l7+4) >> 3);
    PREDICT_8x8_DC(dc);
}
static void predict_8x8_dc_top( uint8_t *src, int i_stride, int i_neighbor )
{
    PREDICT_8x8_LOAD_TOP
    const uint32_t dc = ((t0+t1+t2+t3+t4+t5+t6+t7+4) >> 3);
    PREDICT_8x8_DC(dc);
}
static void predict_8x8_xdc(uint32_t dc, uint8_t *src, int i_stride, int i_neighbor )
{
   PREDICT_8x8_DC(dc);
}
static void predict_8x8_dc( uint8_t *src, int i_stride, int i_neighbor )
{
    PREDICT_8x8_LOAD_LEFT
    PREDICT_8x8_LOAD_TOP
    const uint32_t dc = ((l0+l1+l2+l3+l4+l5+l6+l7
                         +t0+t1+t2+t3+t4+t5+t6+t7+8) >> 4) ;
    PREDICT_8x8_DC(dc);
}
static int get_8x8_dc_left( uint8_t *src, int i_stride, int i_neighbor )
{
    PREDICT_8x8_LOAD_LEFT
    return  ((l0+l1+l2+l3+l4+l5+l6+l7+4) >> 3);
}
static int get_8x8_dc_top( uint8_t *src, int i_stride, int i_neighbor )
{
    PREDICT_8x8_LOAD_TOP
    return  ((t0+t1+t2+t3+t4+t5+t6+t7+4) >> 3);
}

static void predict_8x8_h( uint8_t *src, int i_stride, int i_neighbor )
{
    PREDICT_8x8_LOAD_LEFT
       /*
#define ROW(y) ((uint32_t*)(src+y*i_stride))[0] =\
               ((uint32_t*)(src+y*i_stride))[1] = 0x01010101U * l##y
    ROW(0); ROW(1); ROW(2); ROW(3); ROW(4); ROW(5); ROW(6); ROW(7);
#undef ROW
    */
    int i;
    for(i=0;i<24;i+=3)
    {
       src[i_stride*0+i]=l0;
       src[i_stride*1+i]=l1;
       src[i_stride*2+i]=l2;
       src[i_stride*3+i]=l3;
       src[i_stride*4+i]=l4;
       src[i_stride*5+i]=l5;
       src[i_stride*6+i]=l6;
       src[i_stride*7+i]=l7;
    }
}
static void predict_8x8_v( uint8_t *src, int i_stride, int i_neighbor )
{
  //  int y;
    PREDICT_8x8_LOAD_TOP;
    int i;
    for(i=0;i<8;i++){
       src[0]=t0;
       src[3]=t1;
       src[6]=t2;
       src[9]=t3;
       src[12]=t4;
       src[15]=t5;
       src[18]=t6;
       src[21]=t7;
       src+=i_stride;
    }
}
static void predict_8x8_ddl( uint8_t *src, int i_stride, int i_neighbor )
{
    PREDICT_8x8_LOAD_TOP
    PREDICT_8x8_LOAD_TOPRIGHT
    SRC(0,0)= (t0 + 2*t1 + t2 + 2) >> 2;
    SRC(0,1)=SRC(1,0)= (t1 + 2*t2 + t3 + 2) >> 2;
    SRC(0,2)=SRC(1,1)=SRC(2,0)= (t2 + 2*t3 + t4 + 2) >> 2;
    SRC(0,3)=SRC(1,2)=SRC(2,1)=SRC(3,0)= (t3 + 2*t4 + t5 + 2) >> 2;
    SRC(0,4)=SRC(1,3)=SRC(2,2)=SRC(3,1)=SRC(4,0)= (t4 + 2*t5 + t6 + 2) >> 2;
    SRC(0,5)=SRC(1,4)=SRC(2,3)=SRC(3,2)=SRC(4,1)=SRC(5,0)= (t5 + 2*t6 + t7 + 2) >> 2;
    SRC(0,6)=SRC(1,5)=SRC(2,4)=SRC(3,3)=SRC(4,2)=SRC(5,1)=SRC(6,0)= (t6 + 2*t7 + t8 + 2) >> 2;
    SRC(0,7)=SRC(1,6)=SRC(2,5)=SRC(3,4)=SRC(4,3)=SRC(5,2)=SRC(6,1)=SRC(7,0)= (t7 + 2*t8 + t9 + 2) >> 2;
    SRC(1,7)=SRC(2,6)=SRC(3,5)=SRC(4,4)=SRC(5,3)=SRC(6,2)=SRC(7,1)= (t8 + 2*t9 + t10 + 2) >> 2;
    SRC(2,7)=SRC(3,6)=SRC(4,5)=SRC(5,4)=SRC(6,3)=SRC(7,2)= (t9 + 2*t10 + t11 + 2) >> 2;
    SRC(3,7)=SRC(4,6)=SRC(5,5)=SRC(6,4)=SRC(7,3)= (t10 + 2*t11 + t12 + 2) >> 2;
    SRC(4,7)=SRC(5,6)=SRC(6,5)=SRC(7,4)= (t11 + 2*t12 + t13 + 2) >> 2;
    SRC(5,7)=SRC(6,6)=SRC(7,5)= (t12 + 2*t13 + t14 + 2) >> 2;
    SRC(6,7)=SRC(7,6)= (t13 + 2*t14 + t15 + 2) >> 2;
    SRC(7,7)= (t14 + 3*t15 + 2) >> 2;
}
static void predict_8x8_ddr( uint8_t *src, int i_stride, int i_neighbor )
{
    PREDICT_8x8_LOAD_TOP
    PREDICT_8x8_LOAD_LEFT
    PREDICT_8x8_LOAD_TOPLEFT
    SRC(0,7)= (l7 + 2*l6 + l5 + 2) >> 2;
    SRC(0,6)=SRC(1,7)= (l6 + 2*l5 + l4 + 2) >> 2;
    SRC(0,5)=SRC(1,6)=SRC(2,7)= (l5 + 2*l4 + l3 + 2) >> 2;
    SRC(0,4)=SRC(1,5)=SRC(2,6)=SRC(3,7)= (l4 + 2*l3 + l2 + 2) >> 2;
    SRC(0,3)=SRC(1,4)=SRC(2,5)=SRC(3,6)=SRC(4,7)= (l3 + 2*l2 + l1 + 2) >> 2;
    SRC(0,2)=SRC(1,3)=SRC(2,4)=SRC(3,5)=SRC(4,6)=SRC(5,7)= (l2 + 2*l1 + l0 + 2) >> 2;
    SRC(0,1)=SRC(1,2)=SRC(2,3)=SRC(3,4)=SRC(4,5)=SRC(5,6)=SRC(6,7)= (l1 + 2*l0 + lt + 2) >> 2;
    SRC(0,0)=SRC(1,1)=SRC(2,2)=SRC(3,3)=SRC(4,4)=SRC(5,5)=SRC(6,6)=SRC(7,7)= (l0 + 2*lt + t0 + 2) >> 2;
    SRC(1,0)=SRC(2,1)=SRC(3,2)=SRC(4,3)=SRC(5,4)=SRC(6,5)=SRC(7,6)= (lt + 2*t0 + t1 + 2) >> 2;
    SRC(2,0)=SRC(3,1)=SRC(4,2)=SRC(5,3)=SRC(6,4)=SRC(7,5)= (t0 + 2*t1 + t2 + 2) >> 2;
    SRC(3,0)=SRC(4,1)=SRC(5,2)=SRC(6,3)=SRC(7,4)= (t1 + 2*t2 + t3 + 2) >> 2;
    SRC(4,0)=SRC(5,1)=SRC(6,2)=SRC(7,3)= (t2 + 2*t3 + t4 + 2) >> 2;
    SRC(5,0)=SRC(6,1)=SRC(7,2)= (t3 + 2*t4 + t5 + 2) >> 2;
    SRC(6,0)=SRC(7,1)= (t4 + 2*t5 + t6 + 2) >> 2;
    SRC(7,0)= (t5 + 2*t6 + t7 + 2) >> 2;
  
}
static void predict_8x8_vr( uint8_t *src, int i_stride, int i_neighbor )
{
    PREDICT_8x8_LOAD_TOP
    PREDICT_8x8_LOAD_LEFT
    PREDICT_8x8_LOAD_TOPLEFT
    /* produce warning as l7 is unused */
    SRC(0,6)= (l5 + 2*l4 + l3 + 2) >> 2;
    SRC(0,7)= (l6 + 2*l5 + l4 + 2) >> 2;
    SRC(0,4)=SRC(1,6)= (l3 + 2*l2 + l1 + 2) >> 2;
    SRC(0,5)=SRC(1,7)= (l4 + 2*l3 + l2 + 2) >> 2;
    SRC(0,2)=SRC(1,4)=SRC(2,6)= (l1 + 2*l0 + lt + 2) >> 2;
    SRC(0,3)=SRC(1,5)=SRC(2,7)= (l2 + 2*l1 + l0 + 2) >> 2;
    SRC(0,1)=SRC(1,3)=SRC(2,5)=SRC(3,7)= (l0 + 2*lt + t0 + 2) >> 2;
    SRC(0,0)=SRC(1,2)=SRC(2,4)=SRC(3,6)= (lt + t0 + 1) >> 1;
    SRC(1,1)=SRC(2,3)=SRC(3,5)=SRC(4,7)= (lt + 2*t0 + t1 + 2) >> 2;
    SRC(1,0)=SRC(2,2)=SRC(3,4)=SRC(4,6)= (t0 + t1 + 1) >> 1;
    SRC(2,1)=SRC(3,3)=SRC(4,5)=SRC(5,7)= (t0 + 2*t1 + t2 + 2) >> 2;
    SRC(2,0)=SRC(3,2)=SRC(4,4)=SRC(5,6)= (t1 + t2 + 1) >> 1;
    SRC(3,1)=SRC(4,3)=SRC(5,5)=SRC(6,7)= (t1 + 2*t2 + t3 + 2) >> 2;
    SRC(3,0)=SRC(4,2)=SRC(5,4)=SRC(6,6)= (t2 + t3 + 1) >> 1;
    SRC(4,1)=SRC(5,3)=SRC(6,5)=SRC(7,7)= (t2 + 2*t3 + t4 + 2) >> 2;
    SRC(4,0)=SRC(5,2)=SRC(6,4)=SRC(7,6)= (t3 + t4 + 1) >> 1;
    SRC(5,1)=SRC(6,3)=SRC(7,5)= (t3 + 2*t4 + t5 + 2) >> 2;
    SRC(5,0)=SRC(6,2)=SRC(7,4)= (t4 + t5 + 1) >> 1;
    SRC(6,1)=SRC(7,3)= (t4 + 2*t5 + t6 + 2) >> 2;
    SRC(6,0)=SRC(7,2)= (t5 + t6 + 1) >> 1;
    SRC(7,1)= (t5 + 2*t6 + t7 + 2) >> 2;
    SRC(7,0)= (t6 + t7 + 1) >> 1;
}
static void predict_8x8_hd( uint8_t *src, int i_stride, int i_neighbor )
{
    PREDICT_8x8_LOAD_TOP
    PREDICT_8x8_LOAD_LEFT
    PREDICT_8x8_LOAD_TOPLEFT
    /* produce warning as t7 is unused */
    SRC(0,7)= (l6 + l7 + 1) >> 1;
    SRC(1,7)= (l5 + 2*l6 + l7 + 2) >> 2;
    SRC(0,6)=SRC(2,7)= (l5 + l6 + 1) >> 1;
    SRC(1,6)=SRC(3,7)= (l4 + 2*l5 + l6 + 2) >> 2;
    SRC(0,5)=SRC(2,6)=SRC(4,7)= (l4 + l5 + 1) >> 1;
    SRC(1,5)=SRC(3,6)=SRC(5,7)= (l3 + 2*l4 + l5 + 2) >> 2;
    SRC(0,4)=SRC(2,5)=SRC(4,6)=SRC(6,7)= (l3 + l4 + 1) >> 1;
    SRC(1,4)=SRC(3,5)=SRC(5,6)=SRC(7,7)= (l2 + 2*l3 + l4 + 2) >> 2;
    SRC(0,3)=SRC(2,4)=SRC(4,5)=SRC(6,6)= (l2 + l3 + 1) >> 1;
    SRC(1,3)=SRC(3,4)=SRC(5,5)=SRC(7,6)= (l1 + 2*l2 + l3 + 2) >> 2;
    SRC(0,2)=SRC(2,3)=SRC(4,4)=SRC(6,5)= (l1 + l2 + 1) >> 1;
    SRC(1,2)=SRC(3,3)=SRC(5,4)=SRC(7,5)= (l0 + 2*l1 + l2 + 2) >> 2;
    SRC(0,1)=SRC(2,2)=SRC(4,3)=SRC(6,4)= (l0 + l1 + 1) >> 1;
    SRC(1,1)=SRC(3,2)=SRC(5,3)=SRC(7,4)= (lt + 2*l0 + l1 + 2) >> 2;
    SRC(0,0)=SRC(2,1)=SRC(4,2)=SRC(6,3)= (lt + l0 + 1) >> 1;
    SRC(1,0)=SRC(3,1)=SRC(5,2)=SRC(7,3)= (l0 + 2*lt + t0 + 2) >> 2;
    SRC(2,0)=SRC(4,1)=SRC(6,2)= (t1 + 2*t0 + lt + 2) >> 2;
    SRC(3,0)=SRC(5,1)=SRC(7,2)= (t2 + 2*t1 + t0 + 2) >> 2;
    SRC(4,0)=SRC(6,1)= (t3 + 2*t2 + t1 + 2) >> 2;
    SRC(5,0)=SRC(7,1)= (t4 + 2*t3 + t2 + 2) >> 2;
    SRC(6,0)= (t5 + 2*t4 + t3 + 2) >> 2;
    SRC(7,0)= (t6 + 2*t5 + t4 + 2) >> 2;
}
static void predict_8x8_vl( uint8_t *src, int i_stride, int i_neighbor )
{
    PREDICT_8x8_LOAD_TOP
    PREDICT_8x8_LOAD_TOPRIGHT
    SRC(0,0)= (t0 + t1 + 1) >> 1;
    SRC(0,1)= (t0 + 2*t1 + t2 + 2) >> 2;
    SRC(0,2)=SRC(1,0)= (t1 + t2 + 1) >> 1;
    SRC(0,3)=SRC(1,1)= (t1 + 2*t2 + t3 + 2) >> 2;
    SRC(0,4)=SRC(1,2)=SRC(2,0)= (t2 + t3 + 1) >> 1;
    SRC(0,5)=SRC(1,3)=SRC(2,1)= (t2 + 2*t3 + t4 + 2) >> 2;
    SRC(0,6)=SRC(1,4)=SRC(2,2)=SRC(3,0)= (t3 + t4 + 1) >> 1;
    SRC(0,7)=SRC(1,5)=SRC(2,3)=SRC(3,1)= (t3 + 2*t4 + t5 + 2) >> 2;
    SRC(1,6)=SRC(2,4)=SRC(3,2)=SRC(4,0)= (t4 + t5 + 1) >> 1;
    SRC(1,7)=SRC(2,5)=SRC(3,3)=SRC(4,1)= (t4 + 2*t5 + t6 + 2) >> 2;
    SRC(2,6)=SRC(3,4)=SRC(4,2)=SRC(5,0)= (t5 + t6 + 1) >> 1;
    SRC(2,7)=SRC(3,5)=SRC(4,3)=SRC(5,1)= (t5 + 2*t6 + t7 + 2) >> 2;
    SRC(3,6)=SRC(4,4)=SRC(5,2)=SRC(6,0)= (t6 + t7 + 1) >> 1;
    SRC(3,7)=SRC(4,5)=SRC(5,3)=SRC(6,1)= (t6 + 2*t7 + t8 + 2) >> 2;
    SRC(4,6)=SRC(5,4)=SRC(6,2)=SRC(7,0)= (t7 + t8 + 1) >> 1;
    SRC(4,7)=SRC(5,5)=SRC(6,3)=SRC(7,1)= (t7 + 2*t8 + t9 + 2) >> 2;
    SRC(5,6)=SRC(6,4)=SRC(7,2)= (t8 + t9 + 1) >> 1;
    SRC(5,7)=SRC(6,5)=SRC(7,3)= (t8 + 2*t9 + t10 + 2) >> 2;
    SRC(6,6)=SRC(7,4)= (t9 + t10 + 1) >> 1;
    SRC(6,7)=SRC(7,5)= (t9 + 2*t10 + t11 + 2) >> 2;
    SRC(7,6)= (t10 + t11 + 1) >> 1;
    SRC(7,7)= (t10 + 2*t11 + t12 + 2) >> 2;
}
static void predict_8x8_hu( uint8_t *src, int i_stride, int i_neighbor )
{
    PREDICT_8x8_LOAD_LEFT
    SRC(0,0)= (l0 + l1 + 1) >> 1;
    SRC(1,0)= (l0 + 2*l1 + l2 + 2) >> 2;
    SRC(0,1)=SRC(2,0)= (l1 + l2 + 1) >> 1;
    SRC(1,1)=SRC(3,0)= (l1 + 2*l2 + l3 + 2) >> 2;
    SRC(0,2)=SRC(2,1)=SRC(4,0)= (l2 + l3 + 1) >> 1;
    SRC(1,2)=SRC(3,1)=SRC(5,0)= (l2 + 2*l3 + l4 + 2) >> 2;
    SRC(0,3)=SRC(2,2)=SRC(4,1)=SRC(6,0)= (l3 + l4 + 1) >> 1;
    SRC(1,3)=SRC(3,2)=SRC(5,1)=SRC(7,0)= (l3 + 2*l4 + l5 + 2) >> 2;
    SRC(0,4)=SRC(2,3)=SRC(4,2)=SRC(6,1)= (l4 + l5 + 1) >> 1;
    SRC(1,4)=SRC(3,3)=SRC(5,2)=SRC(7,1)= (l4 + 2*l5 + l6 + 2) >> 2;
    SRC(0,5)=SRC(2,4)=SRC(4,3)=SRC(6,2)= (l5 + l6 + 1) >> 1;
    SRC(1,5)=SRC(3,4)=SRC(5,3)=SRC(7,2)= (l5 + 2*l6 + l7 + 2) >> 2;
    SRC(0,6)=SRC(2,5)=SRC(4,4)=SRC(6,3)= (l6 + l7 + 1) >> 1;
    SRC(1,6)=SRC(3,5)=SRC(5,4)=SRC(7,3)= (l6 + 3*l7 + 2) >> 2;
    SRC(0,7)=SRC(1,7)=SRC(2,6)=SRC(2,7)=SRC(3,6)=
    SRC(3,7)=SRC(4,5)=SRC(4,6)=SRC(4,7)=SRC(5,5)=
    SRC(5,6)=SRC(5,7)=SRC(6,4)=SRC(6,5)=SRC(6,6)=
    SRC(6,7)=SRC(7,4)=SRC(7,5)=SRC(7,6)=SRC(7,7)= l7;
}



typedef void (fPRED )(uint8_t *src, int i_stride, int i_neighbor);
fPRED *fncPred[12];
//static int iPredFlags[12];
void loadPred(){
   void loadPred16();
   loadPred16();
   fncPred[0]=&predict_8x8_h;
   fncPred[1]=&predict_8x8_v;
   fncPred[2]=&predict_8x8_ddl;
   fncPred[3]=&predict_8x8_ddr;
   fncPred[4]=&predict_8x8_vr;
   fncPred[5]=&predict_8x8_hd;
   fncPred[6]=&predict_8x8_vl;
   fncPred[7]=&predict_8x8_hu;
   fncPred[8]=&predict_8x8_dc_left;
   fncPred[9]=&predict_8x8_dc_top;
   fncPred[10]=&predict_8x8_dc;
   fncPred[11]=&predict_8x8_dc_128;


}
static inline int mmabs(int a){return (a>=0)?a:-a;}
//#define mmabs abs
static inline int sadGain(unsigned char *p1, register short *ref, int stride)
{
   register int i,j;
   register int iSad=0;
   //stride -=24;
   for(i=0;i<8;i++){
      for(j=0;j<24;j+=3){
         iSad+=mmabs((int)p1[j]-*ref);
         ref++;

      }
      p1+=stride;
      
   }
   return iSad;
}
static inline int sadGainUU(unsigned char *p1, unsigned char *ref, int stride , unsigned char * t)
{
   register int i,j;
   register int iSad=0;
   //stride -=24;
   for(i=0;i<8;i++){
      for(j=0;j<24;j+=3){
         iSad+=t[p1[j]-ref[j]];
         //iSad+=mmabs((int)p1[j]-ref[j]);
         //ref++;

      }
      p1+=stride;
      ref+=stride;
      
   }
   return iSad;
}
static inline int sadGainUU_16(unsigned char *p1, unsigned char *ref, int stride , unsigned char * t)
{
   register int i,j;
   register int iSad=0;
   //stride -=24;
   for(i=0;i<16;i++){
      for(j=0;j<48;j+=3){
         iSad+=t[p1[j]-ref[j]];
         //iSad+=mmabs((int)p1[j]-ref[j]);
         //ref++;

      }
      p1+=stride;
      ref+=stride;
      
   }
   return iSad;
}

static inline int sadFX(unsigned char *p1, register int *ref, int stride, int iMax){
   register int i,j;
   register int iSad=0;
   //stride -=24;
   for(i=0;i<8;i++){
      for(j=0;j<24;j+=3){
         iSad+=mmabs((int)p1[j]-*ref);
         ref++;

      }
      if(iSad>iMax)return iSad;
      p1+=stride;
      
   }
   return iSad;
}
static inline int sadF4x4_sq(unsigned char *p1, unsigned char *ref, const int stride, int iMax){
   /*
   register int i,j;
   register int iSad=0;
   //stride -=24;
   for(i=0;i<4;i++){
      for(j=0;j<12;j+=3){
         const int d=p1[j]-ref[j];
         iSad+=mmabs(d);//*d;
         

      }
      if(iSad>iMax)return iSad;
      p1+=stride;
      ref+=stride;
      
   }
   return iSad;
   */
   int sadHada4_t(unsigned char *src,unsigned char *src2, int stride);
   return sadHada4_t(p1,ref,stride);
}

static inline int sadInt(unsigned char *p1, unsigned char *ref, int stride, int iMax){
   register int i,j;
   register int iSad=0;
   //stride -=24;
   for(i=0;i<8;i++){
      for(j=0;j<24;j+=3){
         iSad+=mmabs(p1[j]-ref[j]);

      }
      if(iSad>iMax)return iSad;
      p1+=stride;
      ref+=stride;
      
   }
   return iSad;
}
static int testSendPic(unsigned char *p1, unsigned char *ref, const int stride){
   register int j;
   register int iSad=0;
   register int iSadSq=0;
   int i,d;
   //stride -=24;
   for(i=0;i<16;i++){
      for(j=0;j<48;j+=3){
         d=p1[j]-ref[j];
         iSad+=d;//abs(d);
         iSadSq+=d*d;

      }
      p1+=stride;
      ref+=stride;
      
   }
   //return iSad<iSadSq;
   //1215 ,sad=9 sq=1+4+1+25=31  9/4=2.25 , 31/4=7.75 v=2.7
   //1111 sad=4 sq=4 1-1*1=0
   //9999 9*4/4=9 81*4/4=81 81-9*9
   //9191 20/4=5 (81+81+1+1)/4=41, 41-5*5 20
    int mean = iSad >>8;
    int variance = (iSadSq >>8) - mean * mean;
    return variance>400;//400;
    
}
static int calcPicDev4(unsigned char *p1, unsigned char *ref, const int stride){
   register int j;
   register int iSad=0;
   register int iSadSq=0;
   int i,d;
   //stride -=24;
   for(i=0;i<4;i++){
      d=p1[0]-ref[0];        iSad+=d;         iSadSq+=d*d;
      d=p1[3]-ref[3];        iSad+=d;         iSadSq+=d*d;
      d=p1[6]-ref[6];        iSad+=d;         iSadSq+=d*d;
      d=p1[9]-ref[9];        iSad+=d;         iSadSq+=d*d;

      p1+=stride;
      ref+=stride;
      
   }
   //return iSad<iSadSq;
   //1215 ,sad=9 sq=1+4+1+25=31  9/4=2.25 , 31/4=7.75 v=2.7
   //1111 sad=4 sq=4 1-1*1=0
   //9999 9*4/4=9 81*4/4=81 81-9*9
   //9191 20/4=5 (81+81+1+1)/4=41, 41-5*5 20
    int mean = iSad >>4;
    int variance = (iSadSq >>4) - mean * mean;
    return variance;//400;
    
}
static inline int sadIntT(unsigned char *p1, unsigned char *ref, const int stride, const int strRef, int *t){
   register int i,j;
   register int iSad=0;
   //stride -=24;
   for(i=0;i<4;i++){
      for(j=0;j<4;j++){
         iSad+=t[p1[j*3]-ref[j]];

      }
      p1+=stride;
      ref+=strRef;
      
   }
   return iSad;
}
static inline int canSkipMD(unsigned char *p1, unsigned char *ref, const int stride, int L){
   int i,j;
   int iSad=0;
   //stride -=24;
   for(i=0;i<16;i++){
      for(j=0;j<48;j+=3){
         if(abs(p1[j]-ref[j])>L)return 0;

      }
      p1+=stride;
      ref+=stride;
      
   }
   return 1;
}
static inline int sadF(unsigned char *p1, register int *ref, int stride, int iMax){
   register int i,j;
   register int iSad=0;
   int res[64];
   int *p;
   int iMean=0;
   p=&res[0];
   //ref-cur
   //stride -=24;
   for(i=0;i<8;i++){
      for(j=0;j<24;j+=3){
         *p=(*ref)-(int)p1[j];
         iMean+=*p;
         ref++;p++;

      }
      p1+=stride;
   }
   iMean/=64;
   p=&res[0];

   for(i=0;i<64;i++,p++)iSad+=mmabs((*p)-iMean);
   return iSad+mmabs(iMean);
}
static inline int sadIntMd(unsigned char *p1,unsigned char *ref, int stride, int iMax){
   register int i,j;
   register int iSad=0;
   int res[64];
   int *p;
   int iMean=0;
   p=&res[0];
   //ref-cur
   //stride -=24;
   for(i=0;i<8;i++){
      for(j=0;j<24;j+=3){
         *p=ref[j]-p1[j];
         iMean+=*p;p++;

      }
      p1+=stride;
      ref+=stride;
   }
   iMean/=64;
   p=&res[0];

   for(i=0;i<64;i++,p++)iSad+=mmabs((*p)-iMean);
   return iSad+mmabs(iMean);
}

void dTransWH(int *p, int l);
void dITransWH(int *p, int l);


extern "C"{
//void idct_int32(short *const block);
void idct_int32_init(void);
void simple_idct_c(short * const block);

void idct_int32haar(short *in);
void fdct_int32haar(const short *in);

int CodeCoeffInterT(int *res,
		  const short *qcoeff,
		  const int * zigzag);

void
init_vlc_tables(void);
int
CodeCoeffInter_CalcBitsT(const short * qcoeff, const int * zigzag);
};
#include "t_vlc.h"
#include "t_aritm.inl"

#if 1
void t_icol(short *bl)
{
   int a1,a2,a3,a4,a5,a6,a7,a8;
   int i;
   //for(i=0;i<64;i+=8)bl[i]<<=3;


#define F(_R,_R1,_A,_B) {_R=(_A+_B +1)>>1;_R1=(_A)-(_B)+128;}
#define I(_R1,_R2,_A,_B){_R1=((_A*2+_B )>>1);_R2=(_R1-_B);}

//#define F(_R,_R1,_A,_B) {_R=(_A+_B );_R1=(_A)-(_B);}
//#define I(_R1,_R2,_A,_B){_R1=((_A+_B +1)>>1);_R2=(_R1-_B);}

/*   
   a1=(bl[0]+bl[8])>>1;
   a5=a1-bl[8];
   a2=(bl[16]+bl[24])>>1;
   a6=a2-bl[24];
   a3=(bl[32]+bl[40])>>1;
   a7=a3-bl[40];
   a4=(bl[48]+bl[56])>>1;
   a8=a4-bl[56];
   
*/
   I(a1,a5,bl[0],bl[8]);
   I(a2,a6,bl[16],bl[24]);
   I(a3,a7,bl[32],bl[40]);
   I(a4,a8,bl[48],bl[56]);


   bl[0]=a1;bl[8]=a2;bl[16]=a3;bl[24]=a4;
   bl[32]=a5;bl[40]=a6;bl[48]=a7;bl[56]=a8;

   /*
   a1=(bl[0]+bl[8])>>1;
   a3=a1-bl[8];

   a2=(bl[16]+bl[24])>>1;
   a4=a2-bl[24];
*/
   I(a1,a3,bl[0],bl[8]);
   I(a2,a4,bl[16],bl[24]);

   bl[0]=a1;bl[8]=a2;bl[16]=a3;bl[24]=a4;

   I(a1,a3,bl[32],bl[40]);
   I(a2,a4,bl[48],bl[56]);
   /*
   a1=(bl[32]+bl[40])>>1;
   a3=a1-bl[40];

   a2=(bl[48]+bl[56])>>1;
   a4=a2-bl[56];
*/
   bl[32]=a1;bl[40]=a2;bl[48]=a3;bl[56]=a4;

   for(i=0;i<64;i+=16)
   {
      I(a1,a2,bl[i+0],bl[i+8]);
   //   a1=(bl[i+0]+bl[i+8])>>1;
     // a2=a1-bl[i+8];
      bl[i]=a1;bl[i+8]=a2;
   }
   
}

void t_iwave(short *bl)
{
   int i,j;
   int a1,a2,a3,a4,a5,a6,a7,a8;
   bl[0]+=4;bl[0]>>=3;
   for(j=0;j<8;j++)t_icol(bl+j);
   /*
   {
      bl[j]=(bl[j]+bl[32+j])>>1;
      bl[32+j]=bl[j]-bl[32+j];
 //  }
   //for(j=0;j<8;j++){

      for(i=0;i<64;i+=32){
         bl[i+j]=(bl[i+j]+bl[i+16+j])>>1;
         bl[i+16+j]=bl[i+j]-bl[i+16+j];
      }
   //}
   //for(j=0;j<8;j++){

      for(i=0;i<64;i+=16){
         bl[i+j]=(bl[i+j]+bl[i+8+j])>>1;
         bl[i+8+j]=bl[i+j]-bl[i+8+j];
      }
   }
   */
//return;

   for(i=0;i<64;i+=8){
      /*
      a1=(bl[i]+bl[i+1])>>1;
      a5=a1-bl[i+1];

      a2=(bl[i+2]+bl[i+3])>>1;
      a6=a2-bl[i+3];

      a3=(bl[i+4]+bl[i+5])>>1;
      a7=a3-bl[i+5];

      a4=(bl[i+6]+bl[i+7])>>1;
      a8=a4-bl[i+7];
      */
      I(a1,a5,bl[i+0],bl[i+1]);
      I(a2,a6,bl[i+2],bl[i+3]);
      I(a3,a7,bl[i+4],bl[i+5]);
      I(a4,a8,bl[i+6],bl[i+7]);

      bl[i]=a1;bl[i+1]=a2;bl[i+2]=a3;bl[i+3]=a4;
      bl[i+4]=a5;bl[i+5]=a6;bl[i+6]=a7;bl[i+7]=a8;
   }
 //  show(bl);

   for(i=0;i<64;i+=4){
      /*
      a1=(bl[i]+bl[i+1])>>1;
      a3=a1-bl[i+1];

      a2=(bl[i+2]+bl[i+3])>>1;
      a4=a2-bl[i+3];
*/
      I(a1,a3,bl[i+0],bl[i+1]);
      I(a2,a4,bl[i+2],bl[i+3]);

      bl[i]=a1;bl[i+1]=a2;bl[i+2]=a3;bl[i+3]=a4;
   }
  
//   show(bl);
   
   for(i=0;i<64;i+=2){
//      bl[i]=(bl[i]+bl[i+1])>>1;
  //    bl[i+1]=bl[i]-bl[i+1];
      I(a1,a2,bl[i+0],bl[i+1]);
      bl[i]=a1;bl[i+1]=a2;
   }


#undef I

}
void t_fcol(short *bl)
{
   int i;
   int s1,s2,s3,s4,d1,d2,d3,d4;
   
   for(i=0;i<64;i+=16)
   {
      F(s1,d1,bl[i],bl[i+8]);
      //s1=bl[i]+bl[i+8];
      //d1=bl[i]-bl[i+8];
      bl[i]=s1;bl[i+8]=d1;
   }
   //show(&bl[0]);
   
   for(i=0;i<64;i+=32)
   {
      //s1=bl[i]+bl[i+16];
      //d1=bl[i]-bl[i+16];
      //s2=bl[i+8]+bl[i+24];
      //d2=bl[i+8]-bl[i+24];
      F(s1,d1,bl[i],bl[i+16]);
      F(s2,d2,bl[i+8],bl[i+24]);

      bl[i]=s1;bl[i+8]=d1;
      bl[i+16]=s2;bl[i+24]=d2;
   }
   //show(&bl[0]);

      F(s1,d1,bl[0],bl[32]);
      F(s2,d2,bl[8],bl[40]);
      F(s3,d3,bl[16],bl[48]);
      F(s4,d4,bl[24],bl[56]);
      /*
   s1=bl[0]+bl[32];
   d1=bl[0]-bl[32];
   s2=bl[8]+bl[40];
   d2=bl[8]-bl[40];
   s3=bl[16]+bl[48];
   d3=bl[16]-bl[48];
   s4=bl[24]+bl[56];
   d4=bl[24]-bl[56];
   */

   bl[0]=s1;bl[8]=d1;
   bl[16]=s2;bl[24]=d2;
   bl[32]=s3;bl[40]=d3;
   bl[48]=s4;bl[56]=d4;
//show(&bl[0]);
      /*
   bl[0]=s1>>3;bl[8]=d1>>3;
   bl[16]=s2>>3;bl[24]=d2>>3;
   bl[32]=s3>>3;bl[40]=d3>>3;
   bl[48]=s4>>3;bl[56]=d4>>3;
   */
}
void t_fwave(short *bl)
{
   int s,d,i,j;
   int s1,s2,s3,s4,d1,d2,d3,d4;

   
   for(i=0;i<64;i+=2){
      //s=bl[i]+bl[i+1];
      //d=bl[i]-bl[i+1];
      F(s,d,bl[i],bl[i+1]);
      bl[i]=s;bl[i+1]=d;
   }
  // show(bl);

   for(i=0;i<64;i+=4){
      //s1=bl[i]+bl[i+2];
      //d1=bl[i]-bl[i+2];

      //s2=bl[i+1]+bl[i+3];
      //d2=bl[i+1]-bl[i+3];
      F(s1,d1,bl[i],bl[i+2]);
      F(s2,d2,bl[i+1],bl[i+3]);

      bl[i]=s1;bl[i+1]=d1;bl[i+2]=s2;bl[i+3]=d2;
   }

//   show(bl);
   for(i=0;i<64;i+=8){
      /*
      s1=bl[i]+bl[i+4];
      d1=bl[i]-bl[i+4];

      s2=bl[i+1]+bl[i+5];
      d2=bl[i+1]-bl[i+5];

      s3=bl[i+2]+bl[i+6];
      d3=bl[i+2]-bl[i+6];

      s4=bl[i+3]+bl[i+7];
      d4=bl[i+3]-bl[i+7];
*/
      F(s1,d1,bl[i],bl[i+4]);
      F(s2,d2,bl[i+1],bl[i+5]);
      F(s3,d3,bl[i+2],bl[i+6]);
      F(s4,d4,bl[i+3],bl[i+7]);

      bl[i]=s1;bl[i+1]=d1;bl[i+2]=s2;bl[i+3]=d2;
      bl[i+4]=s3;bl[i+5]=d3;bl[i+6]=s4;bl[i+7]=d4;

   }
//   return;
//   show(bl);
   for(j=0;j<8;j++)t_fcol(bl+j);
   for(i=1;i<64;i++)bl[i]-=128;
   bl[0]<<=3;

#undef F
}


#else
void t_icol(short *bl, int iFlag)
{
   int a1,a2,a3,a4,a5,a6,a7,a8;
   int i;
   //for(i=0;i<64;i+=8)bl[i]<<=3;


//#define F(_R,_R1,_A,_B) {_R=(_A+_B +1)>>1;_R1=(_A)-(_B)+128;}
//#define I(_R1,_R2,_A,_B){_R1=((_A*2+_B )>>1);_R2=(_R1-_B);}
#define F(_R,_R1,_A,_B) {_R=(_A+_B +1)>>1;_R1=(_A)-(_B);}
#define I(_R1,_R2,_A,_B){_R1=((_A*2+_B) >>1);_R2=(_R1-_B);}

//#define F(_R,_R1,_A,_B) {_R=(_A+_B );_R1=(_A)-(_B);}
//#define I(_R1,_R2,_A,_B){_R1=((_A+_B )>>1);_R2=(_R1-_B);}

   if(iFlag&1)
   {
      I(a1,a5,bl[0],bl[8]);
      I(a2,a6,bl[16],bl[24]);
      I(a3,a7,bl[32],bl[40]);
      I(a4,a8,bl[48],bl[56]);


      bl[0]=a1;bl[8]=a2;bl[16]=a3;bl[24]=a4;
      bl[32]=a5;bl[40]=a6;bl[48]=a7;bl[56]=a8;
   }
   if(iFlag&2)
   {

      I(a1,a3,bl[0],bl[8]);
      I(a2,a4,bl[16],bl[24]);

      bl[0]=a1;bl[8]=a2;bl[16]=a3;bl[24]=a4;

      I(a1,a3,bl[32],bl[40]);
      I(a2,a4,bl[48],bl[56]);
      bl[32]=a1;bl[40]=a2;bl[48]=a3;bl[56]=a4;
   }
   if(iFlag&4)
   {
      for(i=0;i<64;i+=16)
      {
         I(a1,a2,bl[i+0],bl[i+8]);
         bl[i]=a1;bl[i+8]=a2;
      }
   }
   
}

void t_iwave(short *bl)
{
   int i,j;
   int iFlag=4;
   int a1,a2,a3,a4,a5,a6,a7,a8;
   for(;iFlag>0;iFlag>>=1){
      //if(iFlag==4){for(i=1;i<64;i++)bl[i]*=2;}
   for(j=0;j<8;j++)t_icol(bl+j,iFlag);
   if(iFlag&1)
   {

      for(i=0;i<64;i+=8){
         I(a1,a5,bl[i+0],bl[i+1]);
         I(a2,a6,bl[i+2],bl[i+3]);
         I(a3,a7,bl[i+4],bl[i+5]);
         I(a4,a8,bl[i+6],bl[i+7]);

         bl[i]=a1;bl[i+1]=a2;bl[i+2]=a3;bl[i+3]=a4;
         bl[i+4]=a5;bl[i+5]=a6;bl[i+6]=a7;bl[i+7]=a8;
      }
   }
 //  show(bl);
   if(iFlag&2)
   {

      for(i=0;i<64;i+=4){
         I(a1,a3,bl[i+0],bl[i+1]);
         I(a2,a4,bl[i+2],bl[i+3]);

         bl[i]=a1;bl[i+1]=a2;bl[i+2]=a3;bl[i+3]=a4;
      }
   }
  
//   show(bl);
   if(iFlag&4){
      for(i=0;i<64;i+=2){
         I(a1,a2,bl[i+0],bl[i+1]);
         bl[i]=a1;bl[i+1]=a2;
      }
   }
   }


#undef I

}
void t_fcol(short *bl, int iFlag)
{
   int i;
   int s1,s2,s3,s4,d1,d2,d3,d4;
   


   if(iFlag&4)
   {

      for(i=0;i<64;i+=16)
      {
         F(s1,d1,bl[i],bl[i+8]);
         bl[i]=s1;bl[i+8]=d1;
      }
   }
   if(iFlag&2)
   {
      for(i=0;i<64;i+=32)
      {
         F(s1,d1,bl[i],bl[i+16]);
         F(s2,d2,bl[i+8],bl[i+24]);

         bl[i]=s1;bl[i+8]=d1;
         bl[i+16]=s2;bl[i+24]=d2;
      }
   }
   //show(&bl[0]);

   if(iFlag&1)
   {
      F(s1,d1,bl[0],bl[32]);
      F(s2,d2,bl[8],bl[40]);
      F(s3,d3,bl[16],bl[48]);
      F(s4,d4,bl[24],bl[56]);

      bl[0]=s1;bl[8]=d1;
      bl[16]=s2;bl[24]=d2;
      bl[32]=s3;bl[40]=d3;
      bl[48]=s4;bl[56]=d4;
   }//show(&bl[0]);
}
void t_fwave(short *bl)
{
   int s,d,i,j;
   int s1,s2,s3,s4,d1,d2,d3,d4;
   int iFlag=1;

   for(;iFlag<8;iFlag<<=1){
   if(iFlag&4)
   {
      for(i=0;i<64;i+=2){
         F(s,d,bl[i],bl[i+1]);
         bl[i]=s;bl[i+1]=d;
      }
   }
  // show(bl);
   if(iFlag&2)
   {
      for(i=0;i<64;i+=4){
         F(s1,d1,bl[i],bl[i+2]);
         F(s2,d2,bl[i+1],bl[i+3]);

         bl[i]=s1;bl[i+1]=d1;bl[i+2]=s2;bl[i+3]=d2;
      }
   }

   if(iFlag&1){
      for(i=0;i<64;i+=8){
     
         F(s1,d1,bl[i],bl[i+4]);
         F(s2,d2,bl[i+1],bl[i+5]);
         F(s3,d3,bl[i+2],bl[i+6]);
         F(s4,d4,bl[i+3],bl[i+7]);

         bl[i]=s1;bl[i+1]=d1;bl[i+2]=s2;bl[i+3]=d2;
         bl[i+4]=s3;bl[i+5]=d3;bl[i+6]=s4;bl[i+7]=d4;

      }
   }
   for(j=0;j<8;j++)t_fcol(bl+j,iFlag);

   //if(iFlag==4){for(i=1;i<64;i++)bl[i]/=2;}
   }
   //for(i=1;i<64;i++)bl[i]-=128;

#undef F
}

#endif

inline int getFreqVal(short *bl)
{
   short tmp[512];
   int i;
   for(i=0;i<512;i++)tmp[i]=0;

   for(i=0;i<64;i++)tmp[256+bl[i]]++;
   int iMax=0;
   for(i=1;i<512;i++)if(tmp[i]>tmp[iMax])iMax=i;
   return iMax-256;
}
void doTFBlock(short *bl)
{
   int i;

   int mo,m=0;

   m=getFreqVal(bl)*64;
   //for(i=0;i<64;i++){m+=bl[i];}
   mo=m;

   if(m<0){m=-((32-m)>>6);mo=-((8-mo)>>4);}else {m=(m+32)>>6;mo=((8+mo)>>4);}
   for(i=0;i<64;i++){bl[i]-=m;}
   bl[9]=bl[0];
   bl[0]=mo;
/*
   for(i=0;i<64;i+=2){
      s=bl[i]+bl[i+1];
      d=bl[i]-bl[i+1];
      bl[i]=s;bl[i+1]=d;
   }
   for(j=0;j<8;j++){
      for(i=0;i<64;i+=16){
         s=bl[i+j]+bl[i+8+j];
         d=bl[i+j]-bl[i+8+j];
           bl[i+j]=s;bl[i+8+j]=d;
      }
   }
*/
}
void doTIBlock(short *bl)
{
   int i;
   int m=0;
   /*
   for(j=0;j<8;j++)
      for(i=0;i<64;i+=16)
   {
      bl[i+j]=(bl[i+j]+bl[i+8+j])>>1;
      bl[i+8+j]=bl[i+j]-bl[i+8+j];
   }
   for(i=0;i<64;i+=2){
      bl[i]=(bl[i]+bl[i+1])>>1;
      bl[i+1]=bl[i]-bl[i+1];
      
   }
   */
   m=bl[0]>>2;
   //if(m<0){m=-((16-m)>>5);}else m=(m+16)>>5;
   bl[0]=bl[9];

   for(i=0;i<64;i++)bl[i]+=m;
   
   bl[9]=(bl[1]+bl[8]+bl[10]+bl[17])*7;
   bl[9]+=(bl[0]+bl[2]+bl[16]+bl[18]);
 //  bl[9]/=36;
#define T_FDIV32(_V) (_V<0?-((16-_V)>>5):(_V>0?((16+_V)>>5):0))
   bl[9]=T_FDIV32(bl[9]);
  // for(i=0;i<64;i++)bl[i]=T_FDIV2(bl[i]);
}
void doTFBlock4(short *bl)
{
   int i;
   int m=0;
   for(i=0;i<16;i++)m+=bl[i];
   int mo=m;

   //m/=64;
   //if(m<0){m=-((32-m)>>6);mo=-((4-mo)>>3);}else {m=(m+32)>>6;mo=-((4-mo)>>3);}
   if(m<0){m=-((8-m)>>4);mo=-((2-mo)>>2);}else {m=(m+8)>>4;mo=((2+mo)>>2);}
   for(i=0;i<16;i++){bl[i]-=m;}
   bl[5]=bl[0];
   bl[0]=mo;
}


void doTIBlock4(short *bl)
{
   int i;
   int m=0;
   //bl[0]=bl[0]*64+((m<0)?(-(m>>1)+1):((m>>1)));
   //m=5;
   m=bl[0]>>2;
   //if(m<0){m=-((16-m)>>5);}else m=(m+16)>>5;
   bl[0]=bl[5];
   for(i=0;i<16;i++)bl[i]+=m;
   //0 1  2
   //4 5  6
   //8 9 10
   bl[5]=(bl[1]+bl[4]+bl[6]+bl[9])*8;
   bl[5]+=(bl[0]+bl[8]+bl[2]+bl[10]);
   bl[5]/=36;

}

void tr1RowX(short *src, int dstStride,short *dst)
{
   int i;
   dst[0]=src[0];
   int d;
   int iPD1=0;
  // int iPD2=0;
   for(i=1;i<dstStride;i++)
   {
      d=src[i]-src[i-1];
      dst[i]=d-iPD1;
      iPD1=d;
   }
}
void trHCol(short *src, int dstStride,short *dst)
{
   for(int i=0;i<dstStride;i++)dst[i]=src[i]-src[i-dstStride];
}

void iHC(short *src, int stride){
   for(int j=0;j<stride;j++)src[j]+=src[j-stride];
}
void iHR(short *src, int stride){
   int d=0;
   for(int j=1;j<stride;j++)
   {
      d+=src[j];
      src[j]=src[j-1]+d;
   }
}
void vtIBl(short *p)
{
   int j;
   for(j=1;j<8;j++)iHC(p+j*8,8);
   for(j=0;j<8;j++)iHR(p+j*8,8);//,dst+j*8);
   //for(j=0;j<64;j++)p[j]*=8;
//   show(p);

}
void vtFBl(short *p)
{
   int j;
   short dst[64];
  // show(p);
   //for(j=0;j<64;j++){if(p[j]<0)p[j]=-((4-p[j])>>3);else p[j]=((4+p[j])>>3);}
   for (j=0;j<8;j++)tr1RowX(p+j*8,8,dst+j*8);
   for (j=7;j>0;j--)trHCol(dst+j*8,8,p+j*8);
   for(j=0;j<8;j++)p[j]=dst[j];
  // show(p);
}
//#define F(_R,_R1,_A,_B) {_R=(_A+_B +1)>>1;_R1=(_A)-(_B);}
//#define I(_R1,_R2,_A,_B){_R1=((_A*2+_B) >>1);_R2=(_R1-_B);}

#define F(_R,_R1,_A,_B) {_R=(_A+_B );_R1=(_A)-(_B);}
#define I(_R1,_R2,_A,_B){_R1=((_A+_B )>>1);_R2=(_R1-_B);}

void trrx(short *bl,int sh)
{
   int p[8];
   int i;
   int s1,s2,s3,s4,d1,d2,d3,d4;
   for(i=0;i<8;i++)p[i]=bl[i<<sh];

   F(s1,d1,p[0],p[1]);
   F(s2,d2,p[2],p[3]);
   F(s3,d3,p[4],p[5]);
   F(s4,d4,p[6],p[7]);


   p[0]=s1;p[1]=s2;p[2]=s3;p[3]=s4;
   bl[4<<sh]=d1;bl[5<<sh]=d2;bl[6<<sh]=d3;bl[7<<sh]=d4;
   //printf("%2d,%2d,%2d,%2d,%2d,%2d,%2d,%2d\n",p[0],p[1],p[2],p[3],p[4],p[5],p[6],p[7]);

   F(s1,d1,p[0],p[1]);
   F(s2,d2,p[2],p[3]);


   p[0]=s1;p[1]=s2;bl[2<<sh]=d1;bl[3<<sh]=d2;
   //printf("%2d,%2d,%2d,%2d,%2d,%2d,%2d,%2d\n",p[0],p[1],p[2],p[3],p[4],p[5],p[6],p[7]);

   F(bl[0<<sh],bl[1<<sh],p[0],p[1]);
   //bl[0<<sh]*=8;   bl[1<<sh]*=4;   bl[2<<sh]*=2;   bl[3<<sh]*=2;

   
   //p[0]=bl[0<<sh];p[1]=bl[1<<sh];printf("%2d,%2d,%2d,%2d,%2d,%2d,%2d,%2d\n",p[0],p[1],p[2],p[3],p[4],p[5],p[6],p[7]);

   //for(i=4;i<8;i++)bl[i<<sh]=p[i];
}

void itrrx(short *bl,int sh)
{
   int p[8];
   int i;
   int a1,a2,a3,a4,a5,a6,a7,a8;

#define T_FDIV2(_V) (_V<0?-((1-_V)>>1):(_V>0?((1+_V)>>1):0))
#define T_FDIV4(_V) (_V<0?-((2-_V)>>2):(_V>0?((2+_V)>>2):0))
#define T_FDIV8(_V) (_V<0?-((4-_V)>>3):(_V>0?((4+_V)>>3):0))
#define T_FDIV16(_V) (_V<0?-((8-_V)>>4):(_V>0?((8+_V)>>4):0))

   for(i=0;i<8;i++)p[i]=bl[i<<sh];
   //p[0]=T_FDIV8(p[0]);   p[1]=T_FDIV4(p[1]);   p[2]=T_FDIV2(p[2]);   p[3]=T_FDIV2(p[3]);

   I(a1,a2,p[0],p[1]);
   p[0]=a1;p[1]=a2;

   I(a1,a2,p[0],p[2]);
   I(a3,a4,p[1],p[3]);
   p[0]=a1;p[1]=a2;p[2]=a3;p[3]=a4;

   I(a1,a2,p[0],p[4]);
   I(a3,a4,p[1],p[5]);
   I(a5,a6,p[2],p[6]);
   I(a7,a8,p[3],p[7]);

   bl[0<<sh]=a1;bl[1<<sh]=a2;bl[2<<sh]=a3;bl[3<<sh]=a4;
   bl[4<<sh]=a5;bl[5<<sh]=a6;bl[6<<sh]=a7;bl[7<<sh]=a8;
#undef F
#undef I
   //for(i=0;i<8;i++)bl[i<<sh]=p[i];
}

//_B[0]=T_FDIV8(_B[0]);
   //for(int _i=0;_i<64;_i++)_B[_i]=T_FDIV2(_B[_i]);}
 //  for(int _i=0;_i<64;_i++)_B[_i]<<=1;

#define T_FTR(_B){\
   for(int _i=0;_i<8;_i++)trrx(&_B[_i<<3],0);\
   for(int _i=0;_i<8;_i++)trrx(&_B[_i],3);\
   /*for(int _i=1;_i<64;_i++)_B[_i]=T_FDIV2(_B[_i]);*/_B[0]=T_FDIV8(_B[0]);}

#define T_ITR(_B){\
   _B[0]=(_B[0]<<3)+4;\
   for(int _i=0;_i<8;_i++)itrrx(&_B[_i],3);\
   for(int _i=0;_i<8;_i++)itrrx(&_B[_i<<3],0);\
   /*for(int _i=1;_i<64;_i++){_B[_i]<<=1;}*/}

void t_fdct_int32(short *const block);
void t_idct_int32(short *const block);
void t_idct_int32_init(void);
#if 1
#define DCT_TYPE short
void t_idct8(DCT_TYPE *t);
void t_fdct8(DCT_TYPE *t);
void t_idct4(DCT_TYPE *t);
void t_fdct4(DCT_TYPE *t);
#define D_4x4 0

#if D_4x4==1
 #define CONST_QUANT 8
#else
  #define CONST_QUANT 0
#endif
void t_i_jpeg_fdct_float(short*);
void fdct_mm32( short *blk );
void idct_int32_dc128(short *const block);

void fill_block_dc(short *bl,int dc){
   
   int m=0x00010001*dc;
   int *b=(int*)bl;
   for(int i=0;i<32;i++){
      b[i]=m;
      
   }
}
inline void dct_fnc(short *const block){}//fdct_mm32(block);}//t_fdct_int32(block);} //t_i_jpeg_fdct_float  t_fdct_int32

inline void idct_fnc(short *const block, int iCoefs=64){ 
   if(iCoefs==0 || (iCoefs==1 && block[0]))
   {
     // for(int i=1;i<64;i++)if(block[i])debugss("---------------------------",0,i);
      short dc;
      if(block[0]==0)dc=0;else 
      if(block[0]<0) dc=-((3-block[0])>>3);
      else dc=((block[0]+4)>>3);
      for(int i=0;i<64;i++)block[i]=dc;

   }
   else {

   }
}//simple_idct_c idct_int32
inline void idct_fnc_dc128(short *const block, int iCoefs=64){
   
   if(iCoefs==0 || (iCoefs==1 && block[0]))
   {
      short dc;
      if(block[0]==0)dc=128;else 
      if(block[0]<0) dc=-(((3-block[0]))>>3)+128;
      else dc=((block[0]+4)>>3)+128;
      if(dc<0)dc=0;else if(dc>255)dc=255;
      for(int i=0;i<64;i++)block[i]=dc;//fill_block_dc(block,dc);
   }
   else 
      idct_int32_dc128(block);
}
inline void idct_fnc_dc_put(short *const block, unsigned char *pCur,int stride){
   

   short dc;
   if(block[0]==0)dc=128;else 
   if(block[0]<0) dc=-(((3-block[0]))>>3)+128;
   else dc=((block[0]+4)>>3)+128;
   if(dc<0)dc=0;else if(dc>255)dc=255;
   for(int i=0;i<8;i++){
      pCur[0]=pCur[3]=pCur[6]=pCur[9]=
         pCur[12]=pCur[15]=pCur[18]=pCur[21]=dc;
      pCur+=stride;
   }
}
inline void idct_fnc_dc_add(short *const block, unsigned char *pCur,int stride){
   

   short dc;
   if(block[0]==0)dc=0;else 
   if(block[0]<0) dc=-(((3-block[0]))>>3);
   else dc=((block[0]+4)>>3);
   if(!dc)return;
//   if(dc<0)dc=0;else if(dc>255)dc=255;
   for(int j=0;j<8;j++){
      for(int i=0;i<24;i+=3){
         int res=pCur[i]+dc;
         if(res<0)pCur[i]=0;else if(res>255)pCur[i]=255;else pCur[i]=res;
      }
      pCur+=stride;
   }
}


inline void wdct_fnc(short *const block, int iCoefs=64){t_fwave(block);}
inline void widct_fnc(short *const block, int iCoefs=64){t_iwave(block);}
inline void widct_fnc_dc128(short *const block, int iCoefs=64){
   t_iwave(block);;
   for(int i=0;i<64;i++){
      block[i]+=128;
      if(block[i]>255)block[i]=255;
      else if(block[i]<0) block[i]=0;
   }
}
inline void x4dct_fnc(short *const block, int iCoefs=64){t_fdct8(block);}
inline void x4idct_fnc(short *const block, int iCoefs=64){ t_idct8(block);}
inline void x4idct_fnc_dc128(short *const block, int iCoefs=64){
   t_idct8(block);;
   for(int i=0;i<64;i++){
      block[i]+=128;
      if(block[i]>255)block[i]=255;
      else if(block[i]<0) block[i]=0;
   }
}
//#define ZIG_ZAG_TBL tabzz4x4
//inline void d_dct_fnc(short *const block){t_fdct8(block);}
//inline void d_idct_fnc(short *const block){ t_idct8(block);}
//#define d_dct_fnc dct_fnc
//#define d_idct_fnc idct_fnc
//#define ZIG_ZAG_TBL zig_zag_twave
//#define ZIG_ZAG_TBL zig_zag_haar
//#define ZIG_ZAG_TBL zig_zag_haar2d
//inline void d_dct_fnc(short *const block){t_fwave(block);}
//inline void d_idct_fnc(short *const block){t_iwave(block);}
void fdwt(short *p);
void idwt(short *p);
//inline void d_dct_fnc(short *const block){fdwt(block);}
//inline void d_idct_fnc(short *const block){ idwt(block);}

//inline void dct_fnc(short *const block){}
//inline void idct_fnc(short *const block){}
//#define WAVE

//#define T_TRASF_UV t6x_uv_tivi
//#define T_TRASF_Y t6x_y_tivi
//#define ZIG_ZAG_TBL zig_zag_t_tr


inline void tt_dct_fnc(short *const block , int iCoefs=64){
   doTFBlock(block);
}
inline void tt_idct_fnc(short *const block, int iCoefs=64){
   doTIBlock(block);
}
inline void tt_idct_fnc_dc128(short *const block, int iCoefs=64){
   doTIBlock(block);;
   for(int i=0;i<64;i++){
      block[i]+=128;
      if(block[i]>255)block[i]=255;
      else if(block[i]<0) block[i]=0;
   }
}
void t_idct_int32_s(short *const block, register unsigned char *dst,const int stride);

inline void d_dct_fnc(short *const block){doTFBlock(block);}
inline void d_idct_fnc(short *const block){doTIBlock(block);}


#define T_TRASF_Y tab6x
#define T_TRASF_UV tab6x_uv
//
void t_fhaar(short *p);
void t_ihaar(short *p);
//#define ZIG_ZAG_TBL zig_zag_dctx
//#define ZIG_ZAG_TBL zig_zag_haar

//haar rle tab 1 8 9 
//0 1 8 9   2 3 10 11 
//4 5 12 13 6 7 14 15//haar tikai difiem

//inline void dct_fnc(short *const block){t_fhaar(block);}
//inline void idct_fnc(short *const block){t_ihaar(block);}
//inline void d_dct_fnc(short *const block){T_FTR(block);}



//inline void dct_fnc(short *const block){vtFBl(block);}
//inline void idct_fnc(short *const block){vtIBl(block);}
//#define WAVE
//inline void dct_fnc(short *const block){return fdct_int32haar(block);}
//inline void idct_fnc(short *const block){return idct_int32haar(block);}
//inline void dct_fnc(short *const block){return t_fdct4(block);}
//inline void idct_fnc(short *const block){return t_idct4(block);}
#else
#define WAVE
#define DCT_TYPE int
inline void dct_fnc(int *block){dTransWH(block,4);}
inline void idct_fnc(int *block){dITransWH(block,4);}
#endif
int encAritm(unsigned char *out , int *in ,int iCnt);
void initTabZ(int q, int *p, const int *tab, int id, int iIsB, int iConstQ)
{
   int t,i;
   int iQIn=q;
   q+=10;q*=100;q/=110;
   q+=8;q*=100;q/=108;
   //q+=5;q*=100;q/=105;
   //q-
   const int tid0[]={4,8};
   const int tid1[]={2,6};
   const int tidX[]={4,12};
   //const int tid1[]={6,6};
   //const int tid0[]={4,8};
   //const int tid1[]={4,8};
   
   const int tab_q_haar[]={
      1,4,2,4,1,4,2,4, 
      4,4,4,4,4,4,4,4, 
      2,4,2,4,2,4,2,4, 
      4,4,4,4,4,4,4,4, 
      1,4,2,4,1,4,2,4, 
      4,4,4,4,4,4,4,4, 
      2,4,2,4,2,4,2,4, 
      4,4,4,4,4,4,4,4, 
   };   
   
   
   const int tt[]={

      /*
      16,10,16,16,16,16,16,24,
      10,12,16,16,16,16,24,40,
      16,16,16,20,20,24,40,40,
      16,16,20,20,24,40,40,60,
      16,16,20,24,40,40,60,60,
      16,16,24,40,40,60,60,60,
      16,24,40,40,60,60,60,80,
      24,40,40,60,60,60,80,99,
      */
      16,10,16,16,16,16,16,16,
      10,12,16,16,16,16,16,16,
      16,16,16,16,16,16,16,16,
      16,16,16,16,16,16,16,16,
      16,16,16,16,16,16,16,16,
      16,16,16,16,16,16,16,16,
      16,16,16,16,16,16,16,16,
      16,16,16,16,16,16,16,16,

   };
   //q=4;
   
   const int q4x4[]={
      9,10,13,13,
      10,10,13,13,
      13,13,16,16,
      13,13,16,16,
      9,10,13,13,
      10,10,13,13,
      13,13,16,16,
      13,13,16,16,
      9,10,13,13,
      10,10,13,13,
      13,13,16,16,
      13,13,16,16,
      9,10,13,13,
      10,10,13,13,
      13,13,16,16,
      13,13,16,16,
   };
/*
static const uint8_t x264_zigzag_scan4[2][16] =
{{ // frame
    0,  4,  1,  2,  5,  8, 12,  9,  6,  3,  7, 10, 13, 14, 11, 15
},
{  // field
    0,  1,  4,  2,  3,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15
}};
*/
   //q+=8;

   int v;
   //if(id && q>80)q=80;
   int quality=q;
   int iqIn=q;

   if(quality>100)quality=100;
   if (quality < 50)
     quality = 5000 / quality;
   else
     quality = 200 - (quality*2);

   q=quality;

   
   //const int tx[]={4,8,12,16,20,24,28,32};
   
   for(i=0;i<64;i++)
   {
      //
      t=iConstQ;//?iConstQ:CONST_QUANT;

      if(t && id)t+=2;
      if(!t){
         t=tab[i];//if(!id){t*=5;t+=4;t>>=3;}
         //if(t<8)t=8;
         //if(iIsB && tab[i]>64)t+=12;
      }
      int iIsDC=i==0;//(i&15)==0;



      //if(id)t=8;


     // t=16;
      v=((t)*q+50)/100;

    //  v=(100-iqIn)/4;
      //p[i]=((((t+24)>>1)+2)*q+50)/100;
          

      
      if(iIsDC){
         //if(!id)v=(tid0[id]+v*7+4)>>3;
         if(v<tid0[id])v=tid0[id];
         if(!id)if(v>32)v=(32+v)>>1;
      }else
      if((i==8 || i==1)){
         //if(!id)v=(tid1[id]+v*7+4)>>3;
         if(v<tid1[id])v=tid1[id];
      }else
      if(v<tidX[id])v=tidX[id];

      


      //if(v<8)v=8;

//      v>>=1;
      //v=4;
      //if(iIsB)v++;
      v&=~1;
      if(iIsB)v+=2;
      //if(iIsB){v+=2;if(v<4)v=4;}//v++;
      //if(v<12)v=12;
      if(iConstQ)v=iConstQ;
      p[i]=v;
      //p[i]=2;
      /*
      if(i==0) {
         p[i]+=(id?12:4);
         p[i]>>=1;
      }
*/
      //p[i]=4;
      //p[i]=2;
   }
   int r=0;
   //iQIn+=2;
   //r=((((100-iQIn)))+1)&~1;   if(r<2)r=2;   r+=2;
   if(iIsB)r+=4;
  /*
   const int tttz[]={

      2,4,2,6,
      4,6,6,8,
      2,6,2,6,
      6,8,6,8,

   };
  // r+=2;
   const int tttzm[]={
      
      8,12,8,12,
      12,16,12,16,
      8,12,8,12,
      12,16,12,16,

   };

   const int tttzmi[]={
      
       80,140, 80,140,
       140,180,140,180,
       80,140, 80,140,
       140,180,140,180,

   };

   

   const int t_te[]={
      10,14,10,14,
      14,18,14,18,
      10,14,10,14,
      14,18,14,18,
   };
*/
   const int t_test[]={
      //70,280,70,280,
      //280,320,280,320,
      
      //3x+y;x-3y
      //112 82
      60,140,60,140,
      140,280,140,280,
      60,140,60,140,
      140,280,140,280,
/*
      80,150,80,150,
      150,300,150,300,
      80,150,80,150,
      150,300,150,300,
*/
      /*
      80,160,80,160,
      160,360,160,360,
      80,160,80,160,
      160,360,160,360,
      */
      /*
      70,120,70,120,
      120,200,120,200,
      70,120,70,120,
      120,200,120,200,
*/
      //5x+2y
      60,120,60,120,
      120,240,120,240,
      60,120,60,120,
      120,240,120,240,
   };
   
   /*
   const int t_test[]={
      20,90,20,90,
      90,150,90,150,
      20,90,20,90,
      90,150,90,150,
   };
   */
   

   
   //q=80
   /*
   const int t_test[]={
      40,96,40,96,
      96,180,96,180,
      40,96,40,96,
      96,180,96,180,
   };
*/
   const int t_test_h[]={
      /*
      12,16,12,16,
      16,32,16,32,
      12,16,12,16,
      16,32,16,32,
*/

      10,20,10,20,
      20,32,20,32,
      10,20,10,20,
      20,32,20,32,
   };
   /*
   const int t_test_t[]={
      
      32,32,32,64,
      32,64,64,8000,
      32,64,8000,8000,
      64,8000,8000,8000,
   };
   */
   /*
   const int tr[]={ 1, 2, 3, 4, 8,12,16,20,
                   24,28,32,36,40,46,52,58,
                   64,70,76,84,88,98,112,128,
                   148,168};
 */
/*
   //64
#define F_S(_X) ((_X * ((((_X-2))>>1)+1)))
   const int tr[]={ 1, 5, 7, 10, F_S(5),F_S(6),F_S(7),
                   F_S(8), F_S(9),F_S(10), F_S(11),F_S(12), F_S(13),F_S(14), F_S(15),
                   F_S(16), F_S(17),F_S(18), F_S(19),F_S(20), F_S(21),F_S(22), F_S(23),
                   F_S(24), F_S(25), F_S(26),};
#undef F_S
                   */
   //r=tr[(100-iQIn)>>2];
//   r=((16)*q+50)>>4;
   quality=iQIn;
   if(quality>100)quality=100;
   if (quality < 50)
     quality = 5000 / quality;
   else
     quality = 200 - (quality*2);

   q=quality;
   
 
   
   const int uvsk[]={
      0,0,64,64,
      0,0,64,64,
      64,64,64,64,
      64,64,64,64,
   };

   const int uvsk_dct[]={
      8,8,10,16,
      8,10,16,18,
      10,16,18,20,
      16,18,20,24,
   };
   int qSt=iQIn>>2;

   for(i=0;i<16;i++){

      
      
     // p[i+128]=//((tttzmi[i&15])*q+50)/100;;//
       //          r+tttz[i];
      //p[i+128]=(((t_te[i]+iIsB+id*2)*q+16)>>5)*2; //(t_te[i]+r+1)>>1;
      
      
     // if(p[i+128]<tttzm[i])p[i+128]=tttzm[i];else if(p[i+128]>tttzmi[i]){p[i+128]+=tttzmi[i];p[i+128]>>=1;}
/*
      p[i+128]=t_test[i]*8;//ok +10%
      p[i+128]=t_test[i]*2;//+20%
      p[i+128]=t_test[i]*3;//+10%
      p[i+128]=t_test[i]*4; labi +20%
      p[i+128]=t_test[i]*5;//+20%
*/

      //p[i+128]=(t_test_h[i]*(qSt)+t_test[i]*16*(25-qSt)+12)/25;
      p[i+128]=(((t_test_h[i])*q+16)>>4);
    //  p[i+128]+=(t_test_h[i]*(qSt)+ t_test[i]*(24-qSt)+12)/24;//24;
      //p[i+128]>>=1;
      //p[i+128]=t_test[i];
      p[i+128]+=1;
      p[i+128]>>=2;p[i+128]<<=2;
      if(p[i+128]<t_test_h[i]){p[i+128]+=t_test_h[i];p[i+128]>>=1;}
  //    p[i+128]=p[128];
      //p[i+128]<<=2;
      //p[i+128]=t_test_t[i];

    //  p[i+128]=(((uvsk_dct[i]+iIsB+id*2)*q+8)>>4); //(t_te[i]+r+1)>>1;
  //    if(p[i+128]<uvsk_dct[i]){p[i+128]+=uvsk_dct[i];p[i+128]>>=1;}

//
//      p[i+128]*=4;

      //if(t_te[i]==8)p[i+128]++;
      //else if(t_te[i]==12)p[i+128]+=2;
      //p[i+128]=(tttz[i]+r+1)>>1;
      //if((i&15)==0 )p[i+128]=(4+p[i+128]*3+2)>>2;

      //p[i+128]-=3;

      //if(i==0){p[128]*=3;p[128]>>=1;}
    //  p[i+128]=p[128];if(t_te[i]==18){p[i+128]*=5;p[i+128]>>=1;}else if(t_te[i]==14){p[i+128]*=6;p[i+128]>>=2;}
      if(id)p[i+128]+=uvsk[i];

      //else 
         //p[i+128]=(p[i+128]+1)&~1;

     // p[i+128]=t_test[i];
//p[i+128]>>=1;

      p[i+128+48]=p[i+128+32]=p[i+128+16]=p[i+128];
   }
   
   if(1){//iQIn<84){
      p[128+128]=((p[128]+12)>>3);//((96-iQIn)>>3);//// (20*q+50)/100;//p[128];
      if(p[128+128]<16)p[128+128]=(p[128+128]*3+16)>>2;
      else if(p[128+128]>32)p[128+128]=(p[128+128]+32)>>1;
   }
   else{
      p[128+128]=4;
   }
#if 0
	static const int aanscales[64] = {
	  /* precomputed values scaled up by 14 bits */
	  16384, 22725, 21407, 19266, 16384, 12873,  8867,  4520,
	  22725, 31521, 29692, 26722, 22725, 17855, 12299,  6270,
	  21407, 29692, 27969, 25172, 21407, 16819, 11585,  5906,
	  19266, 26722, 25172, 22654, 19266, 15137, 10426,  5315,
	  16384, 22725, 21407, 19266, 16384, 12873,  8867,  4520,
	  12873, 17855, 16819, 15137, 12873, 10114,  6967,  3552,
	   8867, 12299, 11585, 10426,  8867,  6967,  4799,  2446,
	   4520,  6270,  5906,  5315,  4520,  3552,  2446,  1247
	};
#endif
//	SHIFT_TEMPS

/*
	if (fdct->divisors[qtblno] == NULL) {
	  fdct->divisors[qtblno] = (DCTELEM *)
	    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
					DCTSIZE2 * SIZEOF(DCTELEM));
	}
	dtbl = fdct->divisors[qtblno];
	for (i = 0; i < DCTSIZE2; i++) {
	  dtbl[i] = (DCTELEM)
	    DESCALE(MULTIPLY16V16((INT32) qtbl->quantval[i],
				  (INT32) aanscales[i]),
		    CONST_BITS-3);
	}
      }
      break;
*/
   //int pr;
   
   for(i=0;i<64;i++){
      p[i+64]=((1<<15))/p[i]+1;//5989x430
      p[i+128+64]=((1<<15))/p[i+128]+1;
   }
   p[128+128+1]=((1<<15))/p[128+128]+1;//2x2
   
   
}
void initQ4x4_SkipLast(int *p, int iIsB, int a,int b, int c){
   int i;
   
   const int t[16]={
      a,b,a,b,
      b,c,b,c,
      a,b,a,b,
      b,c,b,c,

   };
   if(iIsB)p+=16;
   for(i=0;i<16;i++)p[i]=t[i];
   if(!iIsB){p+=16;for(i=0;i<16;i++){p[i]=t[i]*3;p[i]>>=1;p[i]+=8;}}

}
void initQ4x4(int *p, int id ,int iIsB, int a,int b, int c){

   int i;
   //b=a;
//c=b;b=(a+c+1)>>1;
//b/=5;b*=5;if(!b)b=5;c/=25;c*=25;if(!c)c=25;else c-=10;
   /*
   if(id){
      c=a<<1;
      b=a;
      a>>=1;
   }
   */
//#define FIX__B_C
#ifdef FIX__B_C
  // a=c=b;
    c=b=a;//3569,52KB
 //  c=(a*12)>>4;
  // b=(a*14)>>4;
//b=a/1.3;
//c=a/1.69;
#endif
#if 0
   if(0){
       int n;
       int iBFixed=0;
       for(n=0;a*(223)>b*100 && a>2 && n<8;n++){if(n&1){b++;iBFixed=1;}else a--;}
       for(n=0;b*(223)<c*100 && n<8;n++){if(n&1 && !iBFixed){b++;iBFixed=1;}else c--;}
   }
#define IA ((1<<15))*2235/(b*1000)+1
#define IB ((1<<15))/b+1
#define IC ((1<<15))*1000/(b*2235)+1

#else

#define IA ((1<<19))/(a*16)
#define IB ((1<<19))/(b*16)
#define IC ((1<<19))/(c*16)
#endif
   int it[16]={
      IA,IB,IA,IB,
      IB,IC,IB,IC,
      IA,IB,IA,IB,
      IB,IC,IB,IC,

   };


#undef  IA
#undef  IB
#undef  IC
   int t[16]={
      a,b,a,b,
      b,c,b,c,
      a,b,a,b,
      b,c,b,c,
      /*
      a,b,a,b,
      b,c,444,999,
      a,444,200,444,
      b,999,444,999,
      */
   };
//#define A2 107
//#define A3 178
//#define A2 128
//#define A3 196
//#define A2 80
//#define A3 100
//#define A2 (160)
//#define A3 (320)
   //a/2-b
   //(a-b*3)/2
#define A1 (64)
#define A2 (143)
#define A3 (64*5)
//
#define ASX(_AA,_AAA) ASX_FLAG_##_AA=1<<(_AAA), ASX_VALUE_##_AA=_AAA
   enum{
      ASX(abv,1),
   };
      static const int tt[]={
         A1,A2,A1,A2,
         A2,A3,A2,A3,
         A1,A2,A1,A2,
         A2,A3,A2,A3,
      };
#undef A1
#undef A2
#undef A3
      for(i=0;i<64;i++){
     //--    
#ifdef FIX__B_C
         p[i+128]=t[i&15];//(t[i&15]*tt[i&15]+32)>>6;
         p[i+128+64]=((1<<(15+6)))/(p[i+128]*tt[i&15]);
#else
         p[i+128]=t[i&15];
         p[i+128+64]=it[i&15];
#endif
        // int qValR=(p[i+128]*(tt[i&15])+32)>>6;
         //int qValR=p[i+128];p[i+128+64]=((1<<15))/qValR+1;//498 33161
         //p[i+128+64]=((1<<15))/p[i+128]+1;

      }
}


#if 0
const int inter_level[102] = {
  1,  2,  3,  4,  5,  6,  7,  8,
  9, 10, 11, 12,  1,  2,  3,  4,
  5,  6,  1,  2,  3,  4,  1,  2,
  3,  1,  2,  3,  1,  2,  3,  1,
  2,  3,  1,  2,  1,  2,  1,  2,
  1,  2,  1,  1,  1,  1,  1,  1,
  1,  1,  1,  1,  1,  1,  1,  1,
  1,  1,  1,  2,  3,  1,  2,  1,
  1,  1,  1,  1,  1,  1,  1,  1,
  1,  1,  1,  1,  1,  1,  1,  1,
  1,  1,  1,  1,  1,  1,  1,  1,
  1,  1,  1,  1,  1,  1,  1,  1,
  1,  1,  1,  1,  1,  1,
};

const int inter_run[102] = {
  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  1,  1,  1,  1,
  1,  1,  2,  2,  2,  2,  3,  3,
  3,  4,  4,  4,  5,  5,  5,  6,
  6,  6,  7,  7,  8,  8,  9,  9,
 10, 10, 11, 12, 13, 14, 15, 16,
 17, 18, 19, 20, 21, 22, 23, 24,
 25, 26,  0,  0,  0,  1,  1,  2,
  3,  4,  5,  6,  7,  8,  9, 10,
 11, 12, 13, 14, 15, 16, 17, 18,
 19, 20, 21, 22, 23, 24, 25, 26,
 27, 28, 29, 30, 31, 32, 33, 34,
 35, 36, 37, 38, 39, 40,
};

const int inter_vlc[103][2] = {
{ 0x2, 2 },{ 0xf, 4 },{ 0x15, 6 },{ 0x17, 7 },
{ 0x1f, 8 },{ 0x25, 9 },{ 0x24, 9 },{ 0x21, 10 },
{ 0x20, 10 },{ 0x7, 11 },{ 0x6, 11 },{ 0x20, 11 },
{ 0x6, 3 },{ 0x14, 6 },{ 0x1e, 8 },{ 0xf, 10 },
{ 0x21, 11 },{ 0x50, 12 },{ 0xe, 4 },{ 0x1d, 8 },
{ 0xe, 10 },{ 0x51, 12 },{ 0xd, 5 },{ 0x23, 9 },
{ 0xd, 10 },{ 0xc, 5 },{ 0x22, 9 },{ 0x52, 12 },
{ 0xb, 5 },{ 0xc, 10 },{ 0x53, 12 },{ 0x13, 6 },
{ 0xb, 10 },{ 0x54, 12 },{ 0x12, 6 },{ 0xa, 10 },
{ 0x11, 6 },{ 0x9, 10 },{ 0x10, 6 },{ 0x8, 10 },
{ 0x16, 7 },{ 0x55, 12 },{ 0x15, 7 },{ 0x14, 7 },
{ 0x1c, 8 },{ 0x1b, 8 },{ 0x21, 9 },{ 0x20, 9 },
{ 0x1f, 9 },{ 0x1e, 9 },{ 0x1d, 9 },{ 0x1c, 9 },
{ 0x1b, 9 },{ 0x1a, 9 },{ 0x22, 11 },{ 0x23, 11 },
{ 0x56, 12 },{ 0x57, 12 },{ 0x7, 4 },{ 0x19, 9 },
{ 0x5, 11 },{ 0xf, 6 },{ 0x4, 11 },{ 0xe, 6 },
{ 0xd, 6 },{ 0xc, 6 },{ 0x13, 7 },{ 0x12, 7 },
{ 0x11, 7 },{ 0x10, 7 },{ 0x1a, 8 },{ 0x19, 8 },
{ 0x18, 8 },{ 0x17, 8 },{ 0x16, 8 },{ 0x15, 8 },
{ 0x14, 8 },{ 0x13, 8 },{ 0x18, 9 },{ 0x17, 9 },
{ 0x16, 9 },{ 0x15, 9 },{ 0x14, 9 },{ 0x13, 9 },
{ 0x12, 9 },{ 0x11, 9 },{ 0x7, 10 },{ 0x6, 10 },
{ 0x5, 10 },{ 0x4, 10 },{ 0x24, 11 },{ 0x25, 11 },
{ 0x26, 11 },{ 0x27, 11 },{ 0x58, 12 },{ 0x59, 12 },
{ 0x5a, 12 },{ 0x5b, 12 },{ 0x5c, 12 },{ 0x5d, 12 },
{ 0x5e, 12 },{ 0x5f, 12 },{ 0x3, 7 },
};

/** RLTable. */
typedef struct RLTable {
    int n;                         ///< number of entries of table_vlc minus 1
    int last;                      ///< number of values for last = 0
    const int (*table_vlc)[2];
    const int *table_run;
    const int *table_level;
    int *index_run[2];         ///< encoding only
    int *max_level[2];          ///< encoding & decoding
    int *max_run[2];            ///< encoding & decoding
    //VLC vlc;                       ///< decoding only deprected FIXME remove
    //RL_VLC_ELEM *rl_vlc[32];       ///< decoding only
} RLTable;

static RLTable rl_inter = {
    102,
    58,
    inter_vlc,
    inter_run,
    inter_level,
};
#define MAX_RUN 64
#define MAX_LEVEL 64

void init_rl(RLTable *rl)
{
    int max_level[MAX_RUN+1], max_run[MAX_LEVEL+1];
    int index_run[MAX_RUN+1];
    int last, run, level, start, end, i;

    /* compute max_level[], max_run[] and index_run[] */
    for(last=0;last<2;last++) {
        if (last == 0) {
            start = 0;
            end = rl->last;
        } else {
            start = rl->last;
            end = rl->n;
        }

        memset(max_level, 0,( MAX_RUN + 1)*4);
        memset(max_run, 0, (MAX_LEVEL + 1)*4);
        memset(index_run, rl->n, (MAX_RUN + 1)*4);
        for(i=start;i<end;i++) {
            run = rl->table_run[i];
            level = rl->table_level[i];
            if (index_run[run] == rl->n)
                index_run[run] = i;
            if (level > max_level[run])
                max_level[run] = level;
            if (run > max_run[level])
                max_run[level] = run;
        }
        rl->max_level[last] = new int[MAX_RUN + 1];
        memcpy(rl->max_level[last], max_level, (MAX_RUN + 1)*4);
        rl->max_run[last] = new int[MAX_LEVEL + 1];
        memcpy(rl->max_run[last], max_run, (MAX_LEVEL + 1)*4);
        rl->index_run[last] = new int[MAX_RUN + 1];
        memcpy(rl->index_run[last], index_run, (MAX_RUN + 1)*4);
    }
}



static inline int get_rl_index(RLTable *rl,int last, int run, int level)
{
    int index;
    index = rl->index_run[last][run];
    if (index >= rl->n)
        return rl->n;
    if (level > rl->max_level[last][run])
        return rl->n;
    return index + level - 1;
}
#endif
#if 1
//dct 64
#define TVAL_24 24
#define TVAL_8 8
#define TVAL_DCT_SZ 64
#define TVAL_DCT_BYTES TVAL_DCT_SZ*sizeof(DCT_TYPE)
#define TVAL_DCTH 32
#define TVAL_SH6 6
#define MAX_BL 6
#ifdef ZIG_ZAG_TBL 
   #define ZIG_ZAG_TAB ZIG_ZAG_TBL
   #define ZIG_ZAG_TAB2 ff_alternate_h_scan
   #define ZIG_ZAG_TAB3 ff_alternate_v_scan
#else
   #define ZIG_ZAG_TAB zzzff_zigzag_direct
   #define ZIG_ZAG_TAB2 ff_alternate_h_scan
   #define ZIG_ZAG_TAB3 ff_alternate_v_scan
#endif
//(int*)&zzzff_zigzag_direct[0];//&tabzz4x4[0];
#else
#define TVAL_24 12
#define TVAL_8 4
#define TVAL_DCT_SZ 16
#define TVAL_DCTH 8
#define TVAL_SH6 5
#define MAX_BL 4
#define ZIG_ZAG_TAB tabzz4x4
#define ZIG_ZAG_TAB2 tabzz4x4
#define ZIG_ZAG_TAB3 tabzz4x4
//(int*)&zzzff_zigzag_direct[0];//&tabzz4x4[0];

#endif
void getAlphaBetaValues(int q, int &a, int &b);
int getBlockPSNR(unsigned char *p ,unsigned char *o, int w, int h, int stride, int step);
int encAritmC(unsigned char *out , short *in ,int iCnt);
int encAritmUS_I(unsigned char *out , int *in ,int iCnt);
int encAritmNH_S(unsigned char *out , int *in ,int iCnt);
int encAritmUC(unsigned char *out , unsigned char *in ,int iCnt);

inline void fill_dc128_k0(unsigned char *pCur, int stride){
   int i,j;
   unsigned int *pI=(unsigned int *)pCur;
   stride>>=2;
   for(j=0;j<8;j++,pCur+=stride){
      pI[0]|=0x80000080;
      pI[1]|=0x00008000;
      pI[2]|=0x00800000;
      pI[3]|=0x80000080;
      pI[4]|=0x00008000;
      pI[5]|=0x00800000;
   }
}

inline void fill_dc128(unsigned char *pCur, int stride)
{
   int i,j;
   for(j=0;j<8;j++,pCur+=stride){
      pCur[0]=128;
      pCur[3]=128;
      pCur[6]=128;
      pCur[9]=128;
      pCur[12]=128;
      pCur[15]=128;
      pCur[18]=128;
      pCur[21]=128;
   }
}

typedef struct  {
   DCT_TYPE dct[64];
   
   int iDifSad;
   int iPicSad;
   int iPicMean;
   int iCanRestore;
   int iMaxErr;
   int iStartPsnr;
   
   int iCoefsDct;
   int iCoefsQuant;
   int iQuantCoefSum;

   int iIsDif;
   int iPicMed;
   int iIs4x4;
   int iCanBePic;
   
   int iEncBits;
   int iMaxCoef;
   int dc_quantized;
   int iSkip;
   int iCanUseAsPred;


   int iHasUpAndLeft;
   int iMbPerRow;
   int cnt;
}IMG_MB;

typedef struct  {
   int iIsDif;
   int dc_quantized;
   int iSkip;
   int iCanUseAsPred;

   int iHasUpAndLeft;
   int iMbPerRow;
   int iDecoded;
}IMG_MB_DEC;

int loadBlockK(DCT_TYPE *p,  unsigned char *pCur, unsigned char *pRef, int stride)
{
   int i,j;
   //DCT_TYPE *p=&mb->dct[0];
   for(j=0;j<TVAL_8;j++){
      p[0]=pRef[0]-128;
      p[1]=pRef[3]-128;
      p[2]=pRef[6]-128;
      p[3]=pRef[9]-128;
      p[4]=pRef[12]-128;
      p[5]=pRef[15]-128;
      p[6]=pRef[18]-128;
      p[7]=pRef[21]-128;
      pRef+=stride;
      p+=8;
   }
   return 0xffff;
}
int loadBlockKX(DCT_TYPE *dct,  unsigned char *pCur, unsigned char *pRef, int stride)
{
   int i,j;
 
   for(j=0;j<TVAL_8;j++){
      *dct=pRef[0]-128;dct++;
      *dct=pRef[3]-128;dct++;
      *dct=pRef[6]-128;dct++;
      *dct=pRef[9]-128;dct++;
      *dct=pRef[12]-128;dct++;
      *dct=pRef[15]-128;dct++;
      *dct=pRef[18]-128;dct++;
      *dct=pRef[21]-128;dct++;
      pRef+=stride;
   }
   return 0xffff;
}
int picSad(register unsigned char *pCur,const int iSize, const int stride){
   register int h=0;
   register int v=0;
   register int i,j;
   const int iSize3=iSize*3;
   for(j=0;j<iSize;j++){
      for(i=0;i<iSize3;i+=3){
         v+=mmabs((pCur[i]-pCur[i+stride]+2)>>2);
         h+=mmabs((pCur[i]-pCur[i+3]+2)>>2);
        // v+=mmabs((pCur[i]-pCur[i+stride]+1)>>1);
         //h+=mmabs((pCur[i]-pCur[i+3]+1)>>1);
      }
      pCur+=stride;
   }
   return ((max(v,h)+2)*67)>>6;//min(h,v);//((min(h,v)*9)>>3)+6;
}


inline int div_8_abs(int v){
   if(v<=-4){
      return ((-v)+4)>>3;
   }
   else if(v>=4)return ((v)+4)>>3;
   return 0;
}
inline int div_4_abs(int v){
   if(v<=-3){
      return ((-v)+2)/3;
   }
   else if(v>=3)return ((v)+2)/3;
   return 0;
}
inline int div_2_abs(int v){
   if(v<=-2){
      return ((-v)+1)>>1;
   }
   else if(v>=2)return ((v)+1)>>1;
   return 0;
}
inline int div_f_abs(int v){
   if(v<0)v=-v;
   v<<=1;
   return v;
}
inline int med3(int a,int b,int c, int &mi, int &ma){
   
   ma=max(a,b);ma=max(ma,c);
   //return (a+b+c-ma)>>1;
   mi=min(a,b);mi=min(mi,c);return a+b+c-ma-mi;
}
typedef int (div_x_abs_fnc )(int v);

/*
static char skipVals[640*480/64];

void setSkipVal(int i, int j, int xc, int iSk){
   skipVals[j*xc+i]=iSk;
}
int getSkipVal(int i, int j, int xc){
   int r=skipVals[j*xc+i];
   skipVals[j*xc+i]=0;
   return r;;
}
*/
template<int iCanBeNonDif,int iCalcDC>
static inline int canSkip(unsigned char *pCur,unsigned char *pRef ,const int iSize,int stride, int &iSad, unsigned char *t, unsigned char *ta){
  //return 0;
   static int iMinN=iSize;
   //unsigned int *getTabM();
  // unsigned int *getTabS();
//#define tabN(_A) (mmabs(_A)+2)>>2
//#define tabS(_A) mmabs(_A)
//#define tabS(_A) _tabS[_A]
//#define tabN(_A) _tabN[_A]
   static int c;
   //const int *_tabN=(const int *)getTabM();
   //const int *_tabS=(const int *)getTabS();
   if(!pCur){
      c=6;//tabS(6);
      iMinN=iMinN+c*2;//*iSize*2;
      return 0;
   }
   register int h=2;
   register int v=2;
   register int i,j;
   register int d;
   const int iSize3=iSize*3;
#define fnc(_A) t[_A]
   
   const int skipCoef=0;
   iSad=0;

   int stridex=-stride-3;
   int vh=1;
   int ma,mi;
   unsigned char cur;
   int pic[64];
   int id=0;
   int iPicM=0;
   int iSadDC=0;
//   int d;
   for(j=0;j<iSize;j++){
      const int iLastL=j+1==iSize;
      for(i=0;i<iSize3;i+=3,id++){
         cur=pCur[i];
         if(!iLastL){
            h+=fnc(cur-pCur[i+stride]);
         }
         if(i && j){
            vh+=fnc(cur-pCur[i+stridex]);
         }
         if(i+3!=iSize3){
            v+=fnc(cur-pCur[i+3]);
         }
         d=cur-pRef[i];
         if(iCalcDC)iSadDC+=d;
         iSad+=ta[d];
         if(iCanBeNonDif){
            pic[id]=pRef[i];
            iPicM+=pic[id];
         }
      }
      //if(iSad>256)break;
      pCur+=stride;pRef+=stride;
   }
   //int r=min(v,h)>>1;
   int r=med3(v,h,vh,mi,ma);//(*3)>>2;
   //int r=(v+h+8)>>1;//((min(v,h)+8)*3)>>2;

   iMinN=min((mi>>1),iMinN);
   //iMinN=min(h,iMinN);

   //iMinN+=iSize;

   //if(iMinN<12)iMinN=12;
   r+=iMinN;

//   if(iCanBeNonDif && iSad>384 && ma==0)return 2;

   if(iCalcDC){iSadDC+=32;iSadDC>>=6;}
   //iSadDC/=64;
   //if(iSadDC==0 && r*2>iSad)return 1;


   if(mmabs(iSadDC)<1 && r>iSad)return 1;

   if(iSad<iMinN)return 1;
   if(iSad<8)return 1;
   if(iCalcDC==0 ||mmabs(iSadDC)<2){
   //if(ma>iSad && iSad<80)return 1;
      if(r*2>iSad && iSad<64)return 1;
      if(r>iSad && iSad<120)return 1;
      if(mi>iSad && iSadDC==0)return 1;
      //if(r>3*iSad && iSad<300)return 1;
      if(2*r>3*iSad && iSad<250)return 1;
      if(ma>iSad && iSad<32)return 1;
   }
/* -----
   if(ma+30*64<iSad)return 2;
   
   if(iCanBeNonDif==2 && ma*7<iSad && iSad>512)return 2;
   //if(iCanBeNonDif==2 && r*8<iSad && iSad>128)return 2;
   if(iCanBeNonDif && (ma+8)*5<iSad && iSad>128)return 2;
   if(iCanBeNonDif==2 && ma<32 && iSad>256)return 2;

   if(ma*6<iSad && (iSad>128 || (iCanBeNonDif==2 && iSad>64)) && iCanBeNonDif){
      iPicM+=32;iPicM>>=6;
      int m=0;
      int _TODO_GET_IT_FROM__MV_CALC;
      for(id=0;id<32;id++)m+=ta[iPicM-pic[id]];
      if(m>iSad)return 0;
      for(id=32;id<64;id++)m+=ta[iPicM-pic[id]];

      if(m+120<iSad)return 2;
      if(iCanBeNonDif==2 && m+48<iSad)return 2;

   }
   .........
*/
   if(iCanBeNonDif && (ma+20)*6<iSad)return 3;


   return iCanBeNonDif  && (ma+10)*4<iSad?4:0;
}
static inline int canSkipUV(unsigned char *pCur,unsigned char *pRef ,const int iSize,int stride, unsigned char *t, unsigned char *ta){
   register int h=2;
   register int v=2;
   register int i,j;
   register int d;
   const int iSize3=iSize*3;
   register int iSad=0;
//   const int skipCoef=0;
   //unsigned int *getTabM();
   //unsigned int *getTabS();
   //const int *tabN=(const int *)getTabM();
   //const int *tabS=(const int *)getTabS();
   for(j=1;j<iSize;j+=2){
      for(i=3;i<iSize3;i+=6){
         d=pCur[i]-pCur[i+stride];
         h+=fnc(d);
         d=pCur[i]-pCur[i+3];
         v+=fnc(d);
         d=pCur[i]-pRef[i];
         iSad+=ta[d];
      }
      pCur+=stride;pRef+=stride;
   }
#undef  fnc
   int r=(((v+h)*3)>>2)+8;
   if(r>iSad && iSad<16*12)return 1;
   if(r>2*iSad && iSad<256)return 1;
   if(r*2<iSad && iSad>128)return 2;
   if(iSad>16*32)return 2;
   
   return 0;
}

inline int loadBlockFast(DCT_TYPE *p, DCT_TYPE *pic, unsigned char *pCur, unsigned char *pRef, int stride, int iIsRefFrame, int iIsY)
{
   //DCT_TYPE *p=dct;//&mb->dct[0];
   int i,j;//,sadD=0;

   DCT_TYPE ipR;
   DCT_TYPE ipC;
   for(j=0;j<TVAL_8;j++){
      for(i=0;i<TVAL_24;i+=3){
         ipR=pRef[i];ipC=pCur[i];
         *p=(ipR-ipC);
         //if(*p<0)sadD-=*p;else sadD+=*p;
         p++;
      }
      pCur+=stride;
      pRef+=stride;
   }
   return 0;//sadD;
}
int loadBlock(IMG_MB *mb, DCT_TYPE *pic, unsigned char *pCur, unsigned char *pRef, int stride, int iIsRefFrame, int iIsY)
{
   DCT_TYPE *p=&mb->dct[0];
   int i,j,sadD=0,sadP=0;

   int m=0;
   DCT_TYPE ipR;
   DCT_TYPE ipC;
   int iSadDC=0;
   int x=0;
   for(j=0;j<TVAL_8;j++){
      for(i=0;i<TVAL_24;i+=3){
         ipR=pRef[i];ipC=pCur[i];
         *p=(ipR-ipC);
         iSadDC+=*p;
//         *toSave=ipC;toSave++;
         //p[0]*=2;
         if(*p<0){
            if(-(*p)>m)m=-(*p);
            sadD-=*p;
         }else{ 
            if(*p>m)m=*p;
            sadD+=*p;
         }
         
         sadP+=ipR;pic[x]=ipR;x++;
         p++;
      }
      pCur+=stride;
      pRef+=stride;
   }
   mb->iDifSad=sadD;
   mb->iPicSad=sadP;
   int med=(sadP+TVAL_DCTH)>>TVAL_SH6;

   mb->iPicMed=med;

//   return sadD;

   mb->iCanRestore=sadD;
   mb->iPicMean=sadP;

   if(mb->iSkip==5)return sadD;

   int _TODO_rem_retHERE;
//return 0x7fff;

   if((iIsRefFrame ==0 &&((m<3 && sadD<40))) || m<2 || sadD<12)
      return 0;

//   return sadD<64*16?sadD:0x7fff;

   if(sadD>TVAL_8*256)return 0x7fff;


   return sadD;
/*
   int dMed=iSadDC/TVAL_DCT_SZ;

   int iSadDM=0;
   p-=TVAL_DCT_SZ;
   //iSadDM+=0x7fff;
   int sadM=0;
   //int sadM2=0;
   for(i=0;i<TVAL_DCT_SZ;i++,p++){
      if(med>pic[i])sadM+=(med-pic[i]);else sadM+=(pic[i]-med);
      iSadDM+=mmabs((*p)-dMed);
   }
   mb->iCanRestore=iSadDM;
   mb->iPicMean=sadM;
   mb->iPicMed=dMed;


   int adMed=mmabs(dMed);


   int sadD_m_DC=sadD-mmabs(iSadDC);

   //if(sadD>64*24 && sadM<sadD)return 0x7fff;
   if(sadD>64*12 && sadM<sadD_m_DC)return 0x7fff;
   if(sadD>64*6 && sadM*4<sadD_m_DC)return 0x7fff;
   if(sadD>64*3 && sadM*10<sadD_m_DC)return 0x7fff;


   if(iIsRefFrame &&  sadM<sadD_m_DC  && m>2)return 0x7fff;

   double r=(double)(sadD_m_DC+sadM)/(double)(sadM+64);
   if(r>1.5 && sadD_m_DC>(sadM+1)*8+64 && sadD>256)return 0x7fff;

   if(r<0.90 && adMed==0)return 0;
return sadD;

   //--if(r<0.96)return 0;


   int mm=picSad(pCur-stride*TVAL_8,TVAL_8,stride);

   if(!iIsY && adMed<4 && sadM>sadD_m_DC && mm*2>sadD_m_DC)return 0;

   if(!iIsRefFrame && adMed<2 && mm*3>sadD_m_DC*2 && m<6 && sadD*5<sadM*4)return 0;//???????

   if(m>4 && (mm+2)*4+16<sadD_m_DC &&  sadM<sadD_m_DC)return 0x7fff;

   if(mm+8>sadD_m_DC && adMed<3)return 0;
   return sadD;

//--100KB 119000
   if(adMed==0 && sadD_m_DC*2<sadM && sadD<64)return 0;
   if(adMed==0 && sadD_m_DC*3<sadM && sadD<128)return 0;
   return (sadD_m_DC*5<sadM && adMed<3 && sadD<6*64)?0:sadD;


//-------120KB 123000
   
   //is b  if(r<1.02)return 0;
   int iDCMin=3;
   //labi 
   const double dM=1.05;
   //const double dM=0.86;
   //const double dM=1.05;
   //if(adMed>5 && sadM*2+32<sadD)return 0x7fff;
   //if(sadM+32>sadD && sadD>64*8)return 0x7fff;
   if(iIsRefFrame && r<dM)return adMed<(iDCMin>>1) && sadD<8*32?0:sadD;
   else if(r<dM+0.04)return adMed<iDCMin && sadD<8*32?0:sadD;

   if(r>1.8)return 0x7fff;
   //if((sadM+8)*16<sadD)return 0x7fff;
   //if(sadM>sadD && sadD>64*12)return 0x7fff;
   return sadD;//sadD;
   


   //return (sadD+iSadDM)*2<sadM+256 && dMed<3?0:0x7fff ;
   
   //return 0;

   if((sadM+16)*6<sadD && adMed>2 && iSadDM>0)return 0x7fff;
   if((sadM+32)*8<sadD && iSadDM>0)return 0x7fff;
   if(sadM<sadD && sadD>12*64)return 0x7fff;

   //if(iIsRefFrame && (sadD>sadM*2 || (sadD>sadM && sadM<4))   && sadD>64*8)return 0x7fff;
   //--if((sadD>sadM*4 ||  sadM<32) && adMed>5 && sadD>64*12 && m>8 && iSadDM>64)return 0x7fff;
   //--if(sadD>sadM*8 &&  sadM<20 && sadD>64*5)return 0x7fff;

   //if(iIsRefFrame && sadD>sadM  && sadD>64*4)return 0x7fff;

   
 //  if(1)return sadD<sadM*4+64*8?((sadD*2<sadM && adMed<4 && sadD<8*64) || (adMed<3 && m<4 && iSadDM<64)?0:sadD):0x7fff;

   
   if(adMed==0 && sadM<12 && m<2)return 0;
   if(!iIsRefFrame){
      if(adMed<3 && iSadDM<4 && sadD<64*3)return 0;
      if(sadD*6<sadM && adMed==0 && sadD<8*32 && m>10)return 0;
      if(sadD*4<sadM && adMed<2 && sadD<8*16 && m>4 && m<10)return 0;
   }
   if(sadD*2<=sadM && adMed<3 && m<3)return 0;
   if(sadD*2<sadM && adMed==0 && m<3 && sadD<80)return 0;

   if((sadM+6)*32<sadD)return 0x7fff;

   if(adMed>1 && ((sadD>256 && sadD>(sadM+16)*2) || 
      (sadD>192 && sadD>(sadM+16)*4))  && mb->iHasUpAndLeft && ((mb-1)->iIsDif==0 || (mb-mb->iMbPerRow)->iIsDif==0))return 0x7fff;

//   return sadD*4<sadM?0:0x7fff;
   return sadD<sadM+64*12?((iIsRefFrame==0 && 
      ((sadD*6<sadM && adMed<3 && sadD<6*64) || 
       (sadD*3<sadM && adMed<2 && sadD<2*64) || 
       (sadD*2<sadM && adMed==0 && m<2)))?0:sadD):0x7fff;
   
   //return (iSadDM<5 && m<3) ||  (sadD<25*12 && adMed<2 && m<15 && (sadD*7)<sadM*6+256)?0:0x7fff ;

   if(dMed==0 && sadD<4*64 && m<6 && sadM>8*64)
      return 0;
   if(adMed<2 && sadD<8*40  && sadM>20*64)
      return 0;

   if(adMed<2 && sadD<8*24 && sadM>15*64)
      return 0;

   if(adMed==0 && sadD<8*60  && sadM>40*64)
      return 0;

   if(adMed<2 && m<4 && iSadDM<22 && sadD<64*4)
      return 0;
   if(adMed<3 && m<7 && sadM<64*2 && sadD<64*2 && iSadDM<256)
      return 0;

   if(adMed<2 && m<6 && sadM>64*16 && sadD<64*6 && iSadDM<64*8)
      return 0;

   //if((iSadDM<12 && adMed<2) ||  (sadD<16*16 && adMed<2 && m<12 && (sadD*4)<sadM*3+256))
     // return 0;

   //return (sadD)*4<sadM+128?0:0x7fff ;

   if(sadD<200)return sadD;


   //return sadD+64*4<sadM?0:0x7fff ;

   if(sadD+iSadDM<sadM+64)return sadD;

   if(sadM+16<iSadDM && sadM+16<sadD && mb->iHasUpAndLeft && 
      (((mb-1)->iIsDif==0 && mmabs((mb-1)->iPicMed-med)<4) || 
      ((mb-1)->iIsDif==1 && (mb-mb->iMbPerRow)->iIsDif==0 && mmabs((mb-mb->iMbPerRow)->iPicMed-med)<4) ))
   {
      return 0x7fff;
   }
   //if(sadM+128>iSadDM)return sadD;
   if((sadM)*2+256<sadD && sadM*4+256<iSadDM)return 0x7fff;
   if(iSadDM<sadM+256)return sadD;
   if(sadD<sadM+256)return sadD;
   return 0x7fff;
   //if(sadD<TVAL_DCT_SZ*40 && sadM>iSadDM)return sadD;
   if(sadD<TVAL_DCT_SZ*30 && (sadD<sadM+TVAL_DCT_SZ || (sadM+TVAL_DCT_SZ*2>iSadDM && iSadDM<TVAL_DCT_SZ*8)))return sadD;
   if(iSadDM>sadM*2+128)return 0x7fff;

   if(sadM<32 && iSadDM>TVAL_DCT_SZ*8 && iSadDM>sadM)return 0x7fff;
  // return 0x7fff;

   return iSadDM<sadM+512 || sadD<64*16?sadD:0x7fff;

   //-------
   //iPredRet=0;
   int iS;
   sadP=0x7fff;

   if(0x7fff==sadM){
      return 0x7fff;
   }
   //return 0x7fff;

   if(sadP+128>iSadDM && sadM+32>sadD && sadD<64*32){// -m-16 && (sadP+10)*3>sadD){
      if(sadP+64>iSadDM){
         return sadD;
     }
   }
  return 0x7fff;

*/
}


#define T_ALIGN_32(type, name, size) int t32_align_##name[((size*sizeof(type))>>2)+1];type *name=(type*)&t32_align_##name[0];
#if !defined(_WIN32_WCE) && !defined(__SYMBIAN32__) && !defined(ARM) && !defined(ANDROID_NDK) && !defined(__APPLE__)
#define T_ALIGN_64(type, name, size) long long t64_align_##name[((size*sizeof(type))>>3)+1];type *name=(type*)&t64_align_##name[0];
#else
#define T_ALIGN_64 T_ALIGN_32
#endif



static unsigned char *s_cropTbl=NULL;
unsigned char *getCropTbl(){return s_cropTbl;}

typedef struct{
   int vec[4];
   int iSad,iBestUV;
   int iDev;
   int iMinPosSad;
   int iMode;
   int iRotA;
   int iTryMode;//1 2x2, >1 4x4
   int iHada;

   int iSkip[3];
   int iPsnr[3];
   int iSSim[3];
   int iEndPsnr[3];
   int iSkipV[4*3];//1 dct Skiped
   int iBits[4*3];
   IMG_MB *mb[4*3];
}MBL_E_STATS;
#if  defined(__SYMBIAN32__) || defined(_WIN32_WCE) || defined(ARM) || defined(ANDROID_NDK) || defined(__APPLE__)
#define _T_DIS_DBG
#else
//#undef _T_DIS_DBG
#endif

#ifndef _T_DIS_DBG
//qewqwe
//#define  MaxDBGID ((640*480)>>8)

static int MaxDBGID=0;

static MBL_E_STATS *mst;
class CT_IMG_DBG{
   int wi,hi;
public:
   CT_IMG_DBG(){wi=hi=0;msts=NULL;}
   MBL_E_STATS *msts;
   int check(int w, int h){
      if(w!=wi || h!=hi){
         delete msts;
         MaxDBGID=(w*h+w)>>8;
         msts=new MBL_E_STATS[MaxDBGID];
         
         mst=msts;
         clear();
         wi=w;
         hi=h;
         return 1;
      }
      return 0;
   }
   void clear(){
      if(!msts || msts[0].iRotA==10001)return;
         MBL_E_STATS ms;
         memset(&ms,0,sizeof(MBL_E_STATS));
         ms.iSad=4000;
         ms.iDev=4900;
         ms.iMinPosSad=3500;
         ms.iMode=0;
         ms.iTryMode=15;
         ms.iHada=-1;
         ms.iBestUV=300;
         ms.iRotA=10001;
         
         //ms.
         for(int i=0;i<MaxDBGID;i++)msts[i]=ms;

         //memset(msts,0,sizeof(MBL_E_STATS)*MaxDBGID);
   }
};
CT_IMG_DBG dbxx;
void clearBLStats(){
   dbxx.clear();

}
int iMotMinPosSad=200;
inline int getMinPosSad(){
   return iMotMinPosSad;
}
#else
inline int getMinPosSad(){
   return 200;
}

#endif
void setStatSZ(int x, int y, int iMinPosSad){
#ifndef _T_DIS_DBG
   dbxx.check(x,y);
   if(iMinPosSad>=0){
      if(iMinPosSad<iMotMinPosSad){
         iMotMinPosSad*=3;
         iMotMinPosSad+=iMinPosSad;
         iMotMinPosSad>>=2;
      }
      else{
         iMotMinPosSad+=iMinPosSad;
         iMotMinPosSad>>=1;
      }
   }
#endif
}
typedef struct{
   enum eSkip{eNotSkiped,eSkipPsnr,eSkipQ,eSkipLast,eSkip1,eSkip2,eSkip3,eSkip4,eSkip5,eSkip6,eSkip7,eSkip8,eSkip9,eSkipSSIM,eSkipTest};
   enum eType{eDif4x4,eDif8x8,ePic4x4,ePic8x8,eSkiped};
   struct{
   eType iType;
   eSkip iSkip;
   int iStartPsnr,iSQErrStart;
   int iPrevStartPsnr;
   }col[3];
   int iPrevDev;
}MB16_2;

static void addTransSkip(char *p, int &iLen, int sk){
#ifndef _T_DIS_DBG
   char *v="";
   switch(sk){
#define C_SK(_V) case MB16_2::_V:v=#_V;break
      C_SK(eNotSkiped);
      C_SK(eSkipPsnr);
      C_SK(eSkipQ);
      C_SK(eSkipLast);
      C_SK(eSkip1);
      C_SK(eSkip2);
      C_SK(eSkip3);
      C_SK(eSkip4);
      C_SK(eSkip5);
      C_SK(eSkip6);
      C_SK(eSkip7);
      C_SK(eSkip8);
      C_SK(eSkip9);
      C_SK(eSkipSSIM);
      C_SK(eSkipTest);
   }
   iLen+=sprintf(p+iLen," %s",v);
#endif
}

char * getStats(int x, int y, int w, char *p){

   #ifndef _T_DIS_DBG
   int l=0;
   int id=0;
   int xc=w>>4;
   id=(x>>4)+(y>>4)*xc;
   if(id>=MaxDBGID){l+=sprintf(p,"e");return p;}
#define D_B(_V)l+=sprintf(p+l,#_V"=%d\n",mst[id]._V);
   #define D_V(_V)l+=sprintf(p+l,#_V"=%d ",mst[id]._V);
   if(id>=MaxDBGID)return "out";

   l+=sprintf(p+l,"(%d,%d)v",x>>4,y>>4);
   if(mst[id].iMode==100)l+=sprintf(p+l,"(%d,%d)b",mst[id].vec[2],mst[id].vec[3]);
   l+=sprintf(p+l,"(%d,%d)\n",mst[id].vec[0],mst[id].vec[1]);
   D_B(iSad);
   D_B(iBestUV);
   
   
   D_B(iHada);
   D_B(iDev);
   D_B(iMinPosSad);D_B(iMode);D_B(iRotA);D_B(iTryMode&31);D_B(iTryMode>>5);
   int z,zz;

   
   l+=sprintf(p+l,"PSNR %d %d %d, %d %d %d\n",
      mst[id].iPsnr[0],mst[id].iPsnr[1],mst[id].iPsnr[2],
      mst[id].iEndPsnr[0],mst[id].iEndPsnr[1],mst[id].iEndPsnr[2]);
  // l+=sprintf(p+l,"SSIM %d %d %d\n",  mst[id].iSSim[0],mst[id].iSSim[1],mst[id].iSSim[2]);
   addTransSkip(p,l,mst[id].iSkip[0]);addTransSkip(p,l,mst[id].iSkip[1]);addTransSkip(p,l,mst[id].iSkip[2]);


   
   l+=sprintf(p+l,"\nY ");
   int sum=0;
   for(z=0;z<4;z++){l+=sprintf(p+l,"(%d,%d)",mst[id].iSkipV[z],mst[id].iBits[z]);sum+=mst[id].iBits[z];}
   l+=sprintf(p+l,"=%d  \nU ",sum);
   for(z=4;z<8;z++){l+=sprintf(p+l,"(%d,%d)",mst[id].iSkipV[z],mst[id].iBits[z]);}
   l+=sprintf(p+l,"  \nV ");
   for(z=8;z<12;z++){l+=sprintf(p+l,"(%d,%d)",mst[id].iSkipV[z],mst[id].iBits[z]);}

   if(1){
      for(z=0;z<4;z++){
         if(!mst[id].mb[z])continue;
         l+=sprintf(p+l,"  \n");
         for(zz=0;zz<64;zz++){
            l+=sprintf(p+l,"%5d,",(mst[id].mb[z]->dct[zz]));
            if((zz&7)==7)l+=sprintf(p+l,"\n");
         }
      }
   }
#endif
   return p;
}

void setMBBiS_vec(int id, int vx, int vy){
#ifndef _T_DIS_DBG
   if(id>=MaxDBGID)return ;
   mst[id].vec[2]=vx;
   mst[id].vec[3]=vy;
#endif
}
void setMBS_vec(int id, int vx, int vy, int sad, int dev, int minsad, int mode, int tMode, int rot, int iHada, int iBestUV)
{
#ifndef _T_DIS_DBG
   if(id>=MaxDBGID)return ;
   mst[id].vec[0]=vx;
   mst[id].vec[1]=vy;
   mst[id].iSad=sad;
   mst[id].iDev=dev;
   mst[id].iMinPosSad=minsad;
   mst[id].iMode=mode;
   mst[id].iRotA=rot;
   mst[id].iTryMode=tMode;
   mst[id].iHada=iHada<0?-1:(iHada);
   mst[id].iBestUV=iBestUV;
#endif
}

void setDCT_STAT(int i, int j, int k, int w, int iSkipV, int iBits, IMG_MB *mb){
#ifndef _T_DIS_DBG
   int xc=w>>4;
   int id=(i>>1)+(j>>1)*xc;
   int id2=((i&1)+(j&1)*2)+(k*4);
   if(id>=MaxDBGID)return ;
   mst[id].iSkipV[id2]=iSkipV;
   mst[id].iBits[id2]=iBits;
   mst[id].mb[id2]=mb;
#endif
}
void setPSNR_STAT(int i, int j, int k, int w, int iPsnr, int iEndPsnr){
#ifndef _T_DIS_DBG
   int xc=w>>4;
   int id=(i)+(j)*xc;
   if(id>=MaxDBGID)return ;
   mst[id].iPsnr[k]=iPsnr;
   mst[id].iEndPsnr[k]=iEndPsnr;
#endif
}
void setSSIM_STAT(int i, int j, int k, int w, int iSSim){
#ifndef _T_DIS_DBG
   int xc=w>>4;
   int id=(i)+(j)*xc;
   if(id>=MaxDBGID)return ;
   mst[id].iSSim[k]=iSSim;
#endif
}

void setSkip_STAT(int i, int j, int k, int w, int iSk){
#ifndef _T_DIS_DBG
   int xc=w>>4;
   int id=(i)+(j)*xc;
   if(id>=MaxDBGID)return ;
   mst[id].iSkip[k]=iSk;
   
#endif
}

int getMBParams(int i, int j, int k, int w, int &m, int &iSad, int &iMinPosSad, int &iTryMode, int &iDev, int &iVecLen){
#ifndef _T_DIS_DBG
   int xc=w>>4;
   int id=(i>>1)+(j>>1)*xc;
   //int id2=((i&1)+(j&1)*2)+(k*4);
   if(id>=MaxDBGID)return 0;
   iSad=mst[id].iSad;
   iMinPosSad=mst[id].iMinPosSad;
   m=mst[id].iMode;
   iTryMode=mst[id].iTryMode;
   iDev=mst[id].iDev;
   iVecLen=mmabs(mst[id].vec[0])+mmabs(mst[id].vec[1]);

   return 1;
#endif
   return 0;
}
int getMBParamMode(int i, int j, int k, int w,  int &iMode){
#ifndef _T_DIS_DBG
   int xc=w>>4;
   int id=(i>>1)+(j>>1)*xc;
   //int id2=((i&1)+(j&1)*2)+(k*4);
   if(id>=MaxDBGID)return 0;
   iMode=mst[id].iMode;

   return 1;
#endif
   return 0;
}

int getMBParamUV(int i, int j, int k, int w,  int &iSad){
#ifndef _T_DIS_DBG
   int xc=w>>4;
   int id=(i>>1)+(j>>1)*xc;
   //int id2=((i&1)+(j&1)*2)+(k*4);
   if(id>=MaxDBGID)return 0;
   iSad=mst[id].iBestUV;

   return 1;
#endif
   return 0;
}
int getMBParamHada(int i, int j, int k, int w,  int &iHada){
#ifndef _T_DIS_DBG
   int xc=w>>4;
   int id=(i>>1)+(j>>1)*xc;
   //int id2=((i&1)+(j&1)*2)+(k*4);
   if(id>=MaxDBGID)return 0;
   iHada=mst[id].iHada;

   return 1;
#endif
   return 0;
}
int getMBParamDev(int i, int j, int w){
#ifndef _T_DIS_DBG
   int xc=w>>4;
   int id=(i>>1)+(j>>1)*xc;
   //int id2=((i&1)+(j&1)*2)+(k*4);
   if(id>=MaxDBGID)return 0;

   return mst[id].iDev;
#endif
   return 5000;
}
void setMBParamDev(int i, int j, int w, int iDev){
#ifndef _T_DIS_DBG
   int xc=w>>4;
   int id=(i>>1)+(j>>1)*xc;
   //int id2=((i&1)+(j&1)*2)+(k*4);
   if(id>=MaxDBGID)return ;

   mst[id].iDev=iDev;

#endif
}

static inline int notZeros(DCT_TYPE *zv, int *zz, int frm=0, int cnt=TVAL_DCT_SZ){

   int z=0;
   int x=frm;
   for(;x<cnt;x++)
   {
      if(zv[zz[x]]){z++;}
   }
   return z;//last;
}

static inline int zeros(DCT_TYPE *zv, int *zz, int frm=0){

   int z=0;
   int x=frm;
   int iZeros=0;
   for(;x<16;x++)
   {
      if(zv[zz[x]]){iZeros=z;}else z++;
   }
   return iZeros;//last;
}
template<class T>
static inline int notZerosF(T *zv, int frm=0, int cnt=TVAL_DCT_SZ){

   int z=0;

   for(;frm<cnt;frm++)if(zv[frm]){z++;}
   return z;//last;
}

static inline int notZerosAligned(short *zv, unsigned int frm=0, unsigned int cnt=TVAL_DCT_SZ){

   int z=0;
   /*
   long long *ll=(long long*)&zv[cnt-4];
   
   while(!ll[0]){
      if(cnt<=4+frm)break;
      cnt-=4;ll--;
   }
   */

   for(;frm<cnt;frm++)if(zv[frm]){z++;}
   return z;//last;
}

//1 refs, 3bframes ,2 all, 4 key
int decodeAllFramesParts(){return 1;}

template<class T>
static int x264_mb_decimate_score( T *dct, int i_max )
{
#if 1
   return 9;//403.0 876KB, //305.1,1309KB
#else
   //without x264_mb_decimate_score is better
   //401.7 876KB

   static const int i_ds_table4[16] = { 3,2,2,1,1,1,0,0,0,0,0,0,0,0,0,0 };
   static const int i_ds_table8[64] = {
      3,3,3,3,2,2,2,2,2,2,2,2,1,1,1,1,
      1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,
      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };

      const int *zig=(i_max == 64)?&zzzff_zigzag_direct[0]: &tabzz4x4[0];
      //
      const int *ds_table = (i_max == 64) ? &i_ds_table8[0] : &i_ds_table4[0];
      int i_score = 0;
      int idx = i_max - 1;

      while( idx >= 0 && dct[zig[idx]] == 0 )
         idx--;

      while( idx >= 0 )
      {
         int i_run;

         if( (unsigned)(dct[zig[idx--]] + 1) > 2 )
            return 9;

         i_run = 0;
         while( idx >= 0 && dct[zig[idx]] == 0 )
         {
            idx--;
            i_run++;
         }
         i_score += ds_table[i_run];
      }

      return i_score;
#endif
}

const int t4x4PL[]={
   4,3,3,1, 3,3,1,0,  3,1,0,0, 1,0,0,0,
   4,3,3,1, 3,3,1,0,  3,1,0,0, 1,0,0,0,
   4,3,3,1, 3,3,1,0,  3,1,0,0, 1,0,0,0,
   4,3,3,1, 3,3,1,0,  3,1,0,0, 1,0,0,0,
};
const int t4x4P[]={
//   3,4,3,2,  4,3,2,1,   3,2,1,1,   1,1,1,1,  //120330 93KB
   //--4,2,3,2,   2,1,2,1,   3,2,3,2,   2,1,2,1, //116900 81 KB
  // 4,2,1,1,  2,1,1,0,  1,1,0,0,   1,0,0,0,
//   4,3,1,0,     3,1,0,0,    1,0,0,0,      0,0,0,0,
   //--++ 4,3,2,1,     3,2,1,0,   1,1,0,0,        0,0,0,0,
   //---4,3,2,1, 3,2,1,0, 2,1,0,0, 1,0,0,0,
   //--ok--4,3,2,0,    3,1,0,0,    2,0,0,0,    0,0,0,0,
   4,3,2,1, 3,2,1,0, 2,1,0,0, 1,0,0,0,
   4,3,2,1, 3,2,1,0, 2,1,0,0, 1,0,0,0,
   4,3,2,1, 3,2,1,0, 2,1,0,0, 1,0,0,0,
   4,3,2,1, 3,2,1,0, 2,1,0,0, 1,0,0,0,
   //4,3,2,1,     3,2,1,0,    2,1,0,0,      1,0,0,0,

//--   4,2,3,1, 2,2,1,0,   3,1,2,0,   1,0,0,0,

//   3,2,3,1,  2,1,1,1,   3,1,2,1,    1,1,1,1, //116880 81 KB
   //3,2,2,1,  2,1,1,0, 2,1,2,1,  1,0,1,0,  //116600 80




   /*
   1,0,1,4,  0,1,4,4,  1,4,80,80,  4,4,80,80,
   1,0,1,4,  0,1,4,4,  1,4,80,80,  4,4,80,80,
   1,0,1,4,  0,1,4,4,  1,4,80,80,  4,4,80,80,
   1,0,1,4,  0,1,4,4,  1,4,80,80,  4,4,80,80,
   */
};
const int t4x4B[]={
   3,3,0,0,       3,1,0,0,      0,0,0,0,    0,0,0,0,  
   3,3,0,0,       3,1,0,0,      0,0,0,0,    0,0,0,0,  
   3,3,0,0,       3,1,0,0,      0,0,0,0,    0,0,0,0,  
   3,3,0,0,       3,1,0,0,      0,0,0,0,    0,0,0,0,  
//--   3,1,3,1,     1,0,1,0,    3,1,3,1,  1,0,1,0,  
  // 2,1,1,0,   1,1,0,0,  1,0,0,0,   0,0,0,0,
   /*
   1,0,4,20, 1,4,20,80, 4,20,80,80, 20,80,80,80,
   1,0,4,20, 1,4,20,80, 4,20,80,80, 20,80,80,80,
   1,0,4,20, 1,4,20,80, 4,20,80,80, 20,80,80,80,
   1,0,4,20, 1,4,20,80, 4,20,80,80, 20,80,80,80,
   */
};

const int t4x4K[]={
   //--3,2,0,0, 2,1,0,0, 0,0,0,0, 0,0,0,0,  
   3,2,0,1,    2,1,0,1,    0,0,0,0,    1,1,0,0,  
   3,2,0,1,    2,1,0,1,    0,0,0,0,    1,1,0,0,  
   3,2,0,1,    2,1,0,1,    0,0,0,0,    1,1,0,0,  
   3,2,0,1,    2,1,0,1,    0,0,0,0,    1,1,0,0,  
   //--??--3,2,1,0, 2,1,0,0, 1,0,0,0, 0,0,0,0,  
//   3,3,0,0, 3,2,0,0,   0,0,0,0, 0,0,0,0,  
};
static const int ti6[]={
   1,1,1,0,0,0,0,0,        1,1,0,0,0,0,0,0,        1,0,0,0,0,0,0,0,        0,0,0,0,0,0,0,0,
   0,0,0,0,0,0,0,0,        0,0,0,0,0,0,0,0,        0,0,0,0,0,0,0,0,        0,0,0,0,0,0,0,0
};
static const int ti10[]={
   1,1,1,1,0,0,0,0,        1,1,1,0,0,0,0,0,        1,1,0,0,0,0,0,0,        1,0,0,0,0,0,0,0,
   0,0,0,0,0,0,0,0,        0,0,0,0,0,0,0,0,        0,0,0,0,0,0,0,0,        0,0,0,0,0,0,0,0
};
static const int ti15[]={
   1,1,1,1,1,0,0,0,        1,1,1,1,0,0,0,0,        1,1,1,0,0,0,0,0,        1,1,0,0,0,0,0,0,
   1,0,0,0,0,0,0,0,        0,0,0,0,0,0,0,0,        0,0,0,0,0,0,0,0,        0,0,0,0,0,0,0,0
};
static const int ti21[]={
   1,1,1,1,1,1,0,0,  1,1,1,1,1,0,0,0,  1,1,1,1,0,0,0,0,        
   1,1,1,0,0,0,0,0,  1,1,0,0,0,0,0,0,  1,0,0,0,0,0,0,0,   0,0,0,0,0,0,0,0,        0,0,0,0,0,0,0,0,        
};
const int nti8x8_4x4[]={
   0,0,0,0,1,1,1,1,
   0,0,0,0,1,1,1,1,
   0,0,0,0,1,1,1,1,
   0,0,0,0,1,1,1,1,
   1,1,1,1,1,1,1,1,
   1,1,1,1,1,1,1,1,
   1,1,1,1,1,1,1,1,
   1,1,1,1,1,1,1,1,
};

const int ti8x8_d[]={
   3,3,2,2,1,1,0,0,
   3,2,2,1,1,0,0,0,
   2,2,1,1,0,0,0,0,
   2,1,1,0,0,0,0,0,
   1,1,0,0,0,0,0,0,
   1,0,0,0,0,0,0,0,
   0,0,0,0,0,0,0,0,
   0,0,0,0,0,0,0,0,
};
static int iBitGainX=0;
static int iBitGainX1=0;
static int iBitGainXNZ=0;
static int iBitGainX1sc=0;
static int iBlockXCnt=0;
#if 1
//!defined(__SYMBIAN32__) && !defined(_WIN32_WCE)
#ifdef T_CAN_TEST_V
#define _TEST_T_BITS
//static int iSc[6];
#endif
#endif

//#define GET_MED3(_A,_B,_C) (min(max(_A, _B), min(max(_B, _C), max(_A, _C))))
#define GET_MIN3(_A,_B,_C) (min(_A, min(_B, _C)))


void createTable_int(char *name, int *tab, int iSize,char *fn);


//#define _ENC_D_CODE(_V) vlc.addXBits(_V,8)
//#define _DEC_D_CODE vlc.getNBitsC(8)
//#define _ENC_D_CODE(_V) vlc.toAC_val_X(_V,2)
//#define _ENC_D_CODE(_V) vlc.toL_Val(_V,3)
//#define _DEC_D_CODE vlc.get_L_Val(3)
//404 515
//#define _ENC_D_CODE(_V) vlc.toVLC(_V)
//#define _DEC_D_CODE vlc.getVlc()
//--2,404 502,1 404 514, 3 404 507
//#define _ENC_D_CODE(_V) {vlc.toVLC_X(_V,iPrevCode>128?6:(log((double)iPrevCode+2)/2)+1);iPrevCode+=(_V)*3;iPrevCode>>=2;}
//#define _DEC_D_CODE(_R) {_R=vlc.getVlcX(iPrevCode>128?6:(log((double)iPrevCode+2)/2)+1);iPrevCode+=(_R)*3;iPrevCode>>=2;}
//if((iBlocksED==3)&& iBlocks8orMore){vlc.toVLC_X(_V>>2,iLowHiQCode);if(iBlocks8orMore)vlc.addXBits(_V&3,2);}else 
//if((iBlocksED==3)&& iBlocks8orMore && !_C){_R<<=2;_R|=vlc.getNBitsC(2);}else
//|| (j>=2 && (iDecDct4x4&3)==0)
//||(iBlocks8orMore && tab_y[0]<=16)+(iBlocks8orMore )
//--#define _ENC_D_CODE(_V,_C) if((_C)  ){vlc.toVLC_PN(_V-(_C),2);} else {vlc.toVLC_X(_V>>(iBlocks8orMore),iLowHiQCode);if(iBlocks8orMore)vlc.addB(_V&1);}
//--#define _DEC_D_CODE(_R,_C) _R=((_C )?(vlc.getVlc_PN(2)+(_C)):vlc.getVlcX(iLowHiQCode)); if(iBlocks8orMore && !(_C)){_R<<=1;_R|=vlc.getB();}
#define _ENC_D_CODE(_V,_C) if((_C)  ){vlc.toVLC_PN(_V-(_C),2);} else {vlc.toVLC_X(_V>>(iBlocks8orMore),iLowHiQCode);if(iBlocks8orMore)vlc.addB(_V&1);}
#define _DEC_D_CODE(_R,_C) _R=((_C )?(vlc.getVlc_PN(2)+(_C)):vlc.getVlcX(iLowHiQCode)); if(iBlocks8orMore && !(_C)){_R<<=1;_R|=vlc.getB();}
//#define _ENC_D_CODE(_V,_C) if(_C){vlc.toVLC_PN(_V-_C,1+iBlocks8orMore);} else {vlc.toVLC_X((iBlocks8orMore && _V==0)?1:(iBlocks8orMore && _V==1?0:_V),iLowHiQCode+iBlocks8orMore);}
//#define _DEC_D_CODE(_R,_C) _R=((_C)?(vlc.getVlc_PN(1+iBlocks8orMore)+_C):vlc.getVlcX(iLowHiQCode+iBlocks8orMore));
//#define _ENC_D_CODE(_V) vlc.toL_Val(_V,3)
//#define _DEC_D_CODE vlc.get_L_Val(3)
//1,404 506;2,404 506;1,404 508
//#define _ENC_D_CODE(_V) vlc.toVLC_PN(_V,1)
//#define _DEC_D_CODE(_R) _R=vlc.getVlc_PN(1)

typedef int (t_guant_fnc)(unsigned int v,unsigned int t, const unsigned int iTabSh12);

inline static int quant_dif_try2(unsigned int v,unsigned int t, const unsigned int iTabSh12){
  return ((v+(t>>1))*iTabSh12)>>15;//  *1.11;
}

inline static int quant_dif_goodBlock(unsigned int v,unsigned int t, const unsigned int iTabSh12){
 //-- if(v<8)return 0;
//--  return ((v+(t>>2))*iTabSh12)>>15;//  *1.11;
  //return ((v+(t/6))*iTabSh12)>>15;//  *1.11;
  return ((v*4+t)*iTabSh12)>>17;
}
inline static int quant_dif_badBlock(unsigned int v,unsigned int t, const unsigned int iTabSh12){
  if(v*4<t*3)return 0;
//  return ((v+((t>>1)))*iTabSh12)>>15;//  *1.11;
  return ((v*2+t)*iTabSh12)>>16;
  
}
inline static int quant_dif_badBlock2(unsigned int v,unsigned int t, const unsigned int iTabSh12){
  if(v*3<t*2)return 0;
//  return ((v+((t>>1)))*iTabSh12)>>15;//  *1.11;
  return ((v*2+t)*iTabSh12)>>16;
  
}

inline static int quant_pic_nonKey(unsigned int v,unsigned int t, const unsigned int iTabSh12){
 // if(v<12)return 0;
  if(v*32<t*25)return 0;
  //if(v<t)return 0;
//--  return ((v+((t>>1)))*iTabSh12)>>15;//  *1.11;
  return ((v*2+t)*iTabSh12)>>16;//  *1.11;
}
static int iMaxXX=0;
static int iM1XX=1;
int setFSTabValx( int t0, int t1);

extern "C"{
void rci();
void addRacBits(unsigned char *r, int iPredID, int iFrom,int b);
void addRacVal(int v);
void addRacValP( int v, int pos);
int rce();
int mainzz(unsigned char *r, int SIZE, unsigned char *b);
}
void initFSTab(){
       static int iInitFSTab=1;
       if(iInitFSTab){
          iInitFSTab=0;
          //iFC=(iDCQ+t[1]+48)>>4;
//   
#define _GET_FC(_fs,_t1,_iDCQ)  ((_fs=setFSTabValx((_t1)>>1,_t1))+((_iDCQ)>>3))
//#define _GET_FC(_fs,_t1,_iDCQ)  ((_iDCQ+(_t1)*2)>>4);(_fs=setFSTabValx((_t1)>>1,_t1))
//iFC=(iDCQ+t[1]*2)>>4;
int fs;
//#define _GET_FC(_t1,_iDCQ)  ((testFStrenght(0,_t1,0,0)+(_iDCQ))>>2)
          for(int i=6000;i>0;i--){
             int iFC=_GET_FC(fs,i,(i*100/222));//iFC=testFStrenght(0,i,0,0)+(((i*100/222)*2)>>4);//+i;

             //iFC=(i+48)>>4;

             if(iFC>=300)continue;
             setFSTabVal(iFC,i*100/222,i,fs);

             setFSTabVal(iFC+1,i*100/223,i,fs);
             setFSTabVal(iFC+2,i*100/222,i,fs);
             setFSTabVal(iFC+3,i*101/223,i,fs);
             setFSTabVal(iFC+4,i*101/222,i,fs);
          }
       }
}

class TDCTX{
   unsigned char cropTbl[1024*8];
   unsigned char s_t_d8[512];
   unsigned char s_t_d4[512];
   unsigned char s_t_d2[512];
   unsigned char s_t_d1[512];

   unsigned char *t_d8;
   unsigned char *t_d4;
   //RLTable rl;
public:
   unsigned char *t_d2;
   unsigned char *t_d1;
   MB16_2 *mb16_2;
   int iDecDct4x4;
   CTVLCX vlc;
   int iIsFirstPass;
   int iIsKey;
   int iIsKeyUV;
   int iPrevWasKey;
   int iQIsMax;
   int iHasDifOnly;
   int iQuantIsConst;
   int iEncPicOnly;
   int iLowQval;
   int iSkUV;
   int iSkipRestore;
   int iEnc4x4Only;
   int iSkipUVFilter;
   int iDCQuant;
   int iDCQuantUV;
   int iVisDecoder;
   int iLastYBits;
   int iSkipPutBlocks;
   int iHasBigCoefs;
   int iGBits;
   int iFilter;

   int iSQQuantErrUV;
   int iLowHiQCode;

   unsigned char pr1[16];
   unsigned char pr0[16];
   unsigned char prx[16];
   //unsigned char prxt[16];
   int iPrevCode;
   int iBlocks8orMore;
   int iAllBlocks;
   int iBlocksED;

   TDCTX(){
      iFilter=0;
      iAllBlocks=0;
      iBlocksED=0;
      iLowHiQCode=2;
      iBlocks8orMore=0;
      iHasBigCoefs=0;
      iPrevCode=0;
      iSkipPutBlocks=0;
      iLastYBits=0;
      iSQQuantErrUV=92;
      iPrevWasKey=0;
      mb16_2=NULL;
      iIsFirstPass=1;
      iVisDecoder=0;
      iDCQuant=8;
      iSkipUVFilter=0;
      iSkipRestore=0;
      iLowQval=0;
      iEncPicOnly=0;
      iDecDct4x4=0;
      iEnc4x4Only=0;
      iSkUV=0;

      iReqBits=4000*8;
      iAvgBlockBits=40;
      iIncBitrateN=0;
      iPrevInitQ=-1;
      iQuantIsConst=0;
      skVal=NULL;
      iPrevRefSize=2000;
      iNextQ=50;
      iQIsMax=0;
      iHasDifOnly=0;
      pTab=(int*)&ZIG_ZAG_TAB[0];
      t_idct_int32_init();
      loadPred();
      iIsKeyUV=0;
      int i;
      for(i=0;i<64;i++)zigZagCreate[i]=0;
      t_d8=&s_t_d8[256];
      t_d4=&s_t_d4[256];
      t_d2=&s_t_d2[256];
      t_d1=&s_t_d1[256];
      for(i=0;i<256;i++){
         t_d8[-i]=t_d8[i]=div_8_abs(i);
         t_d4[-i]=t_d4[i]=div_4_abs(i)+1;
         t_d2[-i]=t_d2[i]=div_2_abs(i)+1;
         t_d1[-i]=t_d1[i]=i;

      }
initFSTab();


      iIncBitrate=0;


      s_cropTbl=&cropTbl[2048];
      for(i=-2048;i<2048*3;i++){
         s_cropTbl[i]=i<0?0:(i>255?255:i);
      }
      mbFirst=NULL;
      bufVlc=NULL;
      mbType=NULL;
      mbFirstDec=NULL;
      //init_rl(&rl_inter);
      iIsB=0;
      iPrevInitIsB=0;
      iIsKey=0;
      iPrevQ=50;
      iSkipDct=0;
      iTotalCoefs=0;
      iSkipUV=0;
      iW=iH=0;
      iSkipId=0;
      iPartLimitSize=0;
      iIsReferenceFrame=0;
      iThisWasB=0;
      iFramesAfterKey=10;
      iQValIn=50;
      tab_y_b[0]=4;tab_y_b[16]=8;
      for(int i=0;i<16;i++){tab_y_b[i]=32;tab_y_b[i+16]=64;}
      iQLimX1=10;
      iQLimX2=iQLimX1+5;
      iQParam=15;
      iMaxQParam=25;
      iDecRefQ=0;
      iThisWasBX=0;
//      iQTestLim=2;
     // iBigestStartSkipedPsnr[0]=iBigestStartSkipedPsnr[1]=iSmallestSendPsnr[0]=iSmallestSendPsnr[1]=0;
   }
   int iSStartSkipedPsnr[2];
   int iBSendPsnr[2];
   int iTotalCoefs;

   int iPartLimitSize;
   int iSkipDct;
   int iSkipUV;
   int iAvgBlockBits,iIncBitrateN,iReqBits;
   int xc,yc;
   
   int tab_y[192*3];
   int tab_y_b[32];
   int tab_uv[192*3];
   int tabSK_Y[64];
   int tabSK_UV[64];

   int nbtab_y[192*3];
   int nbtab_y_b[32];
   int nbtab_uv[192*3];
   int nbtabSK_Y[64];
   int nbtabSK_UV[64];

   int zigZagCreate[64];
   unsigned char *bufVlc;

   int iPrevLastDec7x;
   int iMaxLev;
   int iMaxLen;
   int iEncValues;
   int iSigns;
   int iRangeLen;
  // int  img_ri[2400*1200/4];
   //short img2[2400*1200/4];
   //char predv[2400*1200/64];
   int iSkipValues;
   int iPredValues;
   int iIsB;
   int iDecRefQ;
   int iThisWasB,iFramesAfterKey;
   int iThisWasBX;
   int iIncBitrate;
   int iIsReferenceFrame;
   int *skVal;//[2400*1200/64];
   unsigned char *mbType;
   int iMbTypePos;

   int iMaxNonDifAddCnt;

  
   int iCurBl;
   int iBlStride;
  // int img[2400*1200];
  // char bufTmp[1024*1024];
   int iQVal,iQValIn,iQParam,iMaxQParam;
   int iW;
   int iH;
   int iW16;
   int iH16;
   int iPredDC;
   IMG_MB_DEC *mbFirstDec;
   void initEnc16(int w, int h, int iIsDec=0){
      iIsKeyUV=0;
      if(iIsDec)return;
      if(iW16!=w || iH16!=h){
         delete []mb16_2;
         mb16_2=NULL;
         iW16=w;
         iW16=h;
         mb16_2=new MB16_2[((w>>4)+1)*((h>>4)+1)];

      }
      

   }
   void  initMem(int w, int h, int iIsDec=0){
      initEnc16(w,h,iIsDec);
      if(iW!=w || iH!=h){
         iSkipId=0;
         delete mbFirst;
         mbFirst=NULL;
         delete skVal;
         skVal=NULL;
         delete bufVlc;
         bufVlc=NULL;
         delete mbType;
         mbType=NULL;
         delete mbFirstDec;
         mbFirstDec=NULL;
      }
      
//      mbFirstDec
      
      if(skVal==NULL)skVal = new int[w*(h+4)*3/64];
      if(mbType==NULL)mbType=new unsigned char[w*(h+4)*3/64];
      if(!iIsDec){
         if(mbFirst==NULL)mbFirst=new IMG_MB[(w*h*3)>>6];
         if(bufVlc==NULL)bufVlc=new unsigned char [w*h];// /2];//atkarigs no quant
         //
         bufVlc[0]=0;
      }
      else {
         if(mbFirstDec==NULL)mbFirstDec=new IMG_MB_DEC[(w*h*3)>>6];
      }
      iW=w;iH=h;

      return ;
   }
   int iPrevInitQ;
   int iPrevInitIsB;
   int iPrevCoefsCnt;
   int iPrevCoefsCnt4x;

   void init(int w, int h, int &q, int iIsDec=0)
   {
      iIsKeyUV=0;
      iRndN=1;
      iSStartSkipedPsnr[0]=iSStartSkipedPsnr[1]=5000;
      iBSendPsnr[0]=iBSendPsnr[1]=2000;
      iPrevCoefsCnt4x=iPrevCoefsCnt=0;
      
      iMaxNonDifAddCnt=0;
      iPrevLastDec7x=64;
      initMem(w,h,iIsDec);
      
      iMbTypePos=0;
      iTotalCoefs=0;
      vlc.reset();
      vlc.pBitBuf=bufVlc;
      //if(!iIsDec)memset(bufVlc,0,w*h/2);;
      iSigns=0;
      iRangeLen=0;
      iSkipValues=0;
//iBitsGain2x2_test=0;iBitsGain2x2_test_better=0;
     // int quality=q;
      iQVal=q;
      iPredValues=0;

      iMaxLev=0;
      iMaxLen=0;

      //quality+=30;
      //quality*=90;
      //quality/=120;
//

      xc=w/TVAL_8;
      yc=h/TVAL_8;
      iQuantIsConst=CONST_QUANT;
      if(iPrevInitQ!=q || iPrevInitIsB!=iIsB){
    //     debugss("aa",2,1);
         iPrevInitQ=q;iPrevInitIsB=iIsB;
         initTabZ(q,&tab_y[0],&j2_y_quant_tbl[0],0,iIsB,iSkipDct?12:iQuantIsConst);//CONST_QUANT);
         initTabZ(q,&tab_uv[0],&j2_cb_quant_tbl[0],1,iIsB,iSkipDct?16:iQuantIsConst);//CONST_QUANT);
         if(!iIsDec)calcDCTSQErr();

      }
      //if(!iIsDec && !iIsReferenceFrame&& !iIsKey)initQ4x4_SkipLast(&tab_y_b[0],iIsB|iThisWasB, tab_y[128],tab_y[129], tab_y[128+5]);



   }
   void calcDCTSQErr(){
      iSQQuantErrUV=48;
      /*
      short qq[64]={
         //tab_uv[0]/2,tab_uv[1],0,0,0,0,0,0,
         tab_uv[0],0,0,0,0,0,0,0,
//         tab_uv[1]  ,0,0,0,0,0,0,0,
         tab_uv[1]/2+2,0,0,0,0,0,0,0,
         tab_uv[2]/4+2,0,0,0,0,0,0,0,
         0,0,0,0,0,0,0,0,
         0,0,0,0,0,0,0,0,
         0,0,0,0,0,0,0,0,
         0,0,0,0,0,0,0,0,
         0,0,0,0,0,0,0,0,
      };
      */
      short qq[64]={
         //tab_uv[0]/2,tab_uv[1],0,0,0,0,0,0,
         (tab_uv[128]>>3)+2,0,0,0,0,0,0,0,
//         tab_uv[1]  ,0,0,0,0,0,0,0,
         (tab_uv[128]>>3)+3,0,0,0,0,0,0,0,
         tab_uv[128]>>3,0,0,0,0,0,0,0,
         0,0,0,0,0,0,0,0,
         0,0,0,0,0,0,0,0,
         0,0,0,0,0,0,0,0,
         0,0,0,0,0,0,0,0,
         0,0,0,0,0,0,0,0,
      };
     // short qq[64];
      //for(int i=0;i<64;i++)qq[i]=((i&3==0)?(tab_uv[i]>>2):(-tab_uv[i]>>3));
      idct_fnc(&qq[0]);
      for(int i=0;i<64;i++)iSQQuantErrUV+=qq[i]*qq[i];
   }
   int iSQQuantErr4x4Y;
   void calc4x4SQErr(){
      iSQQuantErr4x4Y=0;//tab_y[128];
      
      void itrxF(short *p);
      /*
      short qq[16]={
         tab_y[128]/4,0,0,0,
         tab_y[129]/2,0,0,0,
         0,0,0,0,
         0,0,0,0,
      };
      */
      short qq[16]={
         //tab_y[128]/4
         0,tab_y[129]*2/3,0,0,
         0,0,0,0,
         tab_y[130]/3,0,0,0,
         0,0,0,0,
      };
     // short qq[64];
      //for(int i=0;i<64;i++)qq[i]=((i&3==0)?(tab_uv[i]>>2):(-tab_uv[i]>>3));
      qq[0]+=8;
      itrxF(&qq[0]);
      for(int i=0;i<16;i++){qq[i]>>=4;iSQQuantErr4x4Y+=qq[i]*qq[i];}
      //iSQQuantErr4x4Y+=tab_y[128];//+32;
     // iSQQuantErr4x4Y*=8;
      
   }

   int iRndN;
   //template<int iPic, int iFirstCoefOnly>
   inline  void deQm4(DCT_TYPE *p, DCT_TYPE *deq_dct,const int *tab){
      int i;
      for(i=0;i<TVAL_DCT_SZ;i++){
         deq_dct[i]=(p[i]*tab[i]);
      }
   }
   template<int iPic, int iFirstCoefOnly>
   inline  void deQ(DCT_TYPE *p, DCT_TYPE *deq_dct,const int *tab, int iCoefs=64, const int iAddNoise=0)
   {
     //// const int iPic=0;
      //const int iPic=1;
      int i,th=0;
      int t;
//      int c=0;
      //const int iAddNoise=0;
      const int iIsLossLess=iFirstCoefOnly && tab[128]==1;
      if(iIsLossLess){memcpy(deq_dct,p,sizeof(DCT_TYPE)*TVAL_DCT_SZ);return;}
      memset(deq_dct,0,sizeof(DCT_TYPE)*TVAL_DCT_SZ);
      if(iFirstCoefOnly){
         t=tab[128];
         if(!iPic)th=t>>2;
      }
   //   iCoefs=64;
      //static int iRndN=1;
//       iRndN+=p[1]*7;
  //     iRndN+=p[8]*17;

      const int i_mCanAddN[]={
         0,1,0,1,  1,1,1,1,   0,1,3,1,    1,1,1,1,
         0,1,0,1,  1,1,1,1,   0,1,3,1,    1,1,1,1,
         0,1,0,1,  1,1,1,1,   0,1,3,1,    1,1,1,1,
         0,1,0,1,  1,1,1,1,   0,1,3,1,    1,1,1,1,

      };
      
      if(iPic==2){
         i=1;
         if(p[0]){
            iCoefs--;
            deq_dct[0]=(p[0]*tab[0]+1)>>1;
         }
      }
      else i=0;
      //deq vareetu q_dct[i]=tabM[p[i]];
      if(iCoefs<=0)return;

      for(;i<TVAL_DCT_SZ;i++){
         if(p[i]==0){if(iAddNoise && i_mCanAddN[i]){t=tab[i];deq_dct[i]=((iRndN%((t>>2)+1))-iRndN%((t>>1)+1)+i_mCanAddN[i])>>i_mCanAddN[i];} iRndN+=tab[i]*7010011; continue;}
         if(iAddNoise){
            iRndN+=p[i]*23;
            iRndN+=100010011;
         }
         if(!iFirstCoefOnly){
            t=tab[i];//<<1;
            if(!iPic)th=(t>>2);//(t*5)>>3;;//th=(t*20)>>7;
         }
         //th=t>>1;//(t>>2)|1;
         if(p[i]<0)
         {
//            if(!iPic)p[i]--;
            //129395
            deq_dct[i]=p[i]*t-(th);
            //if(q_dct[i]&1)q_dct[i]--;
            if(iAddNoise)iRndN-=p[i]*1010011;
         }
         else
         {
  //          if(!iPic)p[i]++;
                 //p[i]++;
            deq_dct[i]=p[i]*t+th;
            if(iAddNoise)iRndN+=p[i]*1100101;;
            //if(q_dct[i]&1)q_dct[i]++;
          }   
         
         //q_dct[i]+=((iRndN%((t>>2)+1))-iRndN%((t>>1)+1)+1)>>2;
         iCoefs--;
         if(iCoefs<=0)break;
      }
      //for(;i<TVAL_DCT_SZ;i++){p[i]=0;}
      //if(c==1 && q_dct[0]<0)q_dct[0]-=tab[0];
   }
   template<int iPic>
   inline  void deQN(DCT_TYPE *p, DCT_TYPE *deq_dct, const int *tab, int n)
   {
    //  char ddd[64];
      //for(int z=12;z>=3;z--){ddd[z]=ddd[z-3];}
     //// const int iPic=0;
      //const int iPic=1;
      int i;
      DCT_TYPE t;

         
         for(i=0;i<n;i++){
            if(iPic){
               deq_dct[i]=p[i]*tab[i];
            }
            else{
               if(p[i]==0){deq_dct[i]=0; continue;}
               t=tab[i];
               
               if(p[i]<0)
                  deq_dct[i]=p[i]*t;
               else
                  deq_dct[i]=p[i]*t;
                  

                  //deq_dct[i]=(p[i]*t*9+4)>>3;
            }
      }
      //for(;i<TVAL_DCT_SZ;i++){p[i]=0;}
      //if(c==1 && q_dct[0]<0)q_dct[0]-=tab[0];
   }
   template<int iPic>
   inline  void deQ4x4_Flag(DCT_TYPE *p, DCT_TYPE *deq_dct, const int *tab, int f)
   {
      //TODO deq in decx15
     //// const int iPic=0;
      //const int iPic=1;
      int i,j;
 //     DCT_TYPE t;
  
      /*
      //static const int qt[]={5,11,16,22,27,32};
      int qx=40-iQParam+5;
      int bQ=(24*(6-(qx%6))+(qx%6)*48)*(1<<(qx/6));
      const int sh=qx/6+2;
      int aQ=bQ/1.875;
      int cQ=bQ*2.3;
      int tq[]={aQ,bQ,aQ,bQ,bQ,cQ,bQ,cQ,aQ,bQ,aQ,bQ,bQ,cQ,bQ,cQ,};
      const int bias=1<<(sh-1);
      */
      
      //static const int ft[]={1,2,4,8};
      for(j=0;j<4;j++,deq_dct+=16,p+=16){
         deq_dct[0]=0;
         if((f & (1<<j))==0) continue;
               //6+12

#define DEQ_PIC(_R,_V,_Q) _R=((_V)*(_Q))
//#define DEQ_PIC(_R,_V,_Q) {if(_V<0)_R=-((_Q)<<(-(_V)-1));else if(_V>0)_R=(_Q)<<((_V)-1);else _R=0;}
//#define DEQ_DIF DEQ_PIC
//----------
//--#define DEQ_DIF(_R,_V,_Q) {if(_V<0)_R=(_V)*(_Q)-((_Q)>>2);else if(_V>0) _R=(_V)*(_Q)+((_Q)>>2);else _R=0;}

//#define DEQ_DIF(_R,_V,_Q) {if(_V<0)_R=((_V)-0.2)*(_Q);else if(_V)_R=((_V)+0.2)*(_Q);}
//#define DEQ_DIF(_R,_V,_Q) _R=((_V)*(((_Q)*9+4)>>3))
#define DEQ_DIF(_R,_V,_Q) _R=((_V)*((_Q)))
//#define DEQ_DIF(_R,_V,_Q) if(_V==1)_R=((1.25)*((_Q)));else if(_V==-1)_R=((-1.25)*((_Q)));else  _R=((_V)*((_Q)))


//#define DEQ_DIF(_R,_V,_Q) _R=((_V)*((_Q)+((_Q)>>3)))
//#define DEQ_DIF(_R,_V,_Q) _R=((_V)*((_Q)))
#define DEQ_DP(_R,_V,_Q)  if(iDeQDif==2){DEQ_PIC(_R,_V,_Q); }else {DEQ_DIF(_R,_V,_Q);}
//#define DEQ_PIC(_R,_V,_Q) {if(_V<0)_R=(_V)*(_Q)-((_Q)>>3);else _R=(_V)*(_Q)+((_Q)>>3);}
//#define DEQ_DIF(_R,_V,_Q) _R=(17*(_V)*(_Q))>>4
         for(i=1;i<16;i++){
            if(iPic){
               DEQ_PIC(deq_dct[i],p[i],tab[i]);

            }
            else{
               if(p[i]==0){deq_dct[i]=0; continue;}

               const DCT_TYPE t=tab[i];
               DEQ_DIF(deq_dct[i],p[i],t);
               /*
               if(p[i]<0)
                  deq_dct[i]=p[i]*t-(t>>2);
               else
                  deq_dct[i]=p[i]*t+(t>>2);
                  */
                 // deq_dct[i]=(p[i]*t+4)>>3;
            }
            /*
            static  const short d[]={
               1,5,1,25,
               5,25,5,25,
               1,5,1,25,
               5,25,5,25,
            };
            static  const short db[]={
               0,2,0,2,
               2,12,2,12,
               0,2,0,2,
               2,12,2,12,
            };
            if(d[i]!=1){
               if(deq_dct[i]<0)deq_dct[i]=-((db[i]-deq_dct[i])/d[i]);
               else deq_dct[i]=(db[i]+deq_dct[i])/d[i];
               
            }
            */
         }
         //deq_dct+=16;p+=16;
      }
      //for(;i<TVAL_DCT_SZ;i++){p[i]=0;}
      //if(c==1 && q_dct[0]<0)q_dct[0]-=tab[0];
   }
   int iPrevDc[3];
   int iPrevDcT[3][2];
  
   template <int iPic>
   int QErr(DCT_TYPE *p, DCT_TYPE *dct, const  int *tab,const  int cnt, int i_IsB, int k, int iBigDC, int coefs){
//return 1;
      //const int *t4x4=i_IsB?&t4x4B[0]:(k?&t4x4K[0]:&t4x4P[0]);
     // return 1;
      int i,j;
//      int v,v2;
      int iSavedBits=0;


      const int ca_1_4[]={
         0,1,1,1,
         1,1,0,0,
         1,0,0,0,
         1,0,0,0
      };
      const int ca_x[]={
         0,1,1,1,
         1,1,0,0,
         1,0,1,0,
         1,0,0,0
      };
      const int ca_b_dc_c[]={
         1,1,1,1,
         1,1,1,1,
         1,1,1,1,
         1,1,1,1,
      };
      int *ca=(int*)(coefs?&ca_b_dc_c[0]:(iBigDC?&ca_1_4[0]:&ca_x[0]));
//#define T_NO_REM
     // return 1;
      int iCanAdd=!k && !i_IsB;
      int iSend[]={0,0,0,0};
      for(j=0;j<4;j++,p+=16,dct+=16){
         if(!(*(long long*)p) && !(*(long long*)(p+4)) && !(*(long long*)(p+8)) && !(*(long long*)(p+12))){
            //continue;
            ca=(int*)(iBigDC?&ca_1_4[0]:&ca_x[0]);
            //if(!iBigDC)continue;
            //ca=(int*)&ca_1_4[0];

         }
         else ca=(int*)&ca_b_dc_c[0];
//         int iX=0;
         for(i=1;i<16;i++){
            //if(!t4x4[i])continue;
            //if(p[i]==0)continue;
            int pi=p[i];

            if(iPic){
               if(pi<0){
                  int t=tab[i];
                  int a1=mmabs(pi*t-dct[i]);//+(t>>3);;
                  int a3=(pi!=-1)?mmabs((pi+1)*t-dct[i]):-dct[i];
                  if((a3<=a1)&& pi){
                     p[i]++;
                     iSavedBits+=10;
 //  debugss("saved",iSavedBits,iSend[j]);
                  }
                  iSend[j]-=p[i];
                  
               }
               else if(pi>0){
                  int t=tab[i];

                  int a1=mmabs(pi*t-dct[i]);//+(t>>3);
                  int a3=(pi!=1)?mmabs((pi-1)*t-dct[i]):dct[i];
                  if(a3<=a1 && pi){
                     p[i]--;
                     iSavedBits++;
   //debugss("saved",iSavedBits,iSend[j]);
                  }
                  iSend[j]+=p[i];
               }
            }
            else {
               const int t=tab[i];
#if 1
               const int tLim=(t*3)>>2;//t>>1
#else          
               const int tLim_T[]={
                  23,24,25,26,
                  24,25,26,27,
                  25,26,27,28,
                  26,27,28,29,
               };
               const int tLim=((t*tLim_T[i])>>5)+1;
#endif         
               if(pi<0 || ( iCanAdd &&  dct[i]<-tLim && (ca[i]))){ //)){//
                  
                  const int tsha=(t>>2);

                  const int a1=pi?mmabs(pi*t-dct[i]-tsha):-dct[i];//+(t>>3);;
                  const int a2=mmabs((pi-1)*t-dct[i]-tsha);
   #ifdef T_NO_REM
                  int a3=(pi!=-1)?mmabs((pi+1)*t-dct[i]-tsha):-dct[i];
                  if(a3<=a1+1 && pi){
                     p[i]++;
                     iSavedBits+=10;
   debugss("saved",iSavedBits,iSend[j]);
                  }else 
   #endif
                  if(a2+1<a1 && ((pi && vlc.bitsLenAC[((-pi+1))]==vlc.bitsLenAC[(-pi)]) || (iCanAdd &&pi==0))){
                     p[i]--;
                     iSavedBits+=100;
                  }
                  /*
                  else if(a1>(t>>1)){
                     p[i]--;
                     iSavedBits++;
                  }
                  */
                  //if()
                  iSend[j]-=p[i];
       //           v=(((p[i]*8-1)*tab[i]+4)>>3)-dct[i];
                  
               }
               else if(pi>0 || (iCanAdd  && dct[i]>tLim && (ca[i]))){
                  const int tsha=(t>>2);

                  const int a1=pi?mmabs(pi*t-dct[i]+tsha):dct[i];//+(t>>3);
                  const int a2=mmabs((pi+1)*t-dct[i]+tsha);
   #ifdef T_NO_REM
                  int a3=(pi!=1)?mmabs((pi-1)*t-dct[i]+tsha):dct[i];
                  if(a3<=a1+1 && pi){
                     p[i]--;
                     iSavedBits++;
   debugss("saved",iSavedBits,iSend[j]);
                  }else 
   #endif
                  if(a2+1<a1 && ((pi && vlc.bitsLenAC[(1+pi)]==vlc.bitsLenAC[pi]) || (iCanAdd &&pi==0))){
                     p[i]++;
                     iSavedBits+=1000;
                  }
                  iSend[j]+=p[i];
               }
               
               
            }

         }
         
         
      }
      //if(iSavedBits)debugss("saved",iSavedBits,iSend);
      
      if(0){//1||iCanAdd){//1||iCanAdd){// && !iAdd_1_4 &&iSavedBits){
         p-=64;
         for(i=0;i<4;i++){
       //     if(iSend[i]==1 && (!p[i*16+5] && !p[i*16+1] && !p[i*16+4]&& !p[i*16+8] && !p[i*16+2]/* && !p[i*16+3]&& !p[i*16+12]*/)){memset(p+16*i,0,32);iSend[i]=0;}
           if(iSend[i]==1){memset(p+16*i,0,32);iSend[i]=0;}
         }
      }
      

      return iSend[0]+iSend[1]+iSend[2]+iSend[3];
   }
   int QErr8(DCT_TYPE *p, DCT_TYPE *dct, const  int *tab,const  int cnt, int i_IsB, int k){
      //const int *t4x4=i_IsB?&t4x4B[0]:(k?&t4x4K[0]:&t4x4P[0]);
      int i,iSend=0;
    //  int v,v2;
      int iSavedBits=0;
     // return 1;
         
      for(i=1;i<64;i++){
         //if(!t4x4[i])continue;
         //if(p[i]==0)continue;
         if(p[i]<0){
            int t=tab[i];
            //int tsha=t>>2;
            
            int a1=mmabs(p[i]*t-dct[i]);//+(t>>3);;
            int a2=mmabs((p[i]-1)*t-dct[i]);
            int a3=(p[i]!=-1)?mmabs((p[i]+1)*t-dct[i]):dct[i];
            if(a3<=a1){
               p[i]++;
               iSavedBits++;
            }else if(a2<=a1 && vlc.bitsLen[((-p[i]+1)<<1)]==vlc.bitsLen[(-p[i])<<1]){
               p[i]--;
               iSavedBits+=100;
            }
            iSend-=p[i];
            
         }
         else if(p[i]>0){
            int t=tab[i];
//            int tsha=t>>2;

            int a1=mmabs(p[i]*t-dct[i]);//+(t>>3);
            int a2=mmabs((p[i]+1)*t-dct[i]);
            int a3=(p[i]!=1)?mmabs((p[i]-1)*t-dct[i]):dct[i];
            if(a3<=a1){
               p[i]--;
               iSavedBits++;
            }else if(a2<=a1 && vlc.bitsLen[((1+p[i])<<1)]==vlc.bitsLen[(p[i]<<1)]){
               p[i]++;
               iSavedBits+=100;
            }
            iSend+=p[i];
         }
     }
      
     // if(iSavedBits)debugss("saved",iSavedBits,iSend);

      return iSend;
   }
 
   inline int Q_One(unsigned int v, unsigned int t, const unsigned int iTabSh12){

     //-- return ((v+((t*21)>>7))*iTabSh12)>>15;
      //--return ((v+(((t*41)>>7)))*iTabSh12)>>15;
      /*
      const int r=((v+(((t*40)>>7)))*iTabSh12)>>15;
      if(!r)return 0;
      //const int r2=((v+(((t*44)>>7)))*iTabSh12)>>15;
      const int r2=((v+(((t*51)>>7)))*iTabSh12)>>15;
      return vlc.bitsLen[r2<<1]<=vlc.bitsLen[r<<1]?r2:r;
      */
      //39.45
      /*
      */
#if 1
      /*
      127,121,127,121,
      121,115,121,115,
      127,121,127,121,
      121,115,121,115,

      */
      /*
      static const int dz[]={
         7,0,7,0,
         0,-7,0,-7,
         7,0,7,0,
         0,-7,0,-7,
      };

      */
      
      
      //return (int )(((double)v)/(double)(t)+0.33);
      //44,49, ja dz 121
      return ((v+t/3)*iTabSh12)>>15;
      //if(r)return r;
      //return ((v+t/2)*iTabSh12)>>15;
      //return rr>3?3:rr;
      //const int r=((v)*iTabSh12)>>15;
      //return r;//<2?r:(((v+t/2)*iTabSh12)>>15);
      //const int r2=((v+(((t*44)>>7)))*iTabSh12)>>15;
      //const int r2=((v+(((t*(43))>>7)))*iTabSh12)>>15;
      //return vlc.bitsLenAC[r2]<=vlc.bitsLenAC[r]?r2:r;
#else 
      const unsigned int tmp=v<<7;
      if(tmp<t*69)return 0;
      if(tmp<t*195)return 1;
      if(tmp<t*384)return 2;
      if(tmp<t*642)return 3;
      //const int r=((v+(((t*42)>>7)))*iTabSh12)>>15;const int r2=((v+(((t*51)>>7)))*iTabSh12)>>15;
      const int r=((v+(((t*48)>>7)))*iTabSh12)>>15;const int r2=((v+(((t*58)>>7)))*iTabSh12)>>15;
      return vlc.bitsLenAC[r2]<=vlc.bitsLenAC[r]?r2:r;
#endif
/*
      if(v*11<t*7)return 0;
      const int r=((v+(((t*46)>>7)))*iTabSh12)>>15;
      if(!r)return 1;
      const int r2=((v+(((t*58)>>7)))*iTabSh12)>>15;
      return vlc.bitsLen[r2<<1]<=vlc.bitsLen[r<<1]?r2:r;
  */    
   }
//typedef int (t_guant_fnc)(unsigned int v,unsigned int t, const unsigned int iTabSh12)
   inline int Q_OneD2(unsigned int v,unsigned int t, const unsigned int iTabSh12, const unsigned int bias){

     //if(v*2<t+12)return 0;
      
//  const int bias=(t/6);// -(t>>2);//if(bias<0)bias=0;
  const int rr=((v+bias)*iTabSh12);//  *1.11;

  return (rr)>>15;
   }
   inline int Q_OneD3( int v,  int t, const  int iTabSh12, int id){
      static const int b[]={
         0,1,0,1,
         1,2,1,2,
         0,1,0,1,
         1,2,1,2,
      };
      switch(b[id&15]){
         case 1:if(v*15<t*16)return 0;
         case 2:if(v*7<t*8)return 0;
      }
      
      return ((v+(t/6))*iTabSh12)>>15;
   }
   int iQLimX1;
   int iQLimX2;
   void initTabSK(){
/*
#define _Q_A 110
#define _Q_B 128
#define _Q_C 160 
*/
#define _Q_A 110
#define _Q_B 124
#define _Q_C 140 

      static const int t_lim_mult[]={

         _Q_A,_Q_B,_Q_A,_Q_B,
         _Q_B,120,_Q_B,_Q_C,
         _Q_A,_Q_B,_Q_A,_Q_B,
         _Q_B,_Q_C,_Q_B,_Q_C,

      };
      int i;
      //int iAdd=iIsB?10:0;
      const int b=iIsB|iThisWasB|iThisWasBX?1:0;
      int iAdd1=b?10:0;

      const static int flIgM[]={
         9,14,9,14,
         14,18,14,18,
         9,14,9,14,
         14,18,14,18,
      };
      const static int flIg[]={
         0,0,1,0,
         0,0,1,1,
         1,1,1,1,
         0,1,1,1,
      };
      const static int flIgB[]={
         0,0,0,1,
         0,0,1,1,
         0,1,1,1,
         1,1,1,1,
      };
      const static int flIgN[]={
         1,4,1,4,
         4,16,4,16,
         1,4,1,4,
         4,16,4,16,
      };

      for(i=0;i<64;i++){
         int tm=t_lim_mult[i&15];
         //if(tm==_Q_C)tm=_Q_B*3;
         tabSK_Y[i]=((tab_y[i+128]*(tm+iAdd1+(b && flIgB[i&15]?64:0)))>>7);
         
         tabSK_UV[i]=((tab_uv[i+128]*(tm+iAdd1+(flIgB[i&15]?100:0)))>>7)+flIgM[i&15];

         //if(tabSK_Y[i]<(tm>>4))tabSK_Y[i]=(tm>>4);
         if(tabSK_Y[i]<flIgM[i&15]+iAdd1)tabSK_Y[i]=flIgM[i&15]+iAdd1;
         if(flIg[i&15])tabSK_UV[i]+=((tab_uv[i+128]*3)>>2);
         if(b)tabSK_UV[i]+=((tab_uv[i+128]*5)>>3)*flIgB[i&15];
         //if(b)tabSK_Y[i]+=((tab_y[i+128]*3)>>3)*flIgB[i&15];
         
         if(b && flIgB[i&15]==0)tabSK_Y[i]=((tab_y[i+128]*6)>>3)+12;//ja b=q+6
         
         if(flIgN[i&15]==1){
            //tabSK_Y[i]=max(((tab_y[129]/4)),((tab_y[i+128]*3)>>2)+8);
            //--
            tabSK_Y[i]=max(((tab_y[128+5]/5)+((tab_y[i+128])>>1)+4),((tab_y[i+128]*3)>>2)+8);
            //tabSK_Y[i]=max(((tab_y[129]*5))-(tab_y[i+128]>>2),((tab_y[i+128]*3)>>2)+8);
            if(!b)tabSK_UV[i]=max(((tab_uv[129]/4)+8),((tab_uv[i+128]*3)>>2)+8);
         }else 
          if(flIgN[i&15]==16){
//            tabSK_Y[i]=max((((tab_y[129]*4)>>1)+8),((tab_y[i+128]*3)>>2)+8);
  //          if(!b)tabSK_UV[i]=max((((tab_uv[129]*4)>>1)+8),((tab_uv[i+128]*3)>>2)+8);
            //--
             tabSK_Y[i]=max(((tab_y[128]*5))-(tab_y[128]>>1),((tab_y[i+128]*3)>>2)+8);
             //tabSK_Y[i]=max(((tab_y[128]*16)>>1),((tab_y[i+128]*3)>>2)+8);
            if(!b)tabSK_UV[i]=max((((tab_uv[129]*4)>>1)+8),((tab_uv[i+128]*3)>>2)+8);
          }
          //3220 49
         //zemaas qval vajag if(!b)tabSK_Y[i]=((tab_y[i+128]*3+8)>>2);


         
         if(tabSK_Y[i]<flIgM[i&15]+iAdd1)tabSK_Y[i]=flIgM[i&15]+iAdd1;
         if(tabSK_Y[i]>((tab_y[i+128]*7)>>3)+flIgM[i&15]+iAdd1)tabSK_Y[i]=((tab_y[i+128]*7)>>3)+flIgM[i&15]+iAdd1;
         //if(!b)tabSK_Y[i]=((tab_y[i+128]*6)>>3)+8;
//         if(tabSK_UV[i]<(tm>>2)+iAdd1+flIgM[i&15])tabSK_UV[i]=(tm>>2)+iAdd1+flIgM[i&15];
         //if(flIg_sh[i&15] && tabSK_UV[i]<((tabSK_UV[0]*flIg_sh[i&15])>>2))tabSK_UV[i]=(tabSK_UV[0]*flIg_sh[i&15])>>2;
         //tabSK_Y[i]=(tab_y[i+128]*3)>>2;
         
      }
#undef _Q_A
#undef _Q_B
#undef _Q_C
   }
   template<int iPic>
   inline int QTestN(DCT_TYPE *dct,  const int i_IsB, const int k, const int iCnt=64){
      int i;
      const int *tab=(const int *)(k?&tabSK_UV[0]:&tabSK_Y[0]);
      //const int *tabQ=(const int *)(k?&tab_uv[128]:&tab_y[128]);
      int s=0,v,si;
      for(i=0;i<iCnt;i++)
      {
         v=dct[i];
         si=v>>31;
         v=(v + si) ^ si;
         //if(v<0)v=-v;
         if(v>tab[i])return 2;
      }
      return 0;
   }
   //int iQTestLim;
   template<int iPic>
   static int QTestK(DCT_TYPE *dct, const  int *tab, const int i_IsB){
      int i;
      for(i=0;i<64;i++)
      {
         if(nti8x8_4x4[i]){continue;}
         const int iLim=iPic?((tab[i]*6)>>4):tab[i];
         int v=dct[i];
         if(v<0)v=-v;
         
         if(iLim<v && v>4)return 2;
      }
      return 0;
   }   

   static inline int QFastLPic(DCT_TYPE *p, DCT_TYPE *dct, const  int *tab){
      int sum=0;
      const int *tabSh12=tab+64;
      int i,v,b;
      //??const int bias=(tab[0]>>2)+1;
#if 0
      const int bi[]={
         /*
         tab[0]/3,  tab[1]/4,  tab[2]/4, tab[3]/4,
         tab[4]/4,  tab[5]/4,  tab[6]/4,   tab[7]/4,
         tab[8]/4,  tab[9]/4,   tab[10]/4,  tab[11]/4,
         tab[12]/4 , tab[13]/4,   tab[14]/4,tab[15]/4,
         */
         /*
         tab[0]/4,  tab[1]/3,  tab[2]/4, tab[3]/3,
         tab[4]/3,  tab[5]/4,  tab[6]/3,   tab[7]/4,
         tab[8]/4,  tab[9]/3,   tab[10]/4,  tab[11]/3,
         tab[12]/3 , tab[13]/4,   tab[14]/3,tab[15]/4,
         */
         tab[0]/3,  tab[1]/3,  tab[2]/3, tab[3]/3,
         tab[4]/3,  tab[5]/3,  tab[6]/3,   tab[7]/4,
         tab[8]/3,  tab[9]/3,   tab[10]/3,  tab[11]/3,
         tab[12]/3 , tab[13]/4,   tab[14]/3,tab[15]/4,
      };
#endif
      for(i=0;i<64;i++){
         v=dct[i];
         b=tab[i]>>2;//bi[i&15];
//         if(!v){p[i]=0;continue;}
         if(v<0){
            v=((b-v)*tabSh12[i])>>15;
            //v=(((tab[i]>>1)-v)*tabSh12[i])>>15;
            p[i]=-v;
         }
         else {
            //v=(((tab[i]>>1)+v)*tabSh12[i])>>15;
            v=((v+b)*tabSh12[i])>>15;
            p[i]=v;
         }
         sum+=v;      
      }
      return sum;

   }
   //t_guant_fnc
   //t_guant_fnc *fnc,
   template<t_guant_fnc fnc>
   inline int QFnc( DCT_TYPE *p, DCT_TYPE *dct,const  int *tab,const  int cnt){
      int sum=0,v,i;
      const int *tabSh12=tab+64;
      for(i=0;i<cnt;i++){
         v=dct[i];
#if 1
         const int _s=v>>15;
         const int av=(v+_s)^_s;
         v=fnc((unsigned int)av,(unsigned int)tab[i],(const unsigned int)tabSh12[i]);
         sum+=v;
         p[i]=(v+_s)^_s;
#else
         if(v<0){
            v=-v;
            //--if(v>tab[i])sumok[i>>4]++;
            v=fnc(v,tab[i],tabSh12[i]);
            p[i]=-v;
         }
         else {
            //--if(v>tab[i])sumok[i>>4]++;
            v=fnc(v,tab[i],tabSh12[i]);
            p[i]=v;
         }
         sum+=v;
#endif

      }
      return sum;

   }
   template<int iPic>
   inline int QFast(DCT_TYPE *p, DCT_TYPE *dct, const  int *tab,const  int cnt, int i_IsB, int k, int iDecim){
      int sum=0;
      int i,v,t;
      //int iPic=1;
      //const int tqlim[]={4,4,8,8,1,1};
      const int *tabSh12=tab+64;
      //const int iQLIM=8+tab[0]+((tab[2] + tab[1])>>2);//+iIsB*2;
      //const int iQLIM=k==0?((tab[0]+(((tab[9]*2+tab[15]+2)>>2))+1)>>1):((tab[0]+tab[1]+4)>>1);//+iIsB*2;
      //int iQLIM=k?((tab[1]+tab[9]+tab[15]+1)>>1):(tab[15]);if(i_IsB)iQLIM+=2;
//      int th;
     // k=1;
      //(iLowQval==0 || iIsRefFrame? &t4x4P[0]:&t4x4PL[0]);
/*
      const int skipt[]={
         3,3,0,0,    3,3,0,0, 0,0,0,0, 0,0,0,0,
         3,3,0,0,    3,3,0,0, 0,0,0,0, 0,0,0,0,
         3,3,0,0,    3,3,0,0, 0,0,0,0, 0,0,0,0,
         3,3,0,0,    3,3,0,0, 0,0,0,0, 0,0,0,0,
      };
      int sksum[4]={0,0,0,0};
*/
      
//      int iSendIt[4]={0,0,0,0};
      //int sums[4]={0,0,0,0};
      //int sumok[4]={0,0,0,0};

      /*
      //const int qAdd=(tab[0]>>1);
      const int mult[]={
         //64,63,53,43, 63,53,43,43,  53,43,43,43,  43,43,43,43,//29577,347
         //64,63,53,43,   63,53,43,32,  53,43,32,25,  43,32,25,21, //29477,342

//         64,58,53,43, 58,53,43,43,  53,43,43,43,  43,43,43,43,//29562,345
         64,58,58,53,    58,58,53,50,    58,53,50,46,      53,50,46,42,
         64,58,58,53,    58,58,53,50,    58,53,50,46,      53,50,46,42,
         64,58,58,53,    58,58,53,50,    58,53,50,46,      53,50,46,42,
         64,58,58,53,    58,58,53,50,    58,53,50,46,      53,50,46,42,
         
  //64,58,53,43, 58,53,43,40,  53,43,40,36,  43,40,36,32,
      };
      */
 //           if(v<(tab[i]*3)>>2){p[i]=0;continue;}
   //         v=(v+(tab[i]>>2))/tab[i];

/*
           if( v<((t*25)>>4)){\
             if(v>=((t*11)>>4) && t8x8[i])v=1;\
             else v=0;\
           }else {if(v<t*3)v+=((t>>1));else v+=((t)>>2);v=(v*tabSh12[i])>>15;}\

*/
      //
      //const int bias=tab[0]>>2;
      //def bias=t div 5
      //405 506
      //t>>2
      
#define QVANT_X_2 \
         if(iPic==2){\
           t=tab[i];\
           v=Q_OneD2(v,t,tabSh12[i],t>>2);\
         }\
         else if(iPic) v=Q_One(v,tab[i],tabSh12[i]);else{\
            v=(v*tabSh12[i])>>15;\
         }

      if(!k){
         for(i=0;i<cnt;i++){
/*
            v=dct[i];
            if(v<0){
               v=-v;
               //--if(v>tab[i])sumok[i>>4]++;
               QVANT_X_2
               p[i]=-v;
            }
            else {
               //--if(v>tab[i])sumok[i>>4]++;
               QVANT_X_2
               p[i]=v;
            }
            */
            v=dct[i];
            int _s=v>>31;
            v=(v+_s)^_s;
            QVANT_X_2
            p[i]=(v+_s)^_s;

            sum|=v;
           
//            sums[i>>4]+=v;
          }
         //--for(i=0;i<4;i++){if(sums[i] && !sumok[i]){memset(&p[i*16],0,sizeof(DCT_TYPE));sums[i]=0;}}    sum=sums[0]+sums[1]+sums[2]+sums[3];
      }
      else{
      //   const int *t4x4=i_IsB?(k?&t4x4K[0]:&t4x4B[0]):(k?&t4x4K[0]:&t4x4P[0]);

         for(i=0;i<cnt;i++){
           // if(!t4x4[i]){p[i]=0;  continue;   }
            v=dct[i];
            int _s=v>>31;
            v=(v+_s)^_s;
            QVANT_X_2
            p[i]=(v+_s)^_s;
/*
            if(v<0){
               v=-v;
               //v=(v*tabSh12[i])>>15;
               p[i]=-v;
            }
            else {
               QVANT_X_2
               //v=(v*tabSh12[i])>>15;
               p[i]=v;
            }
            */
           // if(t4x4[i])
               sum|=v;
          }
      }
      //if(k && sum>1)return sum;
      //1016KB 124
     // if(k && (sumsm[0]|sumsm[1]|sumsm[2]|sumsm[3])<2)return 0;
      //if((sums[0]|sums[1]|sums[2]|sums[3])<2)return sum;
      return sum;
   }
   template<int iPic>
   inline int Q_NEW(DCT_TYPE *p, DCT_TYPE *dct, const  int *tab, int k, int i_sIsB){
      
      int sum=0;
      int iSendIt=0;
      int i;
      int v;
//      int t;
      const int *tabSh12=tab+64;
      const int *t8x8=k?(i_sIsB?&ti6[0]:(iPic?&ti15[0]:&ti10[0])):(i_sIsB?&ti10[0]:&ti8x8_d[0]);
      const int bias =tab[0]/2;
//(((1<<15)*12)>>5)

      for(i=0;i<TVAL_DCT_SZ;i++){
         v=dct[i];
         

//v+=((t*43)>>7);
         //
//         if(v<t+(t8x8[i]?0:(t>>2))){p[i]=0;continue;}
#define QVANT_X_UVz \
         if(iPic){\
            t=tab[i];\
           if( v<((t*25)>>4)){\
             if(v>=((t*72)>>7) && t8x8[i])v=1;\
             else v=v*3>t*4;\
           }else {if(v<t*3)v+=((t/3));else v+=((t)>>2);v=(v*tabSh12[i])>>15;}\
         }\
         else{\
            v=(v*tabSh12[i])>>15;\
         }


#define QsVANT_X_UV \
         if(iPic){\
            if(nti8x8_4x4[i]){v=((v)*tabSh12[i])>>14;if(v){v--;v>>=1;}}\
            else v=((v+(tab[i]>>1))*tabSh12[i])>>15;\
         }\
         else{\
            v=(v*tabSh12[i])>>15;\
         }
#define QVANT_X_UV \
         if(iPic){\
            if(nti8x8_4x4[i]){v=((v)*tabSh12[i])>>15;}\
            else v=((v+(tab[i]>>1))*tabSh12[i])>>15;\
         }\
         else{\
            v=(v*tabSh12[i])>>15;\
         }
         //Q_OneD2 

         if(v>0){
            QVANT_X_UV
            p[i]=v;
         }
         else {
            v=-v;
            QVANT_X_UV
            p[i]=-v;
         }
         if(v){
            
            if(v>1){
               if(!k)iSendIt+=9;
               else if(t8x8[i])iSendIt+=9;
            }else iSendIt+=t8x8[i];
            sum+=v;
         }
      }
      //debugss("sum",k*100+iSendIt,sum);
   

      return iSendIt;//&&(iPic ||  sum>4 || (sum>2 && iSendIt) || (sum>2-iPic && !k) || (iSendIt && sum>3-iPic*2) || iSendIt>3-iPic)?(sum):0;
   }
   template<int iPic, int iFirstCoefOnly>
   inline int Q(DCT_TYPE *p, DCT_TYPE *dct, const  int *tab, int k, int &iCoefsOut, int &iMaxCoef, int iIsRefFrame, int i_sIsB, const int iIs4x4=0){
      int sum=0;
      int i,v;
      int vb;
      int t;
      int th;
      iCoefsOut=0;
      iMaxCoef=0;
      //const int iPic=0;


      const int *tabSh12=tab+64;
      const int *t4x4=i_sIsB || k?&t4x4B[0]:&t4x4P[0];//(iLowQval==0 || iIsRefFrame? &t4x4P[0]:&t4x4PL[0]);
const int iIsLossLess=iFirstCoefOnly && tab[128]==1;
      //const int iQ4x4Sum=((i_sIsB?4:(3)));
      int iSendIt[16]={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,};

      if(k && iIs4x4==0){
         if(!iLowQval || iIsRefFrame || iPic){
          if(!iSkipUVFilter)  for(i=0;i<TVAL_DCT_SZ;i++){if(!ti10[i])dct[i]=0;}
         }
         else{
            if(!iSkipUVFilter) for(i=0;i<TVAL_DCT_SZ;i++){if(!ti6[i])dct[i]=0;}
         }
         //for(i=iMaxDct;i<TVAL_DCT_SZ;i++)q_dct[ZIG_ZAG_TAB[i]]=0;
      }
      else{
        // if(iPic){for(i=0;i<TVAL_DCT_SZ;i++){if(!ti10[i])q_dct[i]=0;}}
      }
      const int tqlim[]={4,4,8,8,1,1};
      const int iQLIM=iFirstCoefOnly?(2+iIsB):(tqlim[iIs4x4]+tab[0]+((tab[2] + tab[1])>>2)+iIsB*2-iIsRefFrame);;//((tab[iFirstCoefOnly?128:0]*3)>>1);
      
      
      if(iFirstCoefOnly){
         t=tab[128];
         th=(t*22)>>7;
      }
      int sum_x[16]={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,};

      for(i=0;i<TVAL_DCT_SZ;i++){

//        if(iQRem && !iIsRefFrame && (i!=0 && i!=8 && i!=1))q_dct[i]=0;

         v=dct[i];
         if(iIsLossLess && v){
            vb=v;
            if(vb<0)vb=-vb;
            iMaxCoef=max(vb,iMaxCoef);
            iCoefsOut++;
            sum+=vb;
            p[i]=v;
            iSendIt[iIs4x4==0?0:(i>>4)]++;
            continue;
         }
         if(!v){p[i]=0;continue;}
    
         if(!iFirstCoefOnly){
            t=tab[i];
            //th=(t*25)>>7;
            if(iPic){th=(t*43)>>7;}
            
         }

         //if(i==0)
         //th=t;//(t>>2);
         
         //th=(t>>2)|1;
          //th=t;
//            if(!iQRem)v-=th;else v+=th;
//v*=2;
//pic==0 th=((t*25)>>7);
#define QVANT_X \
         vb=v;\
         if(iPic){\
            if(iIs4x4==0 && i==0) v=(v*tabSh12[0]+(1<<13))>>14;\
            else {v+=th;v=(v*tabSh12[i])>>15;}\
         }\
         else{\
            if(v<t+(t>>2)){p[i]=0;iMaxCoef=max(vb,iMaxCoef);continue;}\
            if(iFirstCoefOnly)v=(v*tabSh12[65])>>15;else v=(v*tabSh12[i])>>15;\
         }
#define aaQVANT_X \
         vb=v;\
         if(iPic){\
            if(iIs4x4==0 && i==0) v=(v*tabSh12[0]+(1<<13))>>14;\
            else {v+=th;v=(v*tabSh12[i])>>15;}\
         }\
         else{\
            v+=th;\
            if(v<iQLIM){p[i]=0;iMaxCoef=max(vb,iMaxCoef);continue;}\
            if(iFirstCoefOnly)v=(v*tabSh12[65])>>15;else v=(v*tabSh12[i])>>15;\
         }


//v=(v*tabSh12[iFirstCoefOnly?0:i])>>15; arm copliatoram nepatika
          //if((iPic && v<t) || (!iPic && v<((t*3)>>1))){p[i]=0;iMaxCoef=max(vb,iMaxCoef);continue;}
    
            //v=(v*2+(t>>1))/t;
//#define VAL_M 510
#define VAL_M 2040

         if(v>0){
            QVANT_X
            p[i]=v;

         }
         else {
            v=-v;
            QVANT_X
            p[i]=-v;
         }
         iMaxCoef=max(vb,iMaxCoef);

         if(v){
            iCoefsOut++;
            
     //       sum2=max(v,sum2);
            if(!iPic){
               if(iIs4x4==0){
                  //if(tig[i])iSendIt[0]+=v;
                  iSendIt[0]+=ti8x8_d[i];
               }
               else{
                  if(iIs4x4==4)
                  {
                     const int bt2x2[]={0,0,0,1};
                     if(v>bt2x2[i&3])iSendIt[i>>2]+=v;
                     
                     sum_x[i>>2]=max(v,sum_x[i>>2]);
                  }
                  else {
                    // if(v>=t4x4[i] && vb>4)iSendIt[i>>4]+=v;
                     iSendIt[i>>4]+=t4x4[i];
                     sum_x[i>>4]=max(v,sum_x[i>>4]);
                  }
               }
            }
            sum=max(v,sum);
           // if(iQRem || (vb>8 && (vb>tab_xtwave[i]+12 || (vb>28 && v>1))))
            
         }
         //else if(iSkipDct && v>1 && vb>8)sum|=v;
         
         
      }
      //return sum;
      //
      if(iIsLossLess  || iPic || !sum || iSkipRestore==2 ||
      (iIs4x4==0 && !k && (p[0] ||  (sum>4+i_sIsB*4 && !k)|| (iIsRefFrame && sum>1))))return sum;
      if(iIsRefFrame && (!k || sum>1))return sum;
      if(sum>1+iIsB || p[1] || p[8] || iSendIt[0])return sum;

      
      if(iIs4x4==0){
         int lim=i_sIsB?3:1;
         if((iSendIt[0] ||(!iIsB && (p[1] || p[8])))&& (sum>lim || iMaxCoef>lim))return sum;
         //if(iIsRefFrame)lim--;
         //if(k)lim+=2;
         int iWasSum=sum;
         int iIsBigDC=p[0]<-1 || p[0]>0;
         if(!iIsBigDC && (sum >= lim || k)){
            
            if(k &&  ((iSendIt[0]<5+iIsB-iIsRefFrame)||  sum<3)){sum=0;iCoefsOut=0;}
            //i_sIsB?3:2;//def ir 2 bet ja x2 tad 3
            else if(iMaxCoef<4){sum=0;iCoefsOut=0;}else 
            //if(iPic==0 && iMaxCoef<6 && iCoefsOut<3 && !p[1] && !p[8]){p[0]=0;sum=0;iCoefsOut=0;}else 
            if(iSendIt[0]<4+iIsB-iIsRefFrame){sum=0;iCoefsOut=0;}
            else if ( ((p[1] || p[8]) && k==0) || (p[0] > 0+i_sIsB) || (p[0] < -1-i_sIsB)){}else {{p[0]=0;sum=0;iCoefsOut=0;}}
         
         
         
            if(iCoefsOut==1 && p[0] && iMaxCoef<8){;sum=0;iCoefsOut=0;}//ja qval>80 tad sum<3

         }
         if(i_sIsB && (!p[0] || (k && p[0]<2+i_sIsB && p[0]>-1-i_sIsB)) && iMaxCoef<60){sum=0;iCoefsOut=0;}
         if(sum==0 && iWasSum){memset(p,0,sizeof(DCT_TYPE)*TVAL_DCT_SZ);iCoefsOut=0;}
      }
      else if(sum){
         int iClear=0;
         int aa;
         if((sum<2 && iMaxCoef<20) || iMaxCoef<6){
            aa=4;
            sum=0;
            iClear=1;
            
         }
         else{
            if(iIs4x4==4){
               aa=16;
               for(int j=0;j<16;j++){
                  if(iSendIt[j]>iIsB /*>1 || (p[j<<2] && (j==0 ||((j&3)  && iSendIt[j-1]>0)||((j>3)  && iSendIt[j-4]>0)))*/)continue;
//                  if(iSendIt[j])continue;
                  //memset(p+j*4,0,sizeof(DCT_TYPE)*4);
                  *(int*)&p[j*4]=0;
                  *(int*)&p[j*4+2]=0;
                  iSendIt[j]=0;
                  aa--;
               }
               if(aa==1)iClear=1;

            }else{
               aa=4;
               for(int j=0;j<4;j++){
                  //if(sum_x[j]>1 || iSendIt[j]>iQ4x4Sum || (p[j*16] && ( iSendIt[j]>2)))continue;
                  if(iSendIt[j]>3 || p[j<<4]<-2 || p[j<<4]>1 /*|| (sum_x[j<<4]>1 || iSendIt[j])*/)continue;
                  //if(iSendIt[j])continue;
                  memset(p+j*16,0,sizeof(DCT_TYPE)<<4);
                  aa--;

               }
               //if(i_sIsB && !p[0] && !p[16] && !p[32] && !p[48] && iMaxCoef<80){sum=0;iClear+=iCoefsOut;iCoefsOut=0;}
            }
         }
         
         if(aa==0){sum=0;iCoefsOut=0;iClear=0;}
         if(iClear){memset(p,0,sizeof(DCT_TYPE)*TVAL_DCT_SZ);iCoefsOut=0;sum=0;}
         

      }
      //else if(i_sIsB && sum)

 //     if(iCoefsOut==1 && p[0]<0)p[0]++;
      
      //if(!iQRem && sum)sum--;
 
      //if(sum<0)sum=0;

  

      //if(sum<0)sum=0;
      return sum;//return sum>1?sum:0;
   }
   template<int iPic, int iFirstCoefOnly>
   inline int _Q_o(DCT_TYPE *p, DCT_TYPE *q_dct, const  int *tab, int k, int &iCoefsOut, int &iMaxCoef, int iIsRefFrame, int i_sIsB, int iIs4x4=0){
      int sum=0;
#if 0
      int i,v;
      int vb;
    //  const int iPic=0;

  
      
      iCoefsOut=0;
      iMaxCoef=0;
      //int h=(4+tab[0]+tab[1]+tab[8]+tab[16])>>2;
      int t;
      int th;
      //int thm;
      //if(!iQRem)iQRem=iIsKey;
      //k=1;
      //if(iQRem)k=0;
      //int mk=-k;
     // t=16;
      iMaxCoef=0;
     // if(iIs4x4)tab+=256;
      const int *tabSh12=tab+64;
      //int maxv[]={61,253};
      //int maxv[]={253,253};
      //int maxv[]={510,510};
   /*   
   const int tab_xtwave[]={
      4,1,2,4,8,8,8,8,
      1,2,2,3,3,3,4,8,
      2,2,3,3,3,4,4,8,
      4,3,3,3,4,4,8,16,
      8,3,3,4,4,8,16,16,
      8,3,4,4,8,16,16,24,
      8,4,4,8,16,16,24,24,
      8,8,8,16,16,24,24,24,
   };
   */
   const int tab_twavex[]={
39,36,32,32,28,28,28,28,
36,36,32,32,28,28,28,28,
32,32,32,32,28,28,28,28,
32,32,32,32,28,28,28,28,
28,28, 28,28, 8, 8, 8, 8,
28,28,28,28, 8, 8, 8, 8,
28,28,28,28, 8, 8,8, 8,
28,28,28,28, 8, 8, 8, 8,
   };
    //  int *tab_xtwave=(int*)&ctab_xtwave[k?16:0];
      //int  sum2=0;
      //int iMult=iIsB?4:3;
      //int sums[4]={0,0,0,0};
#define MIN_DC_V 2
      //th=iQRem?0:1;
      const int iShAdd=0;//(1<<13);//-(1<<12);
      const int t4x4P[]={
        //-- 2,0,0,3,   0,0,3,3,   0,3,30,30,  3,3,30,30,
         //---2,0,1,3,   0,0,3,3,   1,3,30,30,  3,3,30,30,
//         1,0,1,8, 0,1,8,10, 1,8,40,40,  8,10,40,40,
         //----1,0,2,8, 0,2,8,10, 2,8,40,40,  8,10,40,40,
         //-119121x102 1,0,2,4, 0,2,4,6, 2,4,40,40,  4,6,40,40,
         1,0,1,4,  0,1,4,4,  1,4,8,8,  4,4,8,8,
         1,0,1,4,  0,1,4,4,  1,4,8,8,  4,4,8,8,
         1,0,1,4,  0,1,4,4,  1,4,8,8,  4,4,8,8,
         1,0,1,4,  0,1,4,4,  1,4,8,8,  4,4,8,8,
//----         1,0,1,6, 0,1,6,10, 1,6,40,40,  6,10,40,40,
//ok         2,0,1,4,     0,0,4,2,   1,4,30,30,  4,2,30,30,
//         1,0,0,2,   0,0,2,3,   0,2,20,20,  2,3,20,20,
      };
      const int t4x4B[]={
         1,0,4,20, 1,4,20,80, 4,20,80,80, 20,80,80,80,
         1,0,4,20, 1,4,20,80, 4,20,80,80, 20,80,80,80,
         1,0,4,20, 1,4,20,80, 4,20,80,80, 20,80,80,80,
         1,0,4,20, 1,4,20,80, 4,20,80,80, 20,80,80,80,
      };
      const int *t4x4=i_sIsB?&t4x4B[0]:&t4x4P[0];
      const int ti6[]={
         1,1,1,0,0,0,0,0,        1,1,0,0,0,0,0,0,        1,0,0,0,0,0,0,0,        0,0,0,0,0,0,0,0,
         0,0,0,0,0,0,0,0,        0,0,0,0,0,0,0,0,        0,0,0,0,0,0,0,0,        0,0,0,0,0,0,0,0
      };
      const int ti10[]={
         1,1,1,1,0,0,0,0,        1,1,1,0,0,0,0,0,        1,1,0,0,0,0,0,0,        1,0,0,0,0,0,0,0,
         0,0,0,0,0,0,0,0,        0,0,0,0,0,0,0,0,        0,0,0,0,0,0,0,0,        0,0,0,0,0,0,0,0
      };
      const int ti15[]={
         1,1,1,1,1,0,0,0,        1,1,1,1,0,0,0,0,        1,1,1,0,0,0,0,0,        1,1,0,0,0,0,0,0,
         1,0,0,0,0,0,0,0,        0,0,0,0,0,0,0,0,        0,0,0,0,0,0,0,0,        0,0,0,0,0,0,0,0
      };
      const int ti21[]={
         1,1,1,1,1,1,0,0,        1,1,1,1,1,1,0,0,        1,1,1,1,1,0,0,0,        1,1,1,1,1,0,0,0,
         1,1,1,1,0,0,0,0,        1,1,0,0,0,0,0,0,        0,0,0,0,0,0,0,0,        0,0,0,0,0,0,0,0
      };      
      const int ti36[]={
         1,1,1,1,1,1,1,0,        1,1,1,1,1,1,1,0,        1,1,1,1,1,1,0,0,        1,1,1,1,1,1,0,0,
         1,1,1,1,1,0,0,0,        1,1,1,1,0,0,0,0,        1,1,0,0,0,0,0,0,        0,0,0,0,0,0,0,0
      };
      const int ti64[]={
         1,1,1,1,1,1,1,1,        1,1,1,1,1,1,1,1,        1,1,1,1,1,1,1,1,        1,1,1,1,1,1,1,1,
         1,1,1,1,1,1,1,1,        1,1,1,1,1,1,1,1,        1,1,1,1,1,1,1,1,        1,1,1,1,1,1,1,1
      };
      const int ti_cb[]={
         1,1,1,0,0,0,0,0,        1,1,1,0,0,0,0,0,        1,1,0,0,0,0,0,0,        0,0,0,0,0,0,0,0,
         0,0,0,0,0,0,0,0,        0,0,0,0,0,0,0,0,        0,0,0,0,0,0,0,0,        0,0,0,0,0,0,0,0
      };
      const int ti_cbk[]={
         1,1,1,1,0,0,0,0,        1,1,1,1,0,0,0,0,        1,1,1,0,0,0,0,0,        1,1,0,0,0,0,0,0,
         0,0,0,0,0,0,0,0,        0,0,0,0,0,0,0,0,        0,0,0,0,0,0,0,0,        0,0,0,0,0,0,0,0
      };

      //3
      //th=0;//tab[0]>>1;
      int iMaxDct=k?15:64;
      if(iIsRefFrame==0 && !iPic)iMaxDct=k?(i_sIsB?6:10):(i_sIsB?21:64);

      //iQuantIsConst
      if(CONST_QUANT)iMaxDct=64;
      //iMaxDct=k?21:64;
     // iMaxDct=64;
      int *tig=(int*)&ti64[0];
      if(k){
         tig=iPic?(int*)&ti_cbk[0]:(int*)&ti_cb[0];
      }
      else {
         switch(iMaxDct){
            case 6:tig=(int*)&ti6[0];break;
            case 10:tig=(int*)&ti10[0];break;
            case 15:tig=(int*)&ti15[0];break;
            case 21:tig=(int*)&ti21[0];break;
            case 36:tig=(int*)&ti36[0];break;


         }
      }
      const int iIsLossLess=0;
     // const int iQ4x4Sum=(i_sIsB || (iLowQval && iIsRefFrame==0)?3:2);//-iIsRefFrame;
      const int iQ4x4Sum=((i_sIsB?4:(3-iIsRefFrame)));

     
      // iMaxDct=21;
      //
      int iSendIt[16]={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,};

      if(k){
         if(!iLowQval || iIsRefFrame || iPic){
            for(i=0;i<TVAL_DCT_SZ;i++){if(!ti10[i])q_dct[i]=0;}
         }
         else{
            for(i=0;i<TVAL_DCT_SZ;i++){if(!ti6[i])q_dct[i]=0;}
         }
         //for(i=iMaxDct;i<TVAL_DCT_SZ;i++)q_dct[ZIG_ZAG_TAB[i]]=0;
      }
      else{
        // if(iPic){for(i=0;i<TVAL_DCT_SZ;i++){if(!ti10[i])q_dct[i]=0;}}
      }
      if(iFirstCoefOnly){
         t=tab[128];
         th=(t*22)>>7;
      }

      for(i=0;i<TVAL_DCT_SZ;i++){

//        if(iQRem && !iIsRefFrame && (i!=0 && i!=8 && i!=1))q_dct[i]=0;

         v=q_dct[i];
         if(iIsLossLess && v){
            vb=v;
            if(vb<0)vb=-vb;
            iMaxCoef=max(vb,iMaxCoef);
            iCoefsOut++;
            sum+=vb;
            p[i]=v;
            iSendIt[iIs4x4==0?0:(i>>4)]++;
            continue;
         }
         if(!v){p[i]=0;continue;}
    
         if(!iFirstCoefOnly){
            t=tab[i];
            //th=(t*25)>>7;
            if(iPic){th=(t*43)>>7;}
            else th=((t*22)>>7);//- 119105 840KB
            
         }

         //if(i==0)
         //th=t;//(t>>2);
         
         //th=(t>>2)|1;
          //th=t;
//            if(!iQRem)v-=th;else v+=th;
//v*=2;
#ifndef QVANT_X
#define QVANT_X \
            vb=v;\
            if(!iPic)v-=th;else v+=th;\
            if(v<t){p[i]=0;iMaxCoef=max(vb,iMaxCoef);continue;}\
            if(iFirstCoefOnly)v=(v*tabSh12[65])>>15;else v=(v*tabSh12[i])>>15;

//v=(v*tabSh12[iFirstCoefOnly?0:i])>>15; arm copliatoram nepatika
    
            //v=(v*2+(t>>1))/t;
#define VAL_M 510
#endif
         if(v>0){
            QVANT_X
            if(v>VAL_M)p[i]=VAL_M;else p[i]=v;

         }
         else {
            v=-v;
            QVANT_X
            if(v>VAL_M)p[i]=-VAL_M;else p[i]=-v;
         }
         iMaxCoef=max(vb,iMaxCoef);

         if(v){
            iCoefsOut++;
            
     //       sum2=max(v,sum2);
            if(!iPic){
               if(iIs4x4==0){
                  if(tig[i])iSendIt[0]+=v;
               }
               else{
                  if(iIs4x4==4)
                  {
                     const int bt2x2[]={0,1,1,8};
                     if(v>bt2x2[i&3])iSendIt[i>>2]+=v;
                  }
                  else {
                     if(v>=t4x4[i] && vb>4)iSendIt[i>>4]+=v;
                  }
               }
            }
           // if(iQRem || (vb>8 && (vb>tab_xtwave[i]+12 || (vb>28 && v>1))))
            sum=max(v,sum);
         }
         //else if(iSkipDct && v>1 && vb>8)sum|=v;
         
         
      }
    //  return sum;
      if(iIsLossLess || iPic || !sum)return sum;
      //if (iQRem || (sum >= lim) || (p[1] != 0) || (p[8] != 0) || (p[0] > 1) || (p[0] < -1)){}else sum=0;

      
      if(iIs4x4==0){
         int lim=i_sIsB?3:2;
         if(k)lim++;
         int iWasSum=sum;
         if(k &&  ((iSendIt[0]<(5-iIsRefFrame*2) && !p[0])||  sum<3)){sum=0;iCoefsOut=0;}
         //i_sIsB?3:2;//def ir 2 bet ja x2 tad 3
         else if(iMaxCoef<4){sum=0;iCoefsOut=0;}else 
         //if(iPic==0 && iMaxCoef<6 && iCoefsOut<3 && !p[1] && !p[8]){p[0]=0;sum=0;iCoefsOut=0;}else 
         if(iSendIt[0]<2){sum=0;iCoefsOut=0;p[0]=0;}
         else if ((sum >= lim) || ((p[1] || p[8]) && k==0) || (p[0] > 0) || (p[0] < -1)){}else {{p[0]=0;sum=0;iCoefsOut=0;}}
         
         
         
         
         if(iCoefsOut==1 && p[0] && iMaxCoef<10){p[0]=0;sum=0;iCoefsOut=0;}//ja qval>80 tad sum<3

         if(i_sIsB && (!p[0] || (k && p[0]<2 && p[0]>-2)) && iMaxCoef<60){sum=0;iCoefsOut=0;}
         if(sum==0 && iWasSum){memset(p,0,sizeof(DCT_TYPE)*TVAL_DCT_SZ);iCoefsOut=0;}
      }
      else if(sum){
         int iClear=0;
         int aa;
         if((sum<2 && iMaxCoef<16) || iMaxCoef<4){
            aa=4;
            sum=0;
            iClear=1;
            
         }
         else{
            if(iIs4x4==4){
               aa=16;
               for(int j=0;j<16;j++){
                  int iIsBigDC=p[j<<2]<-1 || p[j<<2]>1;
                  if((!iIsB || iIsBigDC) && ((iIsBigDC && iSendIt[j]>2)|| iSendIt[j]>4 || ((iIsBigDC || iSendIt[j]>2) && (j==0 ||(j>0  && iSendIt[j-1]>2)||(j>3  && iSendIt[j-4]>2)))))continue;
                  memset(p+j*4,0,sizeof(DCT_TYPE)*4);
                  iSendIt[j]=0;
                  aa--;
               }
               if(aa==1)iClear=1;

            }else{
               aa=4;
               for(int j=0;j<4;j++){
                  if(iSendIt[j]>iQ4x4Sum || (p[j*16] && (p[j*16]<-1 || p[j*16]>1 || iSendIt[j]>2)))continue;
                  //if(iSendIt[j])continue;
                  memset(p+j*16,0,sizeof(DCT_TYPE)*16);
                  aa--;

               }
               //if(i_sIsB && !p[0] && !p[16] && !p[32] && !p[48] && iMaxCoef<80){sum=0;iClear+=iCoefsOut;iCoefsOut=0;}
            }
         }
         
         if(aa==0){sum=0;iCoefsOut=0;iClear=0;}
         if(iClear){memset(p,0,sizeof(DCT_TYPE)*TVAL_DCT_SZ);iCoefsOut=0;sum=0;}
         

      }
      //else if(i_sIsB && sum)

 //     if(iCoefsOut==1 && p[0]<0)p[0]++;
      
      //if(!iQRem && sum)sum--;
 
      //if(sum<0)sum=0;

#endif

      //if(sum<0)sum=0;
      return sum;//return sum>1?sum:0;
   }

   int encMB_UV(IMG_MB *mbY, IMG_MB *mbU, IMG_MB *mb,DCT_TYPE *dctQ, unsigned char *pCur, unsigned char *pRef, int stride, int iIsY, int iDecode, int iIsRef)
   {
      //--return encMB(mb,dctQ,pCur,pRef,stride,1,iDecode);
      T_ALIGN_64(DCT_TYPE,saved,64);
      T_ALIGN_64(DCT_TYPE,dctDeQ,64);
      T_ALIGN_64(DCT_TYPE,pic,64);
      T_ALIGN_64(DCT_TYPE,dctC,64);
      if(iSkUV)return 0;

      int sum=0,i;
      int ret=0;
      int iMinPosSad=getMinPosSad();
      //return 0;

      //int iHasSaved=0;
//      int iIsRef=!iIsB && iDecode==0;

      mb->iIs4x4=0;
     // if(mb->iSkip==1)return 0;
      if((((mbY && mbY->iIsDif==0 && mbY->iSkip!=1) || mb->iSkip==5 || (iDecode==0 && mb->iCanBePic && mbY->iDifSad>400)) && !iIsB))
      {
         ret=loadBlockK(&dctC[0],pCur,pRef,stride);
         mb->iSkip=5;
         mb->iIsDif=0;
         mb->iDifSad=4;
       //  memcpy(dctC,mb->dct,sizeof(DCT_TYPE)*TVAL_DCT_SZ);
      }
      else{
         //if(mbY && mbY->iSkip==1)return 0;//???????

         //ret=canSkip<0>(pCur,pRef,8,stride,mb->iDifSad,t_d1,t_d1);
         mb->iDifSad=sadGainUU(pCur,pRef,stride,t_d1);
         ret=0;
         if(!iIsRef && mb->iDifSad<192+iIsB*64 + ((mbY && mbY->iSkip)?120:-20)){
            mb->iSkip=1;mb->iIsDif=1; 
            mb->iQuantCoefSum=0;
            return 0;
         }
         if(mbU && mbU->iSkip!=1){
            if(iIsB==0 && mb->iDifSad>1024 && mb->iDifSad>3*mbY->iDifSad && mbY->iSkip==0)ret=2;
            else if(iIsB==0 && mb->iDifSad>2048)ret=2;

            if(iIsB && (mb->iDifSad<384 || (mb->iDifSad<2*mbY->iDifSad && mbY->iSkip==1))){
               mb->iSkip=1;mb->iIsDif=1; 
               mb->iQuantCoefSum=0;
               return 0;
            }
            
            if(mb->iDifSad*6<iMinPosSad || (!iIsRef  &&mb->iDifSad*4<iMinPosSad) || (iIsB && mb->iDifSad<iMinPosSad)){
               mb->iSkip=1;mb->iIsDif=1; 
               mb->iQuantCoefSum=0;
               return 0;
            }
            if(!iIsRef && (mb->iDifSad<192 || (2*mb->iDifSad<3*mbY->iDifSad && mbY->iSkip==1) || (mb->iDifSad<2*mbY->iDifSad && mbY->iIs4x4==4))){
               mb->iSkip=1;mb->iIsDif=1; 
               mb->iQuantCoefSum=0;
               return 0;
            }
         }
         //if(iIsB && ret==2)ret=0;
         //ret=2;
         //if(mb->iDifSad>512 && iIsB==0)ret=2;
         if(ret==2){
            ret=loadBlockK(&dctC[0],pCur,pRef,stride);
            mb->iSkip=5;
            mb->iIsDif=0;
           // mb->iDifSad=4;
            //memcpy(dctC,mb->dct,sizeof(DCT_TYPE)*TVAL_DCT_SZ);
         }
         else{
            if(iIsRef && mb->iDifSad<64){
            }
            else if(mb->iDifSad>192 && mb->iHasUpAndLeft 
               && ((mb[-1].iDifSad<mb->iDifSad && mb[-1].iSkip!=1)
               ||(mb[-mb->iMbPerRow].iDifSad<mb->iDifSad && mb[-mb->iMbPerRow].iSkip!=1))
               ){

            }
            else{
               if((mbU==0 || mbU->iSkip==1 || mbU->iQuantCoefSum==0 ) && mb->iDifSad<40+mbY->iDifSad && ( mbY->iSkip==1 || mbY->iQuantCoefSum==0))ret=1;
               if(mbU && mb->iDifSad<mbU->iDifSad && (mbU->iSkip==1 || mbY->iQuantCoefSum==0))ret=1;
               if(mb->iDifSad<1024 && (ret==1 || (mbY->iSkip==1 && mb->iDifSad<256)|| (mbY->iSkip==1 && mb->iDifSad<40+mbY->iDifSad) || mb->iDifSad<128 || (iIsB && mb->iDifSad<256))){
                  mb->iSkip=1;mb->iIsDif=1; 
                  mb->iQuantCoefSum=0;
                  return 0;
               }
               else if(mb->iHasUpAndLeft && mb[-1].iDifSad>mb->iDifSad && mb[-1].iMaxCoef!=-1 && mb[-1].iQuantCoefSum<2){
                  mb->iSkip=1;mb->iIsDif=1; 
                  mb->iQuantCoefSum=0;
                  return 0;
               }
            }

            loadBlockFast(&dctC[0],&pic[0],pCur,pRef,stride,iDecode==0,0);
            //ret=loadBlock(mb,&saved[0],&pic[0],pCur,pRef,stride,iDecode==0,0);
            //mb->iDifSad=ret;
            
            //if(mbY && mbY->iDifSad>ret*4 && mbY->iSkip==1)ret=0;

            mb->iIsDif=1;
            //if(mb->iDifSad<32){mb->iSkip=1;return 0;}
            //if(mb->iDifSad<96 && mbY->iSkip==1){mb->iSkip=1;return 0;}
            mb->iSkip=0;
            //iHasSaved=1;
         }
      }
      mb->iCoefsDct=0;
      mb->iCoefsQuant=0;
      mb->iQuantCoefSum=-1;

      mb->iMaxCoef=0;
      mb->iQuantCoefSum=0;
      if(!iSkipDct){
         dct_fnc(&dctC[0]);
      }

      int *t=iIsY?&tab_y[0]:&tab_uv[0];
      if(mb->iIsDif)
         sum=Q<0,0>(&dctQ[0],&dctC[0],t,!iIsY, mb->iCoefsQuant,mb->iMaxCoef,iDecode==0 || iIsKey,iIsB);
      else
         sum=Q<1,0>(&dctQ[0],&dctC[0],t,!iIsY, mb->iCoefsQuant,mb->iMaxCoef,iDecode==0 || iIsKey,iIsB);
      mb->dc_quantized=dctQ[0];
      

      mb->iQuantCoefSum=sum;
      
      if(sum || !mb->iIsDif)
      {
         if(mb->iIsDif){
            mb->iMaxCoef++;
         }

         //mb->cnt=0;
         //if(sum==0)memset(dctQ,0,sizeof(DCT_TYPE)*TVAL_DCT_SZ);
         //int iCanRestore=sum && iIsKey==0 && mb->iSkip<2 && ((mmabs(dctQ[0])<8 && mmabs(dctQ[1])<6 && mmabs(dctQ[8])<6) || (mmabs(dctQ[0])<12 && mb->iCoefsQuant>8));
         //int iCanRestore=iDecode==1 && 0
           // && mb->iMaxCoef<40  && iIsKey==0 && mb->iSkip<2 && ((mmabs(dctQ[0])<3 && mmabs(dctQ[1])<1 && mmabs(dctQ[8])<1));
         //int iCanRestore=1 && mb->iIsDif &&  iDecode==1 && iIsKey==0 && mb->iDifSad<512 && mb->iMaxCoef<100 &&  mb->iSkip<2 && ((mmabs(dctQ[0])<9 && mmabs(dctQ[1])<1 && mmabs(dctQ[8])<1));
         int iCanRestore=mb->iIsDif &&  (mb->iDifSad<(iMinPosSad>>1)+512 || (mbY && mbY->iCanRestore));//mb->iIsDif && iDecode==1 && mb->iDifSad<100*12 && mmabs(dctQ[0])<3;

         //if(iCanRestore)
         //if(mb->iIsDif && iCanRestore==0 && mmabs(dctC[0])<16 && mmabs(dctC[1])<8 && mmabs(dctC[8])<8)iCanRestore=1;
        // if(iCanRestore && mb->iCoefsQuant<3 && mb->iMaxCoef<16)iCanRestore=0;

         if(iCanRestore && mmabs(dctC[0])>1 && mb->iCoefsQuant==1)iCanRestore=0;
         //if(iCanRestore && mb->iIsDif==0 && sum>2)iCanRestore=0;
         //if(!sum && iIsKey==0)iCanRestore=1;
         
         int iUsePsnr=1;//mbY && mbY->iSkip==1;
         if(iCanRestore){
            getBlock(&saved[0],pCur,stride);
            iDecode=1;
            if(iUsePsnr && mb->iStartPsnr==0){
               mb->iStartPsnr=getBlockPSNR(pCur,pRef,TVAL_8,TVAL_8,stride,3);
               if(iIsB==0 && sum>3 && mb->iStartPsnr<2200)iCanRestore=0;
            }
         }

         if(iCanRestore){
            getBlock(&saved[0],pCur,stride);
            iDecode=1;
            //mb->iStartPsnr=getBlockPSNR(pCur,pRef,TVAL_8,TVAL_8,stride,3);
         }
         
 
         int _TODO_dont_decode_if_refM2_iQIsMax;

         int iRndNO=iRndN;
         if((/*iQVal<70 &&  */decodeAllFramesParts()!=3 && !iIsB) || (iIsB && decodeAllFramesParts()==3)){
            if(!sum)fill_dc128(pCur,stride);
            else {
               int co=mb->iCoefsQuant;//dctQ[0] && mb->iCoefsQuant==1?0:64;
               if(mb->iIsDif){
                  deQ<0,0>(&dctQ[0],&dctDeQ[0],t,co);
                  if(co==1){
                     idct_fnc(&dctDeQ[0],co);
                     a_dif(&dctDeQ[0],pCur,stride);
                  }
                  else {
                     t_idct_int32_s(&dctDeQ[0],pCur,stride);
                  }
               }
               else{
                  deQ<2,0>(&dctQ[0],&dctDeQ[0],t,co);
                  ::idct_fnc_dc128(&dctDeQ[0],co);
                  this->copy_16_8(&dctDeQ[0],pCur,stride);
               }
            }

         }else 
         if(iIsKey || iDecode==0){
            if(decodeAllFramesParts())x_dif(NULL,pCur,pRef,stride);
         }
         else if(!sum && !iIsB)
            fill_dc128(pCur,stride);
         else if((mb->iIsDif || 
            !iQIsMax || iCanRestore) && sum   && iDecode && (!iIsB || iCanRestore))//  && !iQIsMax)//sum && iDecode && iCanRestore)//sum && iDecode && (iCanRestore || !iIsB))//iDecode &&  sum && !iIsB)// && (iCanRestore))// || !iIsB))
         {
            
            int co=mb->iCoefsQuant;//dctQ[0] && mb->iCoefsQuant==1?0:64;
            if(mb->iIsDif){
               deQ<0,0>(&dctQ[0],&dctDeQ[0],t,co);
               if(co==1){
                  idct_fnc(&dctDeQ[0],co);
                  a_dif(&dctDeQ[0],pCur,stride);
               }
               else {
                  t_idct_int32_s(&dctDeQ[0],pCur,stride);
               }
            }
            else{
               deQ<2,0>(&dctQ[0],&dctDeQ[0],t,co);
               ::idct_fnc_dc128(&dctDeQ[0],co);
               this->copy_16_8(&dctDeQ[0],pCur,stride);
            }

         }
         else if(sum && !iIsB)
            x_dif(NULL,pCur,pRef,stride);
         else if(!sum && !mb->iIsDif && !iIsB)
            x_dif(NULL,pCur,pRef,stride);

         

         
         
         if(iCanRestore)
         {
            if(iUsePsnr){
               int psnr=getBlockPSNR(pCur,pRef,TVAL_8,TVAL_8,stride,3);
               //if(mb->iStartPsnr*6>psnr*5){
               //if(mb->iStartPsnr*10>psnr*9){
               int iMBUsk=(mbU && mbU->iSkip==1)?20:0;
               if(mbY && mbY->iSkip==1)iMBUsk+=20;else iMBUsk-=20;
               if(iIsB)iMBUsk+=50;
               int iPsnrDif=psnr-mb->iStartPsnr;
               if(iPsnrDif>410+iMBUsk){
               }
               else if(mb->iStartPsnr*8>psnr*7 || (psnr<2700 && mb->iStartPsnr*4<psnr*3) || iPsnrDif<300+iMBUsk){
                  mb->iQuantCoefSum=0;
                  putBlock(&saved[0],pCur,stride);
                  mb->iSkip=1;mb->iCoefsQuant=-5;
                  if(mb->iStartPsnr<iSStartSkipedPsnr[1])iSStartSkipedPsnr[1]=mb->iStartPsnr;
                  iRndN=iRndNO;
                  mb->iMaxCoef=-1000-iPsnrDif;

                  return 0;
               }
               if(mb->iStartPsnr>iBSendPsnr[1])iBSendPsnr[1]=mb->iStartPsnr;
               //debugss("rest !ok",psnr-mb->iStartPsnr,mb->iMaxCoef);
            }
            else{
            //int iEncBits=iPass==7?-1:mb->iEncBits;
            int iSadAfter=sadGainUU(pCur,pRef,stride,t_d1);
            int iSadGain=mb->iDifSad-iSadAfter;
            int iE=(100*mb->iDifSad/(iSadAfter+1))-100;
            if(iSadGain>(120-iIsRef*60+iIsB*20) || iE>(24-iIsRef*15+iIsB*15))// && iSadGain>64*6)//g>64*20 || (g>80 && mb->iCoefsQuant<3))//((dctQ[0]==0 && sum<6)|| mb->iCoefsQuant<3)))// ||(iEncBits>=0 && iEncBits<10)))
            {
            }
            else
            {
               //int eM=iIsB?15:10;
               if(iSadGain<30 || iE<10)// || ((iSadGain+4)*4>mb->iDifSad && mb->iDifSad<mb->iPicMean))// || (g<120 && iEncBits>40) || (g<80 && iEncBits>32))
               //if(mb->iDifSad<iSadGain*2)
               {
                 // debugss("restored UV",mbY->iDifSad,mb->iDifSad*100000+iSadGain);
                  putBlock(&saved[0],pCur,stride);
                  mb->iSkip=1;mb->iCoefsQuant=-5;
                  iRndN=iRndNO;
                  //if(!sum)mb->iIsDif=1;
                  return 0;
               }
            }
            }
            
         }
         
         //x_dif(NULL,pCur,pRef,stride);

         //if(!iIsB)mb->cnt=0;
         
         return 1;
      }
      return sum>0 || !mb->iIsDif;
   }
   int iPass;
   enum{eMBDif,eMBPic,eMBSkip};
   int iBitsGain2x2_test,iBitsGain2x2_test_better;
   template<int iIsDif>
   inline int calc4x4Bits(DCT_TYPE *x4x,unsigned char *pCur, unsigned char *pRef,int stride, int iIsB ){
      if(iIsDif){
         void t_fdct8_s_d(unsigned char *src,unsigned char *src2, int stride, DCT_TYPE *d );
         t_fdct8_s_d(pRef,pCur,stride,x4x);
      }
      else{
         void t_fdct8_s(unsigned char *src, int stride, DCT_TYPE *d );
         t_fdct8_s(pRef,stride,x4x);
      }
      const int iMinVal=iIsDif?22:14;
      const int iStart=iIsDif?0:1;

      int iBits=0;
      int i4xBits=0;
      int iBitsM[]={0,0,0,0};
      int c,qv,i,j=0;
      
      const int s_it_P[]={
         3,3,2,1,
         3,2,1,0,
         2,1,1,0,
         1,0,0,0,
/*
         0,1,0,2,             
         1,2,2,2,             
         0,2,1,2,
         2,2,2,2,
*/
      };
      //0, 4, 1, 2,
      const int s_it_B[]={
         3,1,1,0,
         1,1,0,0,
         1,0,0,0,
         0,0,0,0,
/*
         1,2,2,8,             
         2,4,8,12,             
         2,8,2,12,             
         8,12,12,16,
         */
      };

      
//      const int *s_it=iIsB?&s_it_B[0]:&s_it_P[0];
      
      /*
      10
      0,2,2,4,
      2,2,2,4,
      2,2,2,4,
      4,4,4,6,
      */
      /*
      //vc1
      const int m_16[]={
         18,14,14,12,             
         14,14,14,12,             
         14,14,14,12,             
         12,12,12,11,             
      };
      */
#define T_4x4_SUB 0
      const int m_16[]={
         /*
         24-T_4x4_SUB,32-T_4x4_SUB,16-T_4x4_SUB,12-T_4x4_SUB,             
         32-T_4x4_SUB,20-T_4x4_SUB,12-T_4x4_SUB,8-T_4x4_SUB,             
         16-T_4x4_SUB,12-T_4x4_SUB,8-T_4x4_SUB,8-T_4x4_SUB,             
         12-T_4x4_SUB,8-T_4x4_SUB,8-T_4x4_SUB,8-T_4x4_SUB,             
         */
         /*
         20,18,19,16,
         18,16,16,12,
         19,16,12,10,
         16,12,10,8,
         
*/
         /* 115 x 79KB
         24,18,24,18,
         18,10,18,10,
         24,18,24,18,
         18,10,18,10,
         */
         /*
         //114 x 74
         36,25,36,25,
         25,14,25,14,
         36,25,36,25,
         25,14,25,14,
*/
         20,12,20,12,
         12,6,12,6,
         20,12,20,12,
         12,6,12,6,
         
      };
      //55744 105 
      
                        
      int iMSendIt[4]={0,0,0,0};
      int dc=0;
      //arm compilatoram nepatik int iSendItVal=(iIsB?8:(iLowQval?6:4))+2;
      int iSendItVal=(iIsB?4:2);
     /// iSendItVal+=2;
      for(j=0;j<4;j++){
         iBits=0;
         for(i=iStart;i<1;i++){
            c=x4x[tabzz4x4[i+j*16]];dc+=c;
            c=mmabs(c);
            iBits++;
            if(c>iMinVal){
               qv=((c-iIsDif)*m_16[i])>>9;
               if(qv>0){
                  iBits+=getBitLen(qv);
                  iBitsM[j]=iBits;
                  //if(qv>=s_it[i] || !iIsDif)
                  iMSendIt[j]+=s_it_P[i];//qv;
                  if(qv>2)iMSendIt[j]+=3;
               }
            }
         }
         if(iIsB && iMSendIt[j]<2)
            continue;
         for(;i<4;i++){
            c=mmabs(x4x[tabzz4x4[i+j*16]]);
            iBits++;
            if(c>iMinVal){
               qv=((c-iIsDif)*m_16[i])>>9;
               if(qv>0){
                  iBits+=getBitLen(qv*2);
                  iBitsM[j]=iBits;
                  //if(qv>=s_it[i] || !iIsDif)iMSendIt[j]+=qv;
                  iMSendIt[j]+=s_it_P[i];
               }
            }
         }
         for(;i<16;i++){
            c=mmabs(x4x[tabzz4x4[i+j*16]]);
            if(c>iMinVal)qv=((c-iIsDif)*m_16[i])>>8;else {iBits++;continue;}
            if(qv>0){
               iBits+=getBitLen(qv*2);
               iBitsM[j]=iBits;
               //if(qv>=s_it[i] || !iIsDif)iMSendIt[j]+=qv;
               iMSendIt[j]+=s_it_P[i];
            }
            else iBits++;
         }
         if(iIsDif){if(iMSendIt[j]>3)i4xBits+=iBitsM[j];}
         else if(iMSendIt[j])i4xBits+=iBitsM[j];
      }
      if(iIsDif && iIsB && i4xBits==0)return 0;
      if(iIsDif && i4xBits==0 && dc>-16 && dc<16)  return 0;
      if(!iIsDif)i4xBits+=40;
//i4xBits>>=1;
      //i4xBits+=(!iIsHaarDif*2);
      i4xBits+=vlc.bitsLen[iMSendIt[0]+!iIsDif];
      i4xBits+=vlc.bitsLen[iMSendIt[1]+!iIsDif];
      i4xBits+=vlc.bitsLen[iMSendIt[2]];
      i4xBits+=vlc.bitsLen[iMSendIt[3]];
      i4xBits-=3;
      if(i4xBits<1)i4xBits=1;

      return i4xBits;
   }
   template<int iIsDif>
   inline int calc2x2Bits(DCT_TYPE *x2x,unsigned char *pCur, unsigned char *pRef,int stride, int iIsB , int iIsRef){

      void t_fdct_2x2_8_s_p(unsigned char *src, int stride, DCT_TYPE *d );
      void t_fdct_2x2_8_s_d(unsigned char *src,unsigned char *src2, int stride, DCT_TYPE *d );
      if(iIsDif)t_fdct_2x2_8_s_d(pRef,pCur,stride,x2x);else t_fdct_2x2_8_s_p(pRef,stride,x2x);
      int dc=0;
      int b2x2=16;
      int i,j,qv,c;
      //int tmNB[]={4,2,2,1};
      //int tmB[]={3,0,0,0};
      //int *tm=iIsB?&tmB[0]:&tmNB[0];
      ///int iSendItVal=iIsB?7:(iLowQval?5:3);
      int iSendX=0;
      for(j=0;j<16;j++){
         int iSendB=0;
         int iSendIt=0;
         i=0;{
            c=x2x[i];
            dc+=c;
            //c=mmabs(c);
            if(c<0)c=-c;
            iSendB++;
            if(c>2){
               qv=(c+2)>>2;
               iSendB+=getBitLen(qv);
               iSendB++;
               iSendIt+=qv;
            }
         }
         if(iIsB && iSendIt<2){
            x2x+=4;continue;
         }

         const int s_it[]={0,1,1,2};
         for(i=1;i<4;i++){
            c=mmabs(x2x[i]);
           // dc+=x2x[i];
            iSendB++;
            if(c<5){continue;}
            qv=(c-1)>>2;
            iSendB+=getBitLen(qv);
            if(qv>s_it[i])iSendIt+=qv;
         }
         x2x+=4;
         if(iSendIt>1){b2x2+=iSendB;iSendX++;}
      }
      //const int co=iIsRef?4:12;
      //dc=mmabs(dc);
      //if(iIsB && dc<7)return 0;
      //if(iIsRef==0 && dc<8 && iSendX<3)return 0;

      //if(iSendX==0 && dc<20) return 0;
      if(iSendX==0)return 0;
      //if(b2x2==16)b2x2=0;

      b2x2=((iSendX*16+16)+b2x2*3+2)>>2;
      
      int iHQ=0;
      
      if(dc<8)b2x2-=8;else{
         if(iHQ)b2x2+=iSendX*6; 
         else b2x2+=(dc>>3);
      }
      
      //if(iSendX<2){b2x2>>=1;}
     // else if(dc>24)b2x2+=20;
/*
      if(iSendX<3){b2x2>>=2;}
      else if(iSendX<7){b2x2>>=1;}
      else {b2x2*=3;b2x2>>=2;}
      b2x2++;
      */
     // b2x2>>=1;
//b2x2=1;//>>=2;
      

      return b2x2;
   }
   inline int getBitLen(int v){
      if(v>512)return 20;
      if(v<0)v=-v;
      return vlc.bitsLen[v];
   }
#define LIM_PIC_SEND 120
   int picOrDif(IMG_MB *mb,unsigned char *pCur, unsigned char *pRef,int stride, int &dc, int iIsRef, int &iCanRestore){

      T_ALIGN_64(DCT_TYPE,d,64);
      T_ALIGN_64(DCT_TYPE,p,64);
      T_ALIGN_64(DCT_TYPE,x4d,64);
      iCanRestore=0;

      int iSendPic= !iIsB &&((iIsRef && mb->cnt>(LIM_PIC_SEND>>2) && mb->iPicMean<5000  && mb->iDifSad>400) 
            || (mb->iPicMean<400 && mb->iDifSad>2000)
            || (iIsRef && mb->iPicMean<800 && mb->iDifSad>1000)
            || (iIsRef && mb->iPicMean>=10 && mb->cnt>8 && mb->iPicMean<300)
            || (iIsRef &&  mb->cnt>(LIM_PIC_SEND>>1))
            || mb->cnt>LIM_PIC_SEND*2
            );

      if(iEnc4x4Only==1 || iEncPicOnly==2 || (iSendPic==0 && mb->iIs4x4)/* || iIsB*/){
         int p4Bits;
         if(iEncPicOnly){
            p4Bits=calc4x4Bits<0>(&mb->dct[0],pCur,pRef,stride,iIsB);
            mb->iEncBits=p4Bits;
            mb->iIsDif=0;
            mb->iIs4x4=2;
            return eMBPic;
         }
         int d4Bits=calc4x4Bits<8>(&mb->dct[0],pCur,pRef,stride,iIsB);
         dc=mb->dct[0];
         if(iEnc4x4Only==2 || (mb->iCanBePic==0 && d4Bits<50) || iIsB || d4Bits<20 ||  (mb->iCanBePic==0 && mb->cnt<20) || mb->iEncBits<40){
            mb->iIs4x4=2;
            mb->iEncBits=d4Bits;
            dc=(mb->dct[0]+mb->dct[16]+mb->dct[32]+mb->dct[48]+2)>>2;
            return d4Bits?eMBDif:eMBSkip;
         }
         p4Bits=calc4x4Bits<0>(p,pCur,pRef,stride,0);
         mb->iIs4x4=2;
         if(p4Bits<d4Bits){
            memcpy(mb->dct,p,sizeof(DCT_TYPE)*64);
            mb->iEncBits=p4Bits;
            mb->iIsDif=0;
            return eMBPic;
         }
         mb->iIsDif=1;
         mb->iEncBits=d4Bits;

         return eMBDif;

      }
      
      /*
      
      if(0&& !iIsB && !iIsRef)//0&&iIsB)//iLastPicBits>70 && iLastDifBits>50)
      {

         void t_fdct8_s_d(unsigned char *src,unsigned char *src2, int stride, DCT_TYPE *d );
         void t_fdct8_s(unsigned char *src, int stride, DCT_TYPE *d );
         t_fdct8_s_d(pRef,pCur,stride,&mb->dct[0]);
//         t_fdct8_s(pRef,stride,&mb->dct[0]);
         mb->iIs4x4=2;
         mb->iIsDif=1;
         return eMBDif;
      }
      */
      int i;
      int iPicBits=0;
      int iDifBits=0;
      int iLastPicBits=0;
      int iLastDifBits=0;
      int qv;
      DCT_TYPE c;
      dc=0;//d[0];
      int iCoefs=0;
      int iLastId=-1;

//      int iSH=3;//this->iQVal>60?3:(this->iQVal>30?4:5);
      //if(iIsRef)iSH--;
      //zzzff_zigzag_direct
      int *xTab=(int*)&zzzff_zigzag_direct[0];//&tabzz4x4[0];


            
      if(iEncPicOnly || iSendPic ){
         iLastDifBits=100000;
      }
      else{
         loadBlockFast(d,NULL,pCur,pRef,stride,0,1);
         if(D_4x4==0)dct_fnc(d);else d_dct_fnc(d);
         dc=d[0];
//   #define _SH_Q 3
//         int to=iIsRef?64:49;
         
         int iMaxQV=0;
         for(i=0;i<3;i++){
            c=mmabs(d[xTab[i]]);
            iDifBits++;
            if(c>5)qv=(c-1)>>2;else continue;
            if(qv){if(qv>iMaxQV)iMaxQV=qv;if(qv==1)iDifBits++;else iDifBits+=getBitLen(qv>>2)+2;iLastId=i;}
         }
         iLastDifBits=iDifBits;
         
         for(;i<15;i++){
            c=mmabs(d[xTab[i]]);
            if(c>7)qv=(c-1)>>2;else{iDifBits++; continue;}
            if(qv){if(qv>iMaxQV)iMaxQV=qv;iCoefs++;iDifBits+=getBitLen(qv*2);iLastDifBits=iDifBits;iLastId=i;}
         }
         //if(iIsRef==0 && iLastDifBits<5 && mmabs(d[0])<=5)return eMBSkip;
         if(iLastDifBits<3 || iLastId==-1 || (iMaxQV<2 && mmabs(d[0])<=4 &&  mmabs(d[1])<=4 &&  mmabs(d[8])<=4) || (iIsB && mmabs(d[0])<=2))return eMBSkip;
         for(;i<64;i++){
            c=mmabs(d[xTab[i]]);
            if(c>5)qv=(c-1)>>2;else{iDifBits++; continue;}
            if(qv){if(qv>iMaxQV)iMaxQV=qv;iCoefs++;iDifBits+=getBitLen(qv*2);iLastDifBits=iDifBits;iLastId=i;}
         }

         //if(iLastDifBits>20){iLastDifBits*=9;iLastDifBits>>3;}
         
  //       if(iMaxQV<2)return eMBSkip;

         //if(mmabs(d[0])>3 && iLastDifBits<7 && mmabs(d[0])<8)return eMBSkip;

         //iLastDifBits+=vlc.bitsLen[iCoefs];
         iLastDifBits+=vlc.bitsLen[iCoefs];

         
         if(iIsRef==0 && mb->cnt<15 && ((iMaxQV<4 && iLastId<12)|| iLastDifBits<70 || iLastId<4)){

            if(iLastId>4){
               int d4Bits=calc4x4Bits<8>(x4d,pCur,pRef,stride,iIsB);
               if(d4Bits==0)return eMBSkip;
               if(d4Bits<iLastDifBits){

                  memcpy(mb->dct,x4d,sizeof(DCT_TYPE)*64);
                  mb->iEncBits=d4Bits;
                  mb->iIs4x4=2;
                  mb->iIsDif=1;
                  return eMBDif;
               }
            }

            memcpy(mb->dct,d,sizeof(DCT_TYPE)*64);
            mb->iEncBits=iLastDifBits;
            if(mmabs(d[0])<=4)iCanRestore=1;
            mb->iIs4x4=0;

            return eMBDif;
         }
      }
      iLastPicBits=1000000;

      if((mb->iCanBePic || (mb->cnt>10 && !iLowQval ) || iIsRef || iSendPic || iLastDifBits>400) && iIsB==0 &&(iEncPicOnly || iLastDifBits<5000 || iLastDifBits>500)){
         iCoefs=0;
         loadBlockK(p,pCur,pRef,stride);
         dct_fnc(p);
         iLastId=0;
         //1+2+3
         iLastPicBits=0;
         for(i=1;i<3;i++){
            c=mmabs(p[xTab[i]]);
            if(c>4)qv=(c+1)>>2;else qv=0;
            iPicBits++;
            if(qv){iPicBits+=getBitLen(qv>>2)+2;iLastId=i;}
         }
         iLastPicBits=iPicBits;
         
         for(;i<64;i++){
            c=mmabs(p[xTab[i]]);
            if(c>3)qv=(c+1)>>2;else{iPicBits++; continue;}
            if(qv){iCoefs++;iPicBits+=getBitLen(qv*2);iLastPicBits=iPicBits;iLastId=i;}
         }

         if(iCoefs)iLastPicBits+=vlc.bitsLen[iCoefs];else iLastPicBits++;
         iLastPicBits+=7;
      }
      
      int i4xBits=50000;

      if((iIsRef || (iLastId<3 && iLastId!=-1)) && mb->cnt>8)iLastDifBits+=20;//<<=1;
      int iIsHaarDif=iIsB || (iEncPicOnly==0 && (iLastPicBits>iLastDifBits || (iIsRef==0 && iLastPicBits<60)));// && iLastPicBits<160;
      if(iIsHaarDif && mb->iCanBePic && iIsB==0 && iLastPicBits<iLastDifBits && iLastDifBits>200)iIsHaarDif=0;
      if(iIsHaarDif==0 && mb->iCanBePic==0 )iIsHaarDif=1;
      if(iLastId<10 && iLastId!=-1){
      }
      else if(( iLastPicBits>(iLastPicBits<iLastDifBits?70:30 )
          && (!iIsHaarDif || mmabs(dc)<160) &&   iLastDifBits>30)){
         if(iIsHaarDif){
            i4xBits=calc4x4Bits<8>(x4d,pCur,pRef,stride,iIsB);
            if(!i4xBits)return eMBSkip;
            dc=((x4d[0]+x4d[16]+x4d[32]+x4d[48])+2)>>2;
            if(mmabs(x4d[0])<10 &&  mmabs(x4d[16])<10 &&  mmabs(x4d[32])<10 &&  mmabs(x4d[48])<10)iCanRestore=1;
         }
         else {
            i4xBits=calc4x4Bits<0>(x4d,pCur,pRef,stride,iIsB);
         }
         if(i4xBits<iLastPicBits && i4xBits<iLastDifBits){
            memcpy(mb->dct,x4d,sizeof(DCT_TYPE)*64);
            mb->iEncBits=i4xBits;
            mb->iIs4x4=2;
            mb->iIsDif=iIsHaarDif;
            return iIsHaarDif?eMBDif:eMBPic;
         }

      }
      
      if(iIsRef && iLastPicBits<iLastDifBits)i4xBits-=4;

      if(iEncPicOnly || (iIsHaarDif==0 && iLastPicBits<i4xBits && iLastPicBits<iLastDifBits)){
         mb->iEncBits=iLastPicBits;
         memcpy(mb->dct,p,sizeof(DCT_TYPE)*64);
         mb->iIs4x4=0;
         return eMBPic;
      }

      
      //-----------
      if(mb->cnt>5 || iIsRef){

         //if(iDecode==0)iPicBits*=3;iPicBits>>=2;
         iLastDifBits+=2;
         if(mb->cnt>12 && iLastDifBits>60){iLastDifBits*=5;iLastDifBits>>=2;}
         else if(mb->cnt>20){iLastDifBits*=5;iLastDifBits>>=2;}
         //else if(mb->cnt>30){iLastDifBits*=3;iLastDifBits>>=1;}

         if(mb->cnt>6 && mb->iHasUpAndLeft){
            if(mb[-1].iSkip==5){iLastDifBits+=10;}
            else if(mb[-mb->iMbPerRow].iSkip==5){iLastDifBits+=10;}
            else if(mb[-mb->iMbPerRow-1].iSkip==5){iLastDifBits+=4;}
            else if(mb[-mb->iMbPerRow+1].iSkip==5){iLastDifBits+=4;}
         }
      }
      //---

      //int ret=iLastDifBits<iLastPicBits?eMBDif:eMBPic;
      int ret=iLastDifBits<iLastPicBits?eMBDif:eMBPic;
      //if(ret==eMBDif && iLastDifBits>40 && iLastPicBits>30 && mmabs(d[0])<12 &&  mmabs(d[8])<16 &&  mmabs(d[1])<16)iCanRestore=1;

      if(ret==eMBPic && i4xBits<iLastPicBits){
         mb->iIs4x4=2;
         mb->iIsDif=iIsHaarDif;
         //ret=eMBDif;
         dc=((x4d[0]+x4d[16]+x4d[32]+x4d[48])+2)>>2;
         memcpy(mb->dct,x4d,sizeof(DCT_TYPE)*64);
         mb->iEncBits=i4xBits;
         return mb->iIsDif?eMBDif:eMBPic;
      }
      
      //if(mb->cnt>15 && ret==eMBDif && iLastDifBits>30)ret=eMBDif;
      //else if(mb->cnt>5 && ret==eMBDif && iLastDifBits>50)ret=eMBDif;


      mb->iEncBits=ret==eMBDif?iLastDifBits:iLastPicBits;
      memcpy(mb->dct,ret==eMBDif?d:p,sizeof(DCT_TYPE)*64);
      mb->iIs4x4=0;
      return ret;

   }
   int encMB(IMG_MB *mb, DCT_TYPE *dctQ, unsigned char *pCur, unsigned char *pRef, int stride, int iIsY, int iDecode=1)
   {
      T_ALIGN_64(DCT_TYPE,saved,64);
      T_ALIGN_64(DCT_TYPE,dctDeQ,64);
      T_ALIGN_64(DCT_TYPE,pic,64);

      
      int iIsRef=iDecode==0;


/*
      DCT_TYPE saved[64];
      //DCT_TYPE dctQ[64];
      DCT_TYPE dctDeQ[64];
      DCT_TYPE pic[64];
*/
      int sum=0;
      int ret=0;
#define DCT_PASS (iPass&1)
#define Q_PASS (iPass&2)
#define RESTORE_PASS (iPass&4)
//#define SEND_PASS_NON_DIF (iPass&8)

      //int iHasSaved=0;

      int iCanRestoreX=0;
      if(DCT_PASS || mb->iSkip==3){

         int r=2;
          int iSkDct=0;
         mb->iCoefsDct=0;
         mb->iCoefsQuant=0;
         mb->iQuantCoefSum=-1;
         //mb->cnt+=15;
         
         if(iEnc4x4Only==2){
            void t_fdct8_s_d(unsigned char *src,unsigned char *src2, int stride, DCT_TYPE *d );
            t_fdct8_s_d(pRef,pCur,stride,&mb->dct[0]);
            iSkDct=1;
            mb->iIs4x4=2;
            mb->iIsDif=1;

         }

         else if(!iIsB && ((/*iIsKey || */mb->iSkip==5
            //|| (mb->cnt>100 && iDecode==0)
            || ((mb->cnt>15 || iIsRef) && mb->iPicMean==10)
            || (mb->iPicMean>10 && mb->cnt>25 && mb->iPicMean<500))))
         {
            //if(iIsKey==0)mb->iDifSad=sadGainUU(pCur,pRef,stride);
            ret=loadBlockK(&mb->dct[0],pCur,pRef,stride);
            mb->iSkip=5;
            mb->iDifSad=0;
            mb->iIsDif=0;
            mb->iIs4x4=0;
         }
         else {
            static int iX;iX++;
            if(0){//iIsB==0 && iX==3){
               iX=0;
               loadBlock(mb,&pic[0],pCur,pRef,stride, iDecode==0,iIsY);
               iSkDct=0;
               mb->iDifSad=sadGainUU(pCur,pRef,stride,t_d1);
               mb->iIsDif=1;
               mb->iIs4x4=1;
            }
            else{
            r=0;
            int dcd=0;
            int retd=eMBDif;

            T_ALIGN_64(DCT_TYPE,d2x2,64);
            T_ALIGN_64(DCT_TYPE,p2x2,64);
            int iD2x2=100000;
            int iIsRef=iDecode==0 && iIsB==0;
            mb->iEncBits=iD2x2;
            
            if(iEncPicOnly==0){
               iD2x2=calc2x2Bits<2>(d2x2,pCur,pRef,stride,iIsB,iIsRef);
               //if(iIsRef)iD2x2++;
               if(iD2x2==0 && iSkipRestore==0){
                  mb->iCoefsQuant=-3;mb->iSkip=1;mb->iIsDif=1; 
                  iBitsGain2x2_test_better++;
                  return 0;
               }
               mb->iEncBits=iD2x2;
               //--??--if(mb->iCanRestore)mb->iCanRestore=iD2x2<30;
               if(iD2x2>150 && !iLowQval)mb->iCanBePic=1;
               ///if(iD2x2<80)mb->iCanBePic=0;
            }
            if((((!iIsRef || (iD2x2<40 && mb->cnt<LIM_PIC_SEND)) ) && (iD2x2<70/* || iD2x2<150*/))){// || (iIsB==0 && mb->cnt==0 && iD2x2<70)){
               iSkDct=1;
               memcpy(&mb->dct[0],d2x2,64*2);
               iBitsGain2x2_test_better+=1000000;
               mb->iIsDif=1;
               mb->iIs4x4=4;
               retd=eMBDif;
               mb->iEncBits=iD2x2;
               iD2x2=0;
               //mb->iCanRestore=0;
            }
            
            else if(1){if(iD2x2<140)mb->iIs4x4=1;/*else if(iD2x2>160)mb->iIs4x4=0;*/ retd=picOrDif(mb,pCur,pRef,stride,dcd,iIsRef,iCanRestoreX);iSkDct=1;}else iSkDct=0;
            if(0&&retd==eMBDif && mb->iEncBits>80){
               mb->iEncBits*=17;
               mb->iEncBits>>=4;
            }
            if(mb->iIs4x4!=4 && (iD2x2<110 || iD2x2+20<mb->iEncBits) && ( 
               (retd==eMBDif && iD2x2+10<mb->iEncBits)||
               //(mb->iEncBits>140 && ((retd==eMBDif && iD2x2+10<mb->iEncBits) ||
                (mb->cnt<15 && retd==eMBPic && iEncPicOnly==0 && iD2x2<mb->iEncBits))){
               memcpy(&mb->dct[0],d2x2,64*2);
               iBitsGain2x2_test_better+=1000000;
               mb->iIsDif=1;
               mb->iIs4x4=4;
               retd=eMBDif;
               mb->iEncBits=iD2x2;
               //mb->iCanRestore=0;
            }
            else if(0){//retd==eMBPic && mb->iEncBits>80){
               //ipahi japastraadaa 16dc
               int iP2x2=calc2x2Bits<0>(p2x2,pCur,pRef,stride,iIsB,iIsRef);
               if(iP2x2<mb->iEncBits){iBitsGain2x2_test+=(mb->iEncBits-iP2x2);iBitsGain2x2_test_better++;}else iBitsGain2x2_test_better--;
            }
            //mb->iCanRestore=iCanRestoreX;
            //mb->iDifSad=mmabs(mb->dct[0])*8+mmabs(mb->dct[1])*32+mmabs(mb->dct[8])*32;


            if(retd==eMBSkip ){
               mb->iCoefsQuant=-3;mb->iSkip=1;mb->iIsDif=1; return 0;
            }
            //if(retd==eMBSkip)retd=eMBDif;
            //iSkDct=0;
            mb->iIsDif=retd==eMBDif;
            /*
            if((iSkDct==0 || (mb->iIsDif && iCanRestoreX))){
//               r=canSkip<0>(pCur,pRef,8,stride,mb->iDifSad,t_d4,t_d1);
               if(iIsB)
                  r=canSkip<0,1>(pCur,pRef,8,stride,mb->iDifSad,t_d2,t_d1);
               else if(iDecode==0)
                  r=canSkip<2,0>(pCur,pRef,8,stride,mb->iDifSad,t_d4,t_d1);
               else 
                  r=canSkip<1,0>(pCur,pRef,8,stride,mb->iDifSad,t_d4,t_d1);

            }
            else*/ if(mb->iIsDif)
               mb->iDifSad=sadGainUU(pCur,pRef,stride,t_d1);
            
            if(r==1){mb->iQuantCoefSum=0;mb->iCoefsQuant=-2;mb->iSkip=1;mb->iIsDif=1; return 0;}
            if(!mb->iIsDif)mb->iSkip=5;

               if(iSkDct==0){
                  r=loadBlock(mb,&pic[0],pCur,pRef,stride, iDecode==0,iIsY);
                  if(r==0){
                     {mb->iQuantCoefSum=0;mb->iCoefsQuant=-2;mb->iSkip=1;mb->iIsDif=1; return 0;}
                  }
               }
            }

#if 0
            //loadBlockK(&mb->dct[0],pCur,pRef,stride);
            
               //r=canSkip(pCur,pRef,8,stride,mb->iDifSad,iDecode==0?div_4_abs:div_2_abs);//(iIsB?div_2_abs:div_4_abs));
            int _TODO_LIETOT_div_f_abs_ja_veclen_lielaaks_par_32;

            mb->iStartPsnr=0;
            //if(!iIsB)  
           //    mb->iStartPsnr=getBlockPSNR(pCur,pRef,TVAL_8,TVAL_8,stride,3);
            //if(mb->iStartPsnr && mb->iStartPsnr>3000)r=1; else 
            //-- r=canSkip(pCur,pRef,8,stride,mb->iDifSad,iIsB?t_d2:(iDecode==0?t_d4:t_d4),t_d1);
            if(iIsB)
               r=canSkip<0>(pCur,pRef,8,stride,mb->iDifSad,t_d2,t_d1);
            else if(iDecode==0)
               r=canSkip<2>(pCur,pRef,8,stride,mb->iDifSad,t_d4,t_d1);
            else 
               r=canSkip<1>(pCur,pRef,8,stride,mb->iDifSad,t_d4,t_d1);
          //     r=canSkip(pCur,pRef,8,stride,mb->iDifSad,t_d1,t_d1);
            
            
            
            int iIsVideoCall=1;
            if(iIsVideoCall){
               int d=mb->iDifSad;
               int c=mb->cnt;

               if(iIsB==0 && (r==4 || (r!=2 && iDecode==0 && mb->iDifSad>96) || r==3 || (r==0 && mb->iDifSad>256)) && mb->cnt>3 && (iMaxNonDifAddCnt>0 ||( r==3 && mb->cnt>8 && iDecode==0) || (mb->cnt>70 && iDecode==0)))
               {
                  if(iDecode==0){}else {d*=3;d>>=2;}
                  if(r==3){d*=3;d>>=1;}
                  if(r==4){d*=5;d>>=2;}
                  if(c>50)r=2;
                  else if(d>64 && c>40)r=2;
                  else if(d>192 && c>20)r=2;
                  else if(d>384 && c>12)r=2;
                  else if(d>512 && c>6)r=2;
               }
               if(iIsB==0 && iMaxNonDifAddCnt>-mb->iMbPerRow){
                  if(mb->iHasUpAndLeft && mb[-1].iSkip==5 && d>192 && c>5)r=2;
                  else if(mb->iHasUpAndLeft && mb[-mb->iMbPerRow].iSkip==5 && d>192 && c>5)r=2;
                  //else if(mb->iHasUpAndLeft && mb[-mb->iMbPerRow].iSkip==5 && mb[-1].iSkip==5 && d>128 && c>3)r=2;
               }
            }
            if(r>2)r=0;

            if(r==1){mb->iQuantCoefSum=0;mb->iCoefsQuant=-2;mb->iSkip=1;mb->iIsDif=1; return 0;}
            if(r==2 && iIsB)r=0;

            //if(iIsB==0 && r!=2 && iDecode==0 && mb->iDifSad>384)r=2;

            if(r==2){
               ret=loadBlockK(&mb->dct[0],pCur,pRef,stride);
               mb->iSkip=5;
               iMaxNonDifAddCnt--;
            }
            else{
               ret=loadBlock(mb,&pic[0],pCur,pRef,stride, iDecode==0,iIsY);
               if(r==2 && ret==0)r=0;
            }
         }
//if(ret)ret--;else ret++;
         if(mb->iSkip==2 || mb->iSkip==5)
         {
            mb->iIsDif=0;
         }
         else
         {
            if(mb->iSkip==5)
               ret=0x7fff;
             
            //if(ret!=0x7fff &&  iIsY && iDecode==0 && mb->iDifSad>32)ret=(mb->iPicMean+4)*2<mb->iDifSad?0x7fff:mb->iDifSad;
            //if(ret!=0x7fff &&  iIsY && iDecode==0 && mb->iDifSad>64*24)ret=0x7fff;

            if(ret==0){mb->iCoefsQuant=-3;mb->iSkip=1;mb->iIsDif=1; return 0;}
            if(iIsB || (!iIsY && mb->iSkip!=5))ret--;


            mb->iIsDif=(ret!=0x7fff && r!=2) ||iIsB;

            //if(ret>128 && iDecode==0 && mb->iIsDif && (mb->iPicMean+32<mb->iCanRestore || ret >64*24))
              // mb->iIsDif=0;
            
            //if(mb->iSkip==0;
            if(!mb->iIsDif)
            {
               for(i=0;i<64;i++)mb->dct[i]=pic[i]-128;
            }
#endif
         }

         mb->iMaxCoef=0;
         mb->iQuantCoefSum=0;
         if(!iSkipDct && iSkDct==0){
            if(mb->iIs4x4)x4dct_fnc(&mb->dct[0]);else
               dct_fnc(&mb->dct[0]);
         }
         
      }
      int *t=iIsY?&tab_y[0]:&tab_uv[0];
      if(mb->iIs4x4)t+=128;

      if(Q_PASS || mb->iSkip==2){
         if(mb->iIsDif){
            if(mb->iIs4x4==4)
               sum=Q<0,1>(&dctQ[0],&mb->dct[0],t,!iIsY, mb->iCoefsQuant,mb->iMaxCoef,iDecode==0 || iIsKey,iIsB, mb->iIs4x4);
            else 
               sum=Q<0,0>(&dctQ[0],&mb->dct[0],t,!iIsY, mb->iCoefsQuant,mb->iMaxCoef,iDecode==0 || iIsKey,iIsB, mb->iIs4x4);
            if(sum==0 && (iQIsMax || mb->iMaxCoef<6)){mb->iSkip=1;dctQ[0]=0;}
         }
         else 
             sum=Q<1,0>(&dctQ[0],&mb->dct[0],t,!iIsY, mb->iCoefsQuant,mb->iMaxCoef,iDecode==0 || iIsKey,iIsB,mb->iIs4x4);
         //else if(sum==0 && mb->iIsDif && mb->iMaxCoef<6)mb->iSkip=1;
         /*
        if((mb->iIsDif && (iQIsMax || iIsB) && 
           mb->iMaxCoef<5 && mb->iSkip==0)){sum=0;mb->iCoefsQuant=0;}
        if(sum==0 && mb->iIsDif && iQIsMax ){mb->iSkip=1;mb->iCoefsQuant=0;}
        //if(mb->iIsDif && !sum){mb->iSkip=1;mb->iCoefsQuant=0;}
        */
        mb->iQuantCoefSum=sum;
        mb->dc_quantized=dctQ[0];
      }
      else {
         mb->iCoefsQuant=mb->iQuantCoefSum=sum=0;//mb->iQuantCoefSum;
      }
      

      //if(RESTORE_PASS && mb->iIsDif&&  sum==0)memset(dctQ,0,sizeof(DCT_TYPE)*TVAL_DCT_SZ);
      
      //if(!sum)sum=mb->iCoefsQuant;
      if(RESTORE_PASS &&(sum || !mb->iIsDif))
      {
         if(mb->iIsDif){
            mb->iMaxCoef++;
         }
         //if(mb->iIsDif==0)mb->cnt=0;
         //int iCanRestore=sum && iIsKey==0 && mb->iSkip<2 && ((mmabs(dctQ[0])<8 && mmabs(dctQ[1])<6 && mmabs(dctQ[8])<6) || (mmabs(dctQ[0])<12 && mb->iCoefsQuant>8));
         //int iCanRestore=iDecode==1 && 0
           // && mb->iMaxCoef<40  && iIsKey==0 && mb->iSkip<2 && ((mmabs(dctQ[0])<3 && mmabs(dctQ[1])<1 && mmabs(dctQ[8])<1));
         //int iCanRestore=1 && mb->iIsDif  && iIsKey==0 && mb->iDifSad<512 && mb->iMaxCoef<100 &&  mb->iSkip<2 && ((mmabs(dctQ[0])<9 && mmabs(dctQ[1])<1 && mmabs(dctQ[8])<1));
         //int iCanRestore=(mb->iIs4x4==0 || mb->iCanRestore) && ( iIsB ||iCanRestoreX || mb->iCanRestore) && iIsKey==0 
           // && mb->iIsDif  &&  (!dctQ && mmabs(mb->dct[1])<8 && mmabs(mb->dct[8])<8 && mb->iDifSad<20*8 &&  mb->iCoefsQuant>6) ||(mb->iCanRestore && mmabs(dctQ[0])<6);

         int iCanRestore=iIsRef==0 && mb->iIsDif  && mb->iMaxCoef<120;//&& mb->iCanRestore && (iIsB || iDecode) && iIsKey==0 ;
         //iCanRestore=1 && mb->iIsDif  && iIsKey==0 && mmabs(mb->dct[0])<12;
            //&& mb->iCoefsQuant>4;// && mb->iMaxCoef<20;// &&   !dctQ[1] && !dctQ[8];// && ((mb->iDifSad>64*2 && mb->iDifSad<64*6) || mb->iDifSad<80);
         //if((iDecode || iIsB) && mb->iIsDif && iCanRestore==0 && mmabs(mb->dct[0])<8 && mmabs(mb->dct[1])<5 && mmabs(mb->dct[8])<5)iCanRestore=1;
         //if(iCanRestore && mmabs(mb->dct[0])>9 && mb->iCoefsQuant==1)iCanRestore=0;
        // iCanRestore=0;
         //if(iCanRestore && mb->iCoefsQuant<3)iCanRestore=0;
         //if(iCanRestore && mb->iIsDif==0 && sum>2)iCanRestore=0;
         //if(!sum && iIsKey==0)iCanRestore=1;
         if(iSkipRestore)iCanRestore=0;
         if(mb->iIs4x4==4 && mb->iEncBits<80 && !iIsB)iCanRestore=0;
         int _TODO_dont_decode_if_refM2_iQIsMax;
         int iDecBlock=decodeAllFramesParts()==2;
         if(iIsB && decodeAllFramesParts()==3)iDecBlock=1;
         if(iDecBlock==0 && decodeAllFramesParts()==1 && (iIsKey || (iDecode==0 || !iIsB)))iDecBlock=1;
         //if(mb->iEncBits<36 && mb->iIs4x4)iCanRestore=0;

         iDecBlock=1;
         int s_psnr[4];
         int iUsePsnr=1;
         if(iCanRestore){
            if(iUsePsnr){
               if(mb->iIs4x4==2 && 0){
                  s_psnr[0]=getBlockPSNR(pCur,pRef,4,4,stride,3);
                  s_psnr[1]=getBlockPSNR(pCur+12,pRef+12,4,4,stride,3);
                  s_psnr[2]=getBlockPSNR(pCur+stride*4,pRef+stride*4,4,4,stride,3);
                  s_psnr[3]=getBlockPSNR(pCur+12+stride*4,pRef+12+stride*4,4,4,stride,3);

                  mb->iStartPsnr=s_psnr[0]+s_psnr[1]+s_psnr[2]+s_psnr[3];
                  if(mb->iStartPsnr>4200*4)iCanRestore=0;
               }
               else {
                  mb->iStartPsnr=getBlockPSNR(pCur,pRef,TVAL_8,TVAL_8,stride,3);
                  if(mb->iStartPsnr>4200 || (iIsB==0 && sum>1 && mb->iStartPsnr<2800))iCanRestore=0;

                 // if(mb->iStartPsnr>3600)return 0;
               }
               
            }
            if(iCanRestore){
               getBlock(&saved[0],pCur,stride);
               iDecBlock=1;
            }
         }
         int iRndNO=iRndN;
         
         
         


         if(iIsKey && iDecBlock==0){

         }
         else if(!sum && (!iIsB || iDecBlock))
            fill_dc128(pCur,stride);
         else if((mb->iIsDif ||  
            !iQIsMax || iCanRestore || iDecBlock) && sum   && (iDecode || iDecBlock || iCanRestore) && (!iIsB || iDecBlock|| iCanRestore))//  && !iQIsMax)//sum && iDecode && iCanRestore)//sum && iDecode && (iCanRestore || !iIsB))//iDecode &&  sum && !iIsB)// && (iCanRestore))// || !iIsB))
         {
            //int co=dctQ[0] && mb->iCoefsQuant==1?0:64;
            int co=mb->iCoefsQuant;//dctQ[0] && mb->iCoefsQuant==1?0:64;
            if(mb->iIsDif){
               if(mb->iIs4x4==4){
                  deQ<0,1>(&dctQ[0],&dctDeQ[0],t,co);
                  void t_idct_2x2_8_s_d(DCT_TYPE *d, unsigned char *dst, int stride, int iX );
                  t_idct_2x2_8_s_d(&dctDeQ[0],pCur,stride,0xffffff);
               }
               else {

                     if(mb->iIs4x4){
                        //x4idct_fnc(&dctDeQ[0],co);
                        deQ<0,0>(&dctQ[0],&dctDeQ[0],t,co,1);
                        void t_idct8_s(DCT_TYPE *t, unsigned char *dst, int stride, int iX);
                        t_idct8_s(&dctDeQ[0],pCur,stride,15);

                     }
                     else{
                        deQ<0,0>(&dctQ[0],&dctDeQ[0],t,co);
                        if(co==1){
                           idct_fnc(&dctDeQ[0],co);
                           a_dif(&dctDeQ[0],pCur,stride);
                        }
                        else {
                           t_idct_int32_s(&dctDeQ[0],pCur,stride);
                        }
                     }
                  }
               }
               else{
                  if(mb->iIs4x4){
                     //x4idct_fnc_dc128(&dctDeQ[0],co);
                     deQ<1,0>(&dctQ[0],&dctDeQ[0],t,co,1);
                     void t_idct8_s_put(DCT_TYPE *t, unsigned char *dst, int stride);
                     t_idct8_s_put(&dctDeQ[0],pCur,stride);

                  }
                  else{
                     deQ<2,0>(&dctQ[0],&dctDeQ[0],t,co);
                     ::idct_fnc_dc128(&dctDeQ[0],co);
                     this->copy_16_8(&dctDeQ[0],pCur,stride);
                  }
               }

            
            
         }
         else if(sum && !iIsB)
            x_dif(NULL,pCur,pRef,stride);
         else if(!sum && !mb->iIsDif && !iIsB)
            x_dif(NULL,pCur,pRef,stride);
         
         

         
         
         if(iCanRestore)
         {
            if(iUsePsnr){
               if(mb->iIs4x4==2 && 0){
                  int psnr[4];
                  int iBlocksEnc=4;
                  int iPsnrDif;
#define PSNR_CHK(_ID, _FRBL, _FRD, _OFS)\
                  psnr[_ID]=getBlockPSNR(pCur+(_OFS),pRef+(_OFS),4,4,stride,3);\
                  iPsnrDif=psnr[_ID]-s_psnr[_ID];\
                  if(psnr[_ID]==s_psnr[_ID])iBlocksEnc--;\
                  else if(s_psnr[_ID]*9>psnr[_ID]*8 || iPsnrDif<300){\
                     putBlock4(&saved[_FRBL],pCur+(_OFS),stride);\
                     iBlocksEnc--;\
                     memset(&dctQ[_FRD],0,16*sizeof(DCT_TYPE));\
                  }

                  PSNR_CHK(0,   0, 0,0)
                  PSNR_CHK(1,   4,16,12)
                  PSNR_CHK(2,  32,32,stride*4)
                  PSNR_CHK(3,32+4,48,12+stride*4)

                  if(iBlocksEnc==0)return 0;
                  else return sum;
               }
               else {
                  int psnr=getBlockPSNR(pCur,pRef,TVAL_8,TVAL_8,stride,3);
                  //if(mb->iStartPsnr*6>psnr*5){
                  //if(mb->iStartPsnr*10>psnr*9){
                  int iPsnrDif=psnr-mb->iStartPsnr;
                  if(iPsnrDif>200+iIsB*150){
                  }
                  else if(mb->iStartPsnr*9>psnr*8 || (psnr<2700 && mb->iStartPsnr*4<psnr*3) || iPsnrDif<150+iIsB*90){
                     mb->iQuantCoefSum=0;
                     putBlock(&saved[0],pCur,stride);
                     mb->iSkip=1;mb->iCoefsQuant=-5;
                     mb->iCanRestore=2;
                     //debugss("rest ok",psnr-mb->iStartPsnr,mb->iMaxCoef);
                     if(mb->iStartPsnr<iSStartSkipedPsnr[0])iSStartSkipedPsnr[0]=mb->iStartPsnr;
                     iRndN=iRndNO;
                     mb->iMaxCoef=-1000-iPsnrDif;
                     return 0;
                  }
               }
               if(mb->iStartPsnr>iBSendPsnr[0])iBSendPsnr[0]=mb->iStartPsnr;
               mb->iCanRestore=0;
              // debugss("rest !ok",psnr-mb->iStartPsnr,mb->iMaxCoef);
            }
            else{
            //int iEncBits=iPass==7?-1:mb->iEncBits;
            int iSadAfter=sadGainUU(pCur,pRef,stride,t_d1);
            int iSadGain=mb->iDifSad-iSadAfter;
            int iE=(100*mb->iDifSad/(iSadAfter+1))-100;
            if(iSadGain>128 || iE>20)// && iSadGain>64*6)//g>64*20 || (g>80 && mb->iCoefsQuant<3))//((dctQ[0]==0 && sum<6)|| mb->iCoefsQuant<3)))// ||(iEncBits>=0 && iEncBits<10)))
            {
            }
            else
            {
               //int eM=iIsB?10:6;
               if(iSadGain<12 || iE<5)// || ((iSadGain+4)*4>mb->iDifSad && mb->iDifSad<mb->iPicMean))// || (g<120 && iEncBits>40) || (g<80 && iEncBits>32))
               //if(mb->iDifSad<iSadGain*2)
               {
                 // debugss("restored",mb->iIs4x4,mb->iDifSad);
                  mb->iQuantCoefSum=0;
                  putBlock(&saved[0],pCur,stride);
                  mb->iSkip=1;mb->iCoefsQuant=-5;
                  iRndN=iRndNO;
                  //if(!sum)mb->iIsDif=1;
                  return 0;
               }

               
            }
            }
            
         }
         
         //x_dif(NULL,pCur,pRef,stride);

        // if(!iIsB)mb->cnt=0;
         
         return 1;
      }
      return sum>0 || !mb->iIsDif;
   }
   inline int clip255(int a){if(a<=0)return 0; if(a>255)return 255;return a;}
   int setBestPred(unsigned char *pC,int stride, int iP, int iGetDc=0)
   {
      //if(iGetDc)return 128;
     // predict_8x8_xdc(128,pC,stride,0);
     // return 128;
      /*
      if(iP==5)
      {
         if(iGetDc)return 128;
         predict_8x8_xdc(128,pC,stride,0);
         return 128;
      }
      */
      //iP-=4;
      int dcx[8];
      int dct;
      int dcl;
      dcl=iCurBl>0?get_8x8_dc_left(pC,stride,0):-1;
      dct=iCurBl>=iBlStride?get_8x8_dc_top(pC,stride,0):-1;
      if(dcl==-1 && dct==-1)
      {
         dcl=192;dct=64;
      }
      else if(dcl==-1)dcl=(dct>128)?64:192;
      else if(dct==-1)dct=(dcl>128)?64:192; 
      else if(mmabs(dct-dcl)<16)
      {
         dct=clip255(8+dct);
         dcl=clip255(dcl-8);
      }
      int avg=((dct+1+dcl)>>1);

      dcx[0]=avg;//((dct+1+dcl)>>1);
      dcx[1]=dct;
      dcx[2]=dcl;
      dcx[3]=//(dcx[2]+256)>>1;//
         clip255(dct*2-dcl);
      dcx[4]=//(dcx[2]+1)>>1;;//
          clip255(dcl*2-dct);

      //dcx[3]=mmabs(med-clip255(dct*2-dcl));
      //dcx[4]=mmabs(med-clip255(dcl*2-dct));
      if(iGetDc)return dcx[iP];
      predict_8x8_xdc(dcx[iP],pC,stride,0);
      if(0 && iCurBl>0 && iCurBl>=iBlStride)
      {
         void t_loop_pred(unsigned char *pix, int xstride, int ystride);
         t_loop_pred(pC,stride,3);
         t_loop_pred(pC,3,stride);

      }
      return dcx[iP];

   }
   int getBestPred(unsigned char *pC,int stride, int med, int &dc)
   {
      //return 7;
//      return 0;
      int dcx[8];
      int dct;
      int dcl;
      dcl=iCurBl>0?get_8x8_dc_left(pC,stride,0):-1;
      dct=iCurBl>=iBlStride?get_8x8_dc_top(pC,stride,0):-1;
      if(dcl==-1 && dct==-1)
      {
         dcl=192;dct=64;
      }
      else if(dcl==-1)dcl=(dct>128)?64:192;
      else if(dct==-1)dct=(dcl>128)?64:192; 
      else if(mmabs(dct-dcl)<16)
      {
         dct=clip255(8+dct);
         dcl=clip255(dcl-8);
      }
      int avg=((dct+1+dcl)>>1);
      
      dcx[0]=(mmabs(avg-med)*3+2)>>2;
      dcx[1]=mmabs(med-dct);
      dcx[2]=mmabs(med-dcl);
      dcx[3]=mmabs(med-clip255(dct*2-dcl));
      dcx[4]=mmabs(med-clip255(dcl*2-dct));
        // dcx[5]=mmabs(128-med);;
/*
         dcx[3]=mmabs(med-(dct*2-dcl));
         dcx[4]=mmabs(med-(dcl*2-dct));
         dcx[5]=mmabs(med-((dct*3+dcl+2)>>2));
         dcx[6]=mmabs(med-((dcl*3+dct+2)>>2));
         dcx[7]=mmabs(128-med);;
*/
      int iMin=0;
      int i;
      for(i=1;i<3;i++)if(dcx[i]<dcx[iMin])iMin=i;

         //if(dcx[1]<dcx[iMin])iMin=1;
         //if(dcx[2]<dcx[iMin])iMin=2;
         //iPredRet=iMin+8;
         dc=dcx[iMin];
         return iMin;

   }
   int calcPred(unsigned char *pCur, unsigned char *pRef, int stride,int &ret)
   {
      int sads[6]={0,0,0,0,0,0};
      int dc=0;
      int dcu=0,dcl=0;
      int ix3,i,j;
      ret=0;
      for(i=0;i<8;i++){dcu+=pCur[i*3-stride];dcl+=pCur[i*stride-3];}
      dc=dcu+dcl;
      dcl=(dcl+4)>>3;dcu=(dcu+4)>>3;
      dc=(dc+8)>>4;
      unsigned char *old=pCur;
      for(j=0;j<8;j++){
         for(i=0;i<8;i++){
            ix3=i*3;
            //pCur[ix3]=((int)old[ix3-stride]*(7-j) + dc*(1+j)+dc*(1+i)+(int)old[i*stride-3]*(7-i)+8)>>4;//530
            //--pCur[ix3]=((int)old[ix3-stride]*(7-j) + dc*(2+j+i)+(int)old[j*stride-3]*(7-i)+8)>>4;//530
            sads[0]+=mmabs((int)pRef[ix3]-dc);//530
            sads[1]+=mmabs((int)pRef[ix3]-(((int)dcl*(1+i)+(int)old[j*stride-3]*(7-i)+4)>>3));//530
            sads[2]+=mmabs((int)pRef[ix3]-(((int)old[ix3-stride]*(7-j) + dcu*(1+j)+4)>>3));//530
            sads[3]+=mmabs((int)pRef[ix3]-(((int)old[ix3-stride]*(7-j) + dc*(2+j+i)+(int)old[j*stride-3]*(7-i)+8)>>4));//530
//            sads[4]+=mmabs((int)pRef[ix3]-(((int)dc*(1+i)+(int)old[j*stride-3]*(7-i)+4)>>3));//530
  //          sads[5]+=mmabs((int)pRef[ix3]-(((int)old[ix3-stride]*(7-j) + dc*(1+j)+4)>>3));//530
            sads[4]+=mmabs((int)pRef[ix3]-(((int)old[j*stride-3])));//530
            sads[5]+=mmabs((int)pRef[ix3]-(((int)old[ix3-stride])));//530
         }
         pCur+=stride;
         pRef+=stride;
      }
      for(i=1;i<6;i++){
         if(sads[ret]>sads[i])ret=i;
      }
      return sads[ret];
   }
   int setPred(unsigned char *pCur, unsigned char *pRef, int stride, int iCalcDc,int &ret){
      int i,j;//,sad=0;
      int dc=128;
      //int sads[4]={0,0,0,0};
      
      if(iCalcDc && ret!=6){
         dc=0;
         //int dcu=0,dcl=0;
         int dcl=0,dcu=0;
         for(i=0;i<8;i++){dcu+=pCur[i*3-stride];dcl+=pCur[i*stride-3];}
         dc=dcu+dcl;
         dcl=(dcl+4)>>3;dcu=(dcu+4)>>3;
         dc=(dc+8)>>4;
         //dcu=(dcu+4)>>3;  //dcl=(dcl+4)>>3;
         unsigned char *old=pCur;
         /*
         for(j=0;j<8;j++){
            for(i=0;i<24;i+=3){
               dc+=old[i];
            }
            old+=stride;
         }
         dc=(dc+32)>>6;
         */

         int ix3;
         old=pCur;
         /*
         if(pRef){
            
            for(j=0;j<8;j++){
               for(i=0;i<8;i++){
                  ix3=i*3;
                  //pCur[ix3]=((int)old[ix3-stride]*(7-j) + dc*(1+j)+dc*(1+i)+(int)old[i*stride-3]*(7-i)+8)>>4;//530
                  //--pCur[ix3]=((int)old[ix3-stride]*(7-j) + dc*(2+j+i)+(int)old[j*stride-3]*(7-i)+8)>>4;//530
                  sads[0]+=mmabs((int)pRef[ix3]-dc);//530
                  sads[1]+=mmabs((int)pRef[ix3]-(((int)dcl*(1+i)+(int)old[j*stride-3]*(7-i)+4)>>3));//530
                  sads[2]+=mmabs((int)pRef[ix3]-(((int)old[ix3-stride]*(7-j) + dcu*(1+j)+4)>>3));//530
                  sads[3]+=mmabs((int)pRef[ix3]-(((int)old[ix3-stride]*(7-j) + dc*(2+j+i)+(int)old[j*stride-3]*(7-i)+8)>>4));//530
               }
               pCur+=stride;
               pRef+=stride;
            }
            //sads[ret]*=31;sads[ret]>>=5;
            for(i=1;i<4;i++){
               if(sads[ret]>sads[i])ret=i;
            }
            pCur=old;
         }
         */
         for(j=0;j<8;j++){
            for(i=0;i<8;i++){
               ix3=i*3;
               //pCur[ix3]=((int)old[ix3-stride]*(7-j) + dc*(1+j)+dc*(1+i)+(int)old[i*stride-3]*(7-i)+8)>>4;//530
               //--pCur[ix3]=((int)old[ix3-stride]*(7-j) + dc*(2+j+i)+(int)old[j*stride-3]*(7-i)+8)>>4;//530
               if(ret==0)pCur[ix3]=dc;//530
               else if(ret==1)pCur[ix3]=((((int)dcl*(1+i)+(int)old[j*stride-3]*(7-i)+4)>>3));//530
               else if(ret==2)pCur[ix3]=((((int)old[ix3-stride]*(7-j) + dcu*(1+j)+4)>>3));//530
               else if(ret==3)pCur[ix3]=((((int)old[ix3-stride]*(7-j) + dc*(2+j+i)+(int)old[j*stride-3]*(7-i)+8)>>4));//530
               else if(ret==4)pCur[ix3]=((((int)old[j*stride-3])));//530
               else if(ret==5)pCur[ix3]=((((int)old[ix3-stride])));//530
//               else if(ret==4)pCur[ix3]=((((int)dc*(1+i)+(int)old[j*stride-3]*(7-i)+4)>>3));//530
  //             else if(ret==5)pCur[ix3]=((((int)old[ix3-stride]*(7-j) + dc*(1+j)+4)>>3));//530

            }
            pCur+=stride;
         }
      }
      else{
         for(j=0;j<8;j++){
            for(i=0;i<24;i+=3){
               pCur[i]=dc;
            }
            pCur+=stride;
         }
      }
      return ret;//sads[ret];

   }   
   
   int c_dif(DCT_TYPE *p, unsigned char *pCur, unsigned char *pRef, int stride, int &iPredRet, int ij, int flag){
      int i,j,sadD=0,sadP=0;
      int pic[64],x=0;
      int pico[64];
      int m=0;
      //iPredRet=0;
      unsigned char *pC=pCur;
      unsigned char *pR=pRef;
      DCT_TYPE ipR;
      DCT_TYPE ipC;
      int iSadDC=0;
      for(j=0;j<TVAL_8;j++){
         for(i=0;i<TVAL_24;i+=3){
            ipR=pRef[i];ipC=pCur[i];
            *p=(ipR-ipC);
            iSadDC+=*p;
            //p[0]*=2;
            if(*p<0){if(-(*p)>m)m=-(*p);sadD-=*p;}else{ if(*p>m)m=*p;sadD+=*p;}
            
            sadP+=ipR;pic[x]=ipR;pico[x]=ipC;x++;
            p++;
         }
         pCur+=stride;
         pRef+=stride;
      }
      int med=(sadP+TVAL_DCTH)>>TVAL_SH6;
      /*
      if(0|| (sadP<16 && sadD>256))
      {
         int dcx;

         //iPredRet=getBestPred(pC,stride,med,dcx);
         return 0x7fff;
      }
      */
      
      if(iIsB){sadD-=32;}
      if(m<3 || sadD<12)return 0;
      if(ij==-2)return sadD;
      if(sadD<128)return sadD;

//return sadD;
      int dMed=iSadDC/TVAL_DCT_SZ;

      int iSadDM=0;
      p-=TVAL_DCT_SZ;
      //iSadDM+=0x7fff;
      int sadM=0;
      for(i=0;i<TVAL_DCT_SZ;i++,p++){
         if(med>pic[i])sadM+=(med-pic[i]);else sadM+=(pic[i]-med);
         iSadDM+=mmabs((*p)-dMed);
      }
      if(sadM<32 && iSadDM>TVAL_DCT_SZ*6)return 0x7fff;
      if(sadD<TVAL_DCT_SZ*40 && sadM>iSadDM)return sadD;
     // return 0x7fff;
      if(sadD<TVAL_DCT_SZ*30 && (sadD<sadM+TVAL_DCT_SZ || (sadM+TVAL_DCT_SZ*2>iSadDM && iSadDM<TVAL_DCT_SZ*8)))return sadD;


      //-------
      //iPredRet=0;
//      int iS;
      sadP=0x7fff;
      int iSetPred=1;
     // ij=0;
      if(0)//ij==0)
      {
         iSetPred=0;
         iPredRet=5;
         //fncPred[iPredRet](pC,stride,flag);
         predict_8x8_xdc(128,pC,stride,flag);
         sadP=sadM;//sadF(pC,&pic[0],stride,sadP);
      }
      else{
         
         iSetPred=0;
//         int dcx;
         //iPredRet=getBestPred(pC,stride,med,dcx);
         //predict_8x8_xdc(128,pC,stride,flag);

         //fncPred[iPredRet](pC,stride,flag);
         //predict_8x8_xdc(dcx,pC,stride,flag);
         //setBestPred(pC,stride,iPredRet);
         sadP=sadM;//sadP=sadF(pC,&pic[0],stride,sadP);

         /*
         for(i=sadM<256 || m<6?8:0;i<12;i++){
        // for(i=0;i<7;i++){
            fncPred[i](pC,stride,flag);
           // setPred(pC,NULL,stride,ij,iPredRet);
            //iS=sadF(pC,pR,stride);
            iS=sadF(pC,&pic[0],stride,sadP);
            if(i<8){iS*=65;iS>>=6;}
            //if(i==8 && sadP>64*8){sadP=iS;iPredRet=8;}
            //if(i<8){iS*=65;iS>>=6;}
            if(i==11){iS+=100;iS*=2;}
            if(iS<sadP){sadP=iS;iPredRet=i;}
           // if(ij==0)break;
         }
         */
         //
      }

      //return 0x7fff;

      if(0x7fff==sadM){
        // if(iPredRet!=11 && iSetPred)
          //  fncPred[iPredRet](pC,stride,flag); 
         return 0x7fff;
      }
      //return 0x7fff;

      if(sadP+128>iSadDM && sadM+32>sadD && sadD<64*32){// -m-16 && (sadP+10)*3>sadD){
         if(sadP+64>iSadDM){
            x=0;
            /*
            for(j=0;j<8;j++){
               for(i=0;i<24;i+=3){
                  pC[i]=pico[x];x++;
               }
               pC+=stride;
            }
            */
            return sadD;
        }
      }
      //if(iPredRet!=-1){
        // if(iPredRet!=11 && ij && iSetPred)//setPred(pC,NULL,stride,ij,iPredRet);//
          //    fncPred[iPredRet](pC,stride,flag);
         return 0x7fff;
   }
   static inline void getBlock(DCT_TYPE *p,unsigned char *pRef, int stride){
      int j;
      for(j=0;j<TVAL_8;j++){
         //for(i=0;i<TVAL_24;i+=3)
         p[0]=(DCT_TYPE)pRef[0];
         p[1]=(DCT_TYPE)pRef[3];
         p[2]=(DCT_TYPE)pRef[6];
         p[3]=(DCT_TYPE)pRef[9];
         p[4]=(DCT_TYPE)pRef[12];
         p[5]=(DCT_TYPE)pRef[15];
         p[6]=(DCT_TYPE)pRef[18];
         p[7]=(DCT_TYPE)pRef[21];
         p+=8;

         pRef+=stride;
      }
   }
   static inline void getBlock16(unsigned char *p,unsigned char *pRef, int stride){
      int j;
      stride-=24;
      for(j=0;j<16;j++){
         //for(i=0;i<TVAL_24;i+=3)
         p[0]=(unsigned char)pRef[0];
         p[1]=(unsigned char)pRef[3];
         p[2]=(unsigned char)pRef[6];
         p[3]=(unsigned char)pRef[9];
         p[4]=(unsigned char)pRef[12];
         p[5]=(unsigned char)pRef[15];
         p[6]=(unsigned char)pRef[18];
         p[7]=(unsigned char)pRef[21];
         p+=8;pRef+=24;
         p[0]=(unsigned char)pRef[0];
         p[1]=(unsigned char)pRef[3];
         p[2]=(unsigned char)pRef[6];
         p[3]=(unsigned char)pRef[9];
         p[4]=(unsigned char)pRef[12];
         p[5]=(unsigned char)pRef[15];
         p[6]=(unsigned char)pRef[18];
         p[7]=(unsigned char)pRef[21];
         p+=8;

         pRef+=stride;
      }
   }
   static inline void putBlock4(DCT_TYPE *p, unsigned char *pCur, int stride){
      for(int j=0;j<4;j++){
         pCur[0]=p[0];
         pCur[3]=p[1];
         pCur[6]=p[2];
         pCur[9]=p[3];
         p+=8;
         pCur+=stride;
      }

   }
   static inline void putBlock(DCT_TYPE *p, unsigned char *pCur, int stride){
      int j;
      for(j=0;j<TVAL_8;j++){
         //for(i=0;i<TVAL_24;i+=3)
         pCur[0]=p[0];
         pCur[3]=p[1];
         pCur[6]=p[2];
         pCur[9]=p[3];
         pCur[12]=p[4];
         pCur[15]=p[5];
         pCur[18]=p[6];
         pCur[21]=p[7];
         p+=8;

         pCur+=stride;
      }
   }
   static inline void putBlock16(unsigned char *p, unsigned char *pCur, int stride){
      int j;
      stride-=24;
      for(j=0;j<16;j++){
         //for(i=0;i<TVAL_24;i+=3)
         pCur[0]=p[0];
         pCur[3]=p[1];
         pCur[6]=p[2];
         pCur[9]=p[3];
         pCur[12]=p[4];
         pCur[15]=p[5];
         pCur[18]=p[6];
         pCur[21]=p[7];
         pCur+=24;
         p+=8;
         pCur[0]=p[0];
         pCur[3]=p[1];
         pCur[6]=p[2];
         pCur[9]=p[3];
         pCur[12]=p[4];
         pCur[15]=p[5];
         pCur[18]=p[6];
         pCur[21]=p[7];
         p+=8;

         pCur+=stride;
      }
   }

   static inline void a_dif(DCT_TYPE *p, unsigned char *pCur, int stride){
      int j;
//      DCT_TYPE v;
      for(j=0;j<TVAL_8;j++){
//#define F_D(_ID, _ID3) pCur[_ID3]=s_cropTbl[p[_ID]+(DCT_TYPE)pCur[_ID3]];p++;
#define F_D(_ID, _ID3) pCur[_ID3]=s_cropTbl[p[0]+(DCT_TYPE)pCur[_ID3]];p++;
//#define F_D(_ID, _ID3) pCur[_ID3]=p[0]+(DCT_TYPE)pCur[_ID3];p++;
         //if(v>255)pCur[_ID3]=255;  else if(v<0)pCur[_ID3]=0;  else pCur[_ID3]=v;
         F_D(0,0);F_D(1,3);F_D(2,6);;F_D(3,9);
         F_D(4,12);F_D(5,15);F_D(6,18);F_D(7,21);
         //p+=8;
         pCur+=stride;
      }
#undef F_D

   }
   static inline void copy_16_8(DCT_TYPE *p, unsigned char *pCur, int stride){
      int j;
      //DCT_TYPE v;
#define F_D(_ID, _ID3) pCur[_ID3]=p[0];p++;
      //if(v>255)pCur[_ID3]=255;  else if(v<0)pCur[_ID3]=0;  else pCur[_ID3]=v;
      for(j=0;j<TVAL_8;j++){
         F_D(0,0);F_D(1,3);F_D(2,6);;F_D(3,9);
         F_D(4,12);F_D(5,15);F_D(6,18);F_D(7,21);
         //p+=8;
         pCur+=stride;
      }
#undef F_D
   }
   static inline void copy_16_8_avg_lost_y(DCT_TYPE *p, unsigned char *pCur, int stride){
      int j;
      //DCT_TYPE v;
#define F_D(_ID, _ID3) pCur[_ID3]=(p[0]+pCur[_ID3]+1)>>1;p++;
      //if(v>255)pCur[_ID3]=255;  else if(v<0)pCur[_ID3]=0;  else pCur[_ID3]=v;
      for(j=0;j<TVAL_8;j++){
         F_D(0,0);F_D(1,3);F_D(2,6);;F_D(3,9);
         F_D(4,12);F_D(5,15);F_D(6,18);F_D(7,21);
         //p+=8;
         pCur+=stride;
      }
#undef F_D
   }
   static inline void a_dc_dif(DCT_TYPE *p, unsigned char *pCur, int stride,const int dc){
      int j;
//      DCT_TYPE v;
      /*
      for(j=0;j<TVAL_8;j++){
         for(i=0;i<TVAL_24;i+=3){
            v=p[0]+dc;
            if(v>255)pCur[i]=255;
            else if(v<0)pCur[i]=0;
            else pCur[i]=v;
           // 
            p++;
         }
         pCur+=stride;
      }
      */

#define F_D(_ID, _ID3) pCur[_ID3]=s_cropTbl[p[_ID]+dc];//???
      //iespejams dc var pieskaitiit dc coefam
      //#define F_D(_ID, _ID3) pCur[_ID3]=p[0]+dc;p++;
      //if(v>255)pCur[_ID3]=255;  else if(v<0)pCur[_ID3]=0;  else pCur[_ID3]=v;
      for(j=0;j<TVAL_8;j++){
         F_D(0,0);F_D(1,3);F_D(2,6);;F_D(3,9);
         F_D(4,12);F_D(5,15);F_D(6,18);F_D(7,21);
         //p+=8;
         pCur+=stride;
      }
#undef F_D

   }
   void filter(unsigned char *pCur, int stride, int iTop, int iLeft, int k)
   {
      void filterX(unsigned char *p, int stride, int idx, int sz);
      //if(k==2 && !iLeft && !iTop)filterX(pCur-2,stride,20,8);
      void filter_4x4_center(unsigned char *p, int stride, int idx);
      //if(k==2)filter_4x4_center(pCur-2,stride,16);
      return;
     // void fillterBlock(unsigned char *pic, int stride);
      //void fillterBlock8(unsigned char *pic, int stride, int q);
      //int q=(105-iQVal)*2;
       //if(!iLeft && !iTop)fillterBlock8(pCur,stride,iQVal);
      //vajadzeetu  - bottom and right ja nav blakus bloki
      //if(!iTop)fillterBlock(pCur+3*4,stride);
      //if(!iLeft)fillterBlock(pCur+stride*4,stride);
      //fillterBlock(pCur+3*4+stride*4,stride);
   }
   static inline void x_dif(DCT_TYPE *p, unsigned char *pCur, unsigned char *pRef, int stride){
      int j;
      for(j=0;j<TVAL_8;j++){
         pCur[0]=pRef[0];
         pCur[3]=pRef[3];
         pCur[6]=pRef[6];
         pCur[9]=pRef[9];
         pCur[12]=pRef[12];
         pCur[15]=pRef[15];
         pCur[18]=pRef[18];
         pCur[21]=pRef[21];
         pCur+=stride;
         pRef+=stride;
      }
   }
   //ff_alternate_h_scan
   int *pTab;
   inline int enc(DCT_TYPE *v, int *p, int k, int iAdd)
   {
      pTab=(int*)&ZIG_ZAG_TAB[0];
      return encR(v,p,k,iAdd);
      /*
      if(iAdd==2)
      {
         return encR(v,p,k,iAdd);
      }
      int l[4];
      l[0]=1;//encT(v,&ZIG_ZAG_TAB[0])-2;
      int iMin=0;
      if(0)//l[0]>0)
      {
         l[1]=encT(v,&ff_alternate_v_scan[0]);
         l[2]=encT(v,&ff_alternate_h_scan[0]);
         l[3]=encT(v,&tabzz4x4_second[0]);

         if(l[1]<l[0])iMin=1;
         if(l[2]<l[iMin])iMin=2;
         if(l[3]<l[iMin])iMin=3;
      }
      if(iMin==0)
         pTab=(int*)&ZIG_ZAG_TAB[0];
      else if(iMin==1)
         pTab=(int*)&ff_alternate_v_scan[0];
      else if(iMin==2)
         pTab=(int*)&ff_alternate_h_scan[0];
      else if(iMin==3)
         pTab=(int*)&tabzz4x4_second[0];
      p[0]=iMin;

      return encR(v,p+1,k,iAdd)+1;
      */
   }
   inline int encT(DCT_TYPE *v, const int *t){
      int cnt=0;
      int i;
      for(i=0;i<TVAL_DCT_SZ;i++){
         if(v[t[i]])cnt=i;
      }
      return cnt;
   }
   static inline int zeroCnt(DCT_TYPE *zv, int *zz, int frm=0, int cnt=TVAL_DCT_SZ){
      int z=0;
      int x=frm;
      int iLast=0;
      for(;x<cnt;x++){
         if(!zv[zz[x]]){z++;}else iLast=z;
      }
      return iLast;
   }
   //get_rl_index
#if 0
   inline int enc8x(DCT_TYPE *v, short *p, int k, int iAdd)
   {
      int val,i;
      int *xTab=(int*)&ZIG_ZAG_TAB[0];
      int cnt;
      int iLast=0;
      for(i=0;i<TVAL_DCT_SZ;i+=8){
         cnt=notZeros(v,xTab,i,i+8);
         if(cnt)iLast=(i>>3)+1;
      }
      int iCur=0;

      vlc.addB(iAdd!=1,(unsigned char*)&bufTmp[0]);
      if(iAdd!=1)
      {
         vlc.addB(iAdd==2,(unsigned char*)&bufTmp[0]);
         if(iAdd==2)
         {
            return  0;
         }
      }

      for(i=0;i<TVAL_DCT_SZ;i++)
      {
         val=v[xTab[i]];
         if(i==0)
         {
            if(val==2)val=0;
            else if(val==-2)val=1;
            else if(val==1)val=-2;
            else if(val==0)val=2;
         }
         if(val)
         {
            vlc.addB(1,(unsigned char*)&bufTmp[0]);
            if(val==-1)
            {
               vlc.addB(1,(unsigned char*)&bufTmp[0]);
               vlc.addB(1,(unsigned char*)&bufTmp[0]);
            }
            else if(val==1)
            {
               vlc.addB(1,(unsigned char*)&bufTmp[0]);
               vlc.addB(0,(unsigned char*)&bufTmp[0]);
            }
            else
            {
               val=val<0?-val*2-1:val*2;
               val-=2;
               vlc.toAC_val((unsigned char*)&bufTmp[0],val);
            }
         }
         else vlc.addB(0,(unsigned char*)&bufTmp[0]);

         if((i&7)==7){
            iCur++;
            if(iCur==iLast)
            {
               vlc.addB(0,(unsigned char*)&bufTmp[0]);
               break;
            }
            vlc.addB(1,(unsigned char*)&bufTmp[0]);
         }
         

         
         
         //p[i]=val;
      }
      return 0;
   }

   inline int enc4x4(DCT_TYPE *v, short *p, int k, int iAdd)
   {
      int i,j,l=0;
      short *old=p;
      int x=0;
      int iLastIs1=0;
      //int iCanNotDiv2=;
      do{
         if(iAdd==2)
         {
            p[0]=2;
            l=1;
            break;
         }
         int o[4];
         o[0]=v[0];o[1]=v[16];o[2]=v[32];o[3]=v[48];
         
         //dst[1]=v[16]-v[0];
         //dst[2]=v[32]-((v[0]+v[16]+1)>>1);
         //dst[3]=v[48]-((v[32]+v[0]*2+v[16]+2)>>2);
         if(1){
         v[16]=o[1]-o[0];
         v[32]=o[2]-((o[0]+o[1]+1)>>1);
         v[48]=o[3]-((o[1]+o[2]+1)>>1);
         }
         int iDCEqual=v[0]==v[32] && v[0]==v[48] && v[0]==v[16] ;
         //int dc=(o[0]+o[1]+o[2]+o[3])/4;
         //vlc.toAC_val((unsigned char*)&bufTmp[0],dc>=0?dc*2:-dc*2-1);
         //v[0]-=dc;v[16]-=dc;v[32]-=dc;v[48]-=dc;
//tabzz4x4_second
        // int *xTab=k==0?(int*)&ZIG_ZAG_TAB[0]:(int*)&tabzz4x4_second[0];
         int *xTab=(int*)&ZIG_ZAG_TAB[0];//:(int*)&tabzz4x4_second[0];

         p[0]=iAdd==1?0:1;
         short *pVal=p+1;
         //int c=v[0];
         v[0]-=iPrevDc[k];

         p[1]=notZeros(v,xTab,0,16);
         p[2]=notZeros(v,xTab,16,32);
         p[3]=notZeros(v,xTab,32,48);
         p[4]=notZeros(v,xTab,48,64);
         
         
         
         
         
        
         l=5;
         p+=5;
         int iMax;
         
         //T_TRASF_Y
         
         for(j=0;j<64;j+=16){
            for(iMax=0,i=0;i<16 && iMax<pVal[(j>>4)];i++){
              l++;
#if 1
              p[x]=v[xTab[i+j]];
              if(p[x])iMax++;
//if(i==0){img2[iEncValues]=mmabs(p[i+j]);iEncValues++;}
              x++;
              /*
              if(iMax==pVal[(j<<4)])
              {
                 if(p[i+j]==1 || p[i+j]==-1)iLastIs1++;
                 break;
              }
              */
#else
               
               int len=0;
               while(v[xTab[i+j]]==0 && i<16){i++;len++;}
               if(i>=16)break;
               int val=v[xTab[i+j]];
               int iBits=0;
               iMax++;

               if(val<0){val=-val;}
               iSigns++;//ziime
               if(val<11)iBits=5+val;else {
                  iBits=calcB(val-10);
                  if(iBits>5)iBits=5;
               }
               int sv=(len<<4)|iBits;
               img2[iEncValues]=sv;iEncValues++;
               vlc.toAC_val((unsigned char*)&bufTmp[0],T_TRASF_Y[sv]);
               if(iBits<6)vlc.iBitPos+=iBits;
#endif
            }
         }
         v[0]=o[0];  v[16]=o[1];    v[32]=o[2];      v[48]=o[3];
            
      }while(0);
      vlc.toAritmDC_pred((unsigned char*)&bufTmp[0],old[0]);
      if(old[0]!=3)
      {
         int s=0;
         for(i=1;i<5;i++){
            if(old[i])
            {
               vlc.addB(1,(unsigned char*)&bufTmp[0]);
               vlc.toAC_val((unsigned char*)&bufTmp[0],old[i]-1);
            }
            else vlc.addB(0,(unsigned char*)&bufTmp[0]);
            //vlc.toAC_val((unsigned char*)&bufTmp[0],i==4 && s==0? old[i]-1:old[i]);
            //s+=old[i];
         }
         
         for(i=0;i<x;i++)
         {
            //vlc.toAC_val((unsigned char*)&bufTmp[0],old[i]>=0?old[i]:-old[i]);z
            int val=p[i];
            vlc.toAC_val((unsigned char*)&bufTmp[0],val>=0?val*2:-val*2-1);
//            iSigns++;
            //ja kodee dc tad nemt citu tab jo val parasti nav 1
         }
         
         //iSigns+=old[1]+old[2]+old[3]+old[4];
      }
      
      return l;

      //tabzz4x4
   }
   inline int enc4x(DCT_TYPE *zv, short *out, int k, int iAdd){
      int iOutPos=0;
      int x;
      int len=0;
      int v;
      //out[iOutPos]=iAdd;  iOutPos++;
      //int iFirst=1;
      int *xTab=(int*)&zzzff_zigzag_direct[0];
      const int *encTab=k?&uv_tab[0]:((iAdd==1)?&dif_tbl[0]:&non_dif_tbl[0]);
      //uv_tab
      //const int *decTab=(iAdd==1)?&tab_dec_dct[0]:&non_dif_d[0];

      //unsigned char o[64];
      /*
      if(iAdd!=1){
         //not dif skip
         vlc.toAritSignedValMaxUShort((unsigned char*)&bufTmp[0],iAdd==2?255:254);
         if(k==0)vlc.toAritSignedValMaxUShort((unsigned char*)&bufTmp[0],11-iPredGlob);
      }
      */
      //if(!k)return 0;
      //if(iAdd==1 || k)return 0;
      vlc.addB(iAdd!=1,(unsigned char*)&bufTmp[0]);
      x=0;
      
     // if(iAdd!=1)vlc.toAritmDC_pred((unsigned char*)&bufTmp[0],iPredGlob);
      if(iAdd==2){
         //out[iOutPos]=0x80;
         vlc.toAritSignedValMaxUShort((unsigned char*)&bufTmp[0],0);//encTab[(int)out[0]]);
         return 1;
      }
      //0123
      //4567
      //8901
      //2345
      int c=zv[0];
      //xTab=(int*)&tab4x4[0];
      if(iAdd!=1)
      {
         vlc.toAritSignedValMaxUShort((unsigned char*)&bufTmp[0],mmabs(c)+1);
         iSigns++;
         x=1;
         xTab++;
      }
      
      
      //else vlc.toAritSignedValMaxUShort(&o[0],iAdd==1?0:1); 
      
/*
      dccf[iCurBl][k]=c;
      if(0 && iAdd!=1){
         int upc=0;
         int leftc=0;
         if(iCurBl>=iBlStride)upc=dccf[iCurBl-iBlStride][k];
         if(iCurBl>0)leftc=dccf[iCurBl-1][k];

         int dcx[7];
         int iMinC=0;
         dcx[0]=0;
         dcx[2]=leftc;
         dcx[1]=upc;
         dcx[3]=(leftc+upc)/2;

         //For example, y can be one of: 
         //(A) y=0 (B) y=a (C) y=b (D) y=c (E) y=a+b-c (F) y=a+(b-c)/2 (G) y=b+(a-c)/2 (H) y=(a+b)/2 

         iMinC=0;
         int res=mmabs(zv[0]);
         for(x=0;x<4;x++){dcx[x]=zv[0]-dcx[x];if(mmabs(dcx[x])<res)iMinC=x;res=mmabs(dcx[x]);}

         vlc.toAritSignedValMaxUShort((unsigned char*)&bufTmp[0],3-iMinC);
         if(iMinC>0)
            zv[0]=dcx[iMinC];
      }
      
      x=0;
      
      if(iAdd!=1){
         int dd=zv[0]-iPrevDcT[k][iAdd!=1];
         
         if(mmabs(dd)<mmabs(zv[0]))//iAdd==0)
         {
           vlc.addB((unsigned char*)&bufTmp[0],1);
           vlc.toAritSignedValMaxUShort((unsigned char*)&bufTmp[0],mmabs(dd));
           iSigns++;
         }
         else{
            vlc.addB((unsigned char*)&bufTmp[0],0);
            vlc.toAritSignedValMaxUShort((unsigned char*)&bufTmp[0],mmabs(zv[0]));
            iSigns++;
         }
         iPrevDcT[k][iAdd!=1]=c;
         x++;
      }
     */

      int iEsc=0;
      //int iLastLen;
      //int iLastLev;
      /*
      if(iAdd!=1)
      {
         //vlc.toAritSignedValMaxUShort((unsigned char*)&bufTmp[0],
            
         vlc.addB((unsigned char*)&bufTmp[0],iAdd!=1);
         vlc.addB((unsigned char*)&bufTmp[0],iAdd!=1);
         vlc.addB((unsigned char*)&bufTmp[0],iAdd!=1);
         vlc.addB((unsigned char*)&bufTmp[0],iAdd!=1);
         vlc.addB((unsigned char*)&bufTmp[0],iAdd!=1);
         vlc.addB((unsigned char*)&bufTmp[0],iAdd!=1);
         vlc.addB((unsigned char*)&bufTmp[0],iAdd!=1);
         
         x++;
            
      }
      */
      for(;x<TVAL_DCT_SZ;)
      {
         while(x<TVAL_DCT_SZ && zv[*xTab]==0){len++;x++;xTab++;}
         if(x==TVAL_DCT_SZ)
         {
            if(iOutPos==0){
               //if(iFirst && iAdd)len++;
               out[iOutPos]=0x80;
               iEsc=1;
               iOutPos++;
            }
            break;
         }
         iEsc=0;

         v=zv[*xTab];x++;
         xTab++;



         /*
         out[iOutPos]=len;iOutPos++;
         out[iOutPos]=v;iOutPos++;
         out[iOutPos]=0;iOutPos++;
         */
         //>=128
         
         int vv=v<0?-v:v;//(v<0?(((-v)<<1)-1):((v<<1)));
         vv--;
         iSigns++;
  //       if(vv>iMaxLev)iMaxLev=vv;
//         if(len>iMaxLen)iMaxLen=len;
         if(len<16 && vv<4){ //7bit
            //int vvx=vv;
           // vv=len;
            //<64
            //??? 00lllrrr
           // iLastLen=len;
            //iLastLev=vv;
            //v++;

            vv<<=4;
            vv|=len;
            //vv<<=1;
            out[iOutPos]=(unsigned char)vv;
            iOutPos++;
            iEsc=2;
         }
         else{// >=7bit 
            //566
            //nevar buut 10000xx
            if(len==0 && (vv==4 || vv==5))
            {
               iEsc=2;
               out[iOutPos]=vv==4?0x88:0x89;
            }
            else if((len && !vv) || (!len && vv))
            {
               iEsc=6;
               out[iOutPos]=vv?(vv|0x40|0x80):(len|0x80);
            }
            else{
               if(len==1)
               {
                  if(vv==4)out[iOutPos]=0x82;
                  else if(vv==5)out[iOutPos]=0x83;
                  else if(vv==6)out[iOutPos]=0x84;
                  else {
                     out[iOutPos]=0x81;
                     iOutPos++;
                     out[iOutPos]=vv-4;
                  }
                  iEsc=2;
               }
               else if(vv==4)
               {
                  iEsc=2;
                  if(len==2)out[iOutPos]=0x85;
                  else if(len==3)out[iOutPos]=0x86;
                  else {
                     out[iOutPos]=0x87;
                     iOutPos++;
                     out[iOutPos]=len;
                  }
               }
               else 
               {
                     out[iOutPos]=0x88;
                     iOutPos++;
                     out[iOutPos]=vv;
                     iOutPos++;
                     out[iOutPos]=len;
                     iEsc=2;
               }
               /*
               out[iOutPos]=len<=15?0x81:(len<=31?0x82:0x83);
               iOutPos++;
               out[iOutPos]=((vv)<<4)|((len)&0x0f);
               */
               //iEsc=7;
            }
            iOutPos++;

         }


        // iFirst=0;

         len=0;
      }
      zv[0]=c;
      //if(iEsc==2)iMaxLev++;
      //if(iEsc==3)iMaxLen++;
      //out[iOutPos-1]|=(0x80);
      //if(iEsc!=1)iEsc=0;
      //if(iEsc==1){out[iOutPos-1]=15;}
      if(iEsc==7){out[iOutPos-1]|=0x80;}
      else if(iEsc==6){out[iOutPos]=0x80;iOutPos++;}
      else if(iEsc==5)out[iOutPos-1]|=1;
      else if(iEsc==3|| iEsc==2)out[iOutPos-1]|=0x40;
      else if(iEsc==4){out[iOutPos-1]|=0x20;}

      for(x=0;x<iOutPos;x++)vlc.toAC_val((unsigned char*)&bufTmp[0],encTab[out[x]]);
            //for(i=0;i<iEncValues;i++)img[i]=tab_enc_dct[(int)img2[i]+128];
            //vlc.toAritSignedValMaxUShort(pOut+iLen*4,iMin);
            //for(i=0;i<iEncValues;i++)vlc.toAritSignedValMaxUShort(pOut+iLen*4,img[i]);//-iMin);
            //img[i]=img[i]&1?(-(img[i]>>1)):(img[i]>>1);}

      return iOutPos;

   }
   inline int calcB(int v){
      int l=1;
      const int t[]={2,6,14,30,62,126,254};
      int *tp=(int*)&t[0];
      while(v>tp[0]){tp++;l++;}
      return l;
   }   
   int enc5x(DCT_TYPE *zv, short *out, int k, int iAdd){

      int iOutPos=0;
      int *xTab=(int*)&zzzff_zigzag_direct[0];
      //xTab=(int*)&tabzz4x4[0];
      vlc.addB(iAdd!=1,(unsigned char*)&bufTmp[0]);
      int x=0;
      int *encTab=(int *)(k?&tab5x_uv[0]:&tab5x[0]);
      //if(k==0)return 0;
      
     // if(iAdd!=1)vlc.toAritmDC_pred((unsigned char*)&bufTmp[0],iPredGlob);
      if(iAdd==2){
         //out[iOutPos]=0x0f;
         vlc.toAritSignedValMaxUShort((unsigned char*)&bufTmp[0],0);//encTab[(int)out[0]]);
         return 0;
      }
      if(iAdd!=1)
      {
         //int c=zv[*xTab]; c=c<=0?(-c*2):(c*2-1);c++;
         //vlc.toAritSignedValMaxUShort((unsigned char*)&bufTmp[0],c);
         vlc.toAritSignedValMaxUShort((unsigned char*)&bufTmp[0],mmabs(zv[*xTab])+1);
         iSigns++;
         x=1;
//         xTab++;
      }
      int len=0;
      int val;
      int iLast=0;
      int retLen=0;
      int iRetLast=0;
      //int tmpOut[64];
      int sv;
      int iPrevBits=2;
      for(;x<64;x++){
         len=0;
         /*
         while(zv[*xTab]==0 && x<64 && len<15){xTab++;x++;len++;}
         if(x>=64)break;
         val=zv[*xTab];
         x++;xTab++;
         */
         while(zv[xTab[x]]==0 && x<TVAL_DCT_SZ && len<15){x++;len++;}
         if(x>=TVAL_DCT_SZ)break;
         val=zv[xTab[x]];
         //if(val==0)iLast=iOutPos;else iLast=-1;
         int iBits=0;
        // int iSB=0;
         if(val)
         {
            if(val<0){val=-val;}
            iSigns++;//ziime
            //iBits=calcB(val);
            //if(val==1)iBits=6;else 
            //if(val==2)iBits=7;else 
            iBits=calcB(val);
            //if(len!=15)iBits--;
            //if(iBits>3)iBits=6;
            //iSB=iPrevBits-iBits;
            //iSB++;
            //iSB=iSB<=0?(-iSB*2):(iSB*2-1);
            //iSB++;
            //iPrevBits=iBits;
         }
         //1, 15,17, 33,31,49,47, 63,79,65,95,81,111,97,240,127,
         sv=(len<<4)|(iBits);
         {out[retLen]=sv;retLen++;}
         if(val)iRetLast=retLen;
         //tabula no sv

         //if(iBits<6)
            iOutPos+=iBits;//(iBits>1?(iBits-1):0);//vertiba
//         printf("bits=%d,(%2d,%2d, %2d)\n",iOutPos,len,val,sv);

         if(val)iLast=iOutPos;


      }
      //esc
      //iLast+=4;
      //for(x=0;x<iLast;x++)
        // vlc.toAritSignedValMaxUShort((unsigned char*)&bufTmp[0],0);
      if(iRetLast)out[iRetLast-1]|=0x08;else {out[iRetLast]=0x08;iRetLast++;}
      if(iRetLast)
      {
         int b=0;
         for(x=0;x<iRetLast;x++)
         {
            sv=out[x];
            /*
    1,  15,2,  17,31,33,3,  49,47,18,63,79,65,95,81, 4,
   111,34,97,127,143,240,113,19,50,159,129,175,191, 5,145,207,
   223,161,66,239,177,82,193,35,20,255,209,225,51,98,114, 6,
   241,130,146,178,67,162,36,52,21,83,194,115,210,99,226,68,
   131,22,37,147,242,53,179,163,195,116,84,211,100,38, 0,
   */
            /*
            b=0;
            if(sv==1)b=1;

            else if(sv==15)b=3;
            else if(sv==2)b=3;
            
            else if(sv==17)b=5;
            else if(sv==31)b=5;
            else if(sv==33)b=5;
            else if(sv==3)b=5;
            else b=7;
            while(b){b--;vlc.addB((unsigned char*)&bufTmp[0],1);}
            */
            vlc.toAC_val((unsigned char*)&bufTmp[0],encTab[sv]);
            //b=(encTab[sv]<4)?3:7;
            //while(b){b--;vlc.addB((unsigned char*)&bufTmp[0],1);}
         }
      }
      //else vlc.toAritSignedValMaxUShort((unsigned char*)&bufTmp[0],encTab[0x0f]);

      //for(x=0;x<iLast;x++)vlc.addB((unsigned char*)&bufTmp[0],1);
      vlc.iBitPos+=iLast;
   //   if(iLast!=-1)iOutPos=iLast;
      

//      printf("\nlen=%d bits\n", iLast);
      return iRetLast;
   }
   inline int enc6x(DCT_TYPE *zv, short *out, int k, int iAdd){

      int iOutPos=0;
      int *xTab=(int*)&ZIG_ZAG_TAB[0];//&tabzz4x4[0];
      //xTab=(int*)&tabzz4x4[0];
      vlc.addB(iAdd!=1,(unsigned char*)&bufTmp[0]);
      int x=0;
      int *encTab=(int *)(k?&T_TRASF_UV[0]:&T_TRASF_Y[0]);

      //if(k)return 0;
      
     // if(iAdd!=1)vlc.toAritmDC_pred((unsigned char*)&bufTmp[0],iPredGlob);
      if(iAdd==2){
         //out[iOutPos]=0x0f;
         vlc.toAritSignedValMaxUShort((unsigned char*)&bufTmp[0],0);//encTab[(int)out[0]]);
         return 0;
      }
      int c=zv[*xTab];
      /*
      int iPred=0;
      if(mmabs(c-iPrevDc[k])<mmabs(c)){
         zv[*xTab]=c-iPrevDc[k];
         iPred=1;
      }
      vlc.addB((unsigned char*)&bufTmp[0],iPred);
      iPrevDc[k]=c;
      */
      int val;
      if(iAdd==0)
      {
      //            vlc.iBitPos+=8;

         //int c=zv[*xTab]; c=c<=0?(-c*2):(c*2-1);c++;
         //vlc.toAritSignedValMaxUShort((unsigned char*)&bufTmp[0],c);
         //const int tabswapDC[6]={0,2,3,4,1,5};//0 nekad nav
         //val=mmabs(zv[*xTab]);
         //if(val<6)val=tabswapDC[val];
         int dc=zv[0]-iPrevDc[k];
         vlc.toAC_valSigned((unsigned char*)&bufTmp[0],dc);
         iSigns++;
         x=1;
//         xTab++;
      }
      int len=0;
      int iLast=0;
      int retLen=0;
      int iRetLast=0;
      //int tmpOut[64];
      int sv;
      int iPrevBits=2;
      int iValCnt=notZeros(zv,xTab,x);
      //iOutPos+=3;
      if(0)//MAX_BL==4)
      {
         vlc.iBitPos+=3;
         if(iValCnt>7)vlc.iBitPos+=4;
      }
      else
      {
         vlc.toAC_val((unsigned char*)&bufTmp[0],iValCnt);
         //vlc.iBitPos+=4;
         //if(iValCnt>14)vlc.iBitPos+=6;
      }
      int iValLeft=iValCnt;
      for(;x<TVAL_DCT_SZ && iValLeft>0; x++){
         len=0;

         while(zv[xTab[x]]==0 && x<TVAL_DCT_SZ && len<16){x++;len++;}
         if(x>=TVAL_DCT_SZ)break;
         val=zv[xTab[x]];
        // if(len==15 && val==0)x--;

         //if(val==0)iLast=iOutPos;else iLast=-1;
         int iBits=0;
        // int iSB=0;
         if(val)
         {
            if(val<0){val=-val;}
            //const int tabswapDC[6]={4,5,0,1,2,3};
            iValLeft--;
            iSigns++;//ziime
            if(val<11)iBits=5+val;else
            iBits=calcB(val-10);
         }else len=15;
      //int ll=len;
  //    iZerosLeft-=(len==15?16:len);
    //  if(iZerosLeft==0)len=0;
      //1, 15,17, 33,31,49,47, 63,79,65,95,81,111,97,240,127,
         int sv=(len<<4)|iBits;
         img2[iEncValues]=sv;iEncValues++;
         vlc.toAC_val((unsigned char*)&bufTmp[0],encTab[sv]);
         if(val)iRetLast=retLen;
         //tabula no sv

         //if(iBits<6)
           // if(iBits<6)iOutPos+=iBits;//(iBits>1?(iBits-1):0);//vertiba
         if(val>10)vlc.iBitPos+=iBits;
//         printf("bits=%d,(%2d,%2d, %2d)\n",iOutPos,len,val,sv);

         if(val)iLast=iOutPos;


      }
      //zv[xTab[0]]=c;
      //esc
      //iLast+=4;
      //for(x=0;x<iLast;x++)
        // vlc.toAritSignedValMaxUShort((unsigned char*)&bufTmp[0],0);
      int b;
         if(0)//for(x=0;x<iRetLast;x++)
         {
            sv=out[x];
            vlc.toAC_val((unsigned char*)&bufTmp[0],encTab[sv]);
            b=0;
            //6, 7,14, 1, 2,22,30
            /*
         if(sv==6)b++;
//10x
         else if(sv==22)b+=3;
         else if(sv==7)b+=3;
     //110xxx    
// 6, 7,22, 8,38, 9,23,54,10,70,11,86,39,24,12,102,
         else if(sv==8)b+=6;
         else if(sv==38)b+=6;
         else if(sv==9)b+=6;
         else if(sv==23)b+=6;
         else if(sv==54)b+=6;
         else if(sv==10)b+=6;
         else if(sv==70)b+=6;
         else if(sv==11)b+=6;
         else b+=8;
         vlc.iBitPos+=b;
         */
            //tab6x
         //iLast+=b;
            //b=(encTab[sv]<4)?3:7;
            //while(b){b--;vlc.addB((unsigned char*)&bufTmp[0],1);}
         }
         //for(x=0;x<iLast;x++)vlc.addB((unsigned char*)&bufTmp[0],1);
         //vlc.iBitPos+=iLast;
   //   if(iLast!=-1)iOutPos=iLast;
      
         zv[0]=c;

//      printf("\nlen=%d bits\n", iLast);
      return iRetLast;
   }
#endif
   inline int encR(DCT_TYPE *v, int *p, int k, int iAdd){

      if(iAdd>3){iPrevCoefsCnt4x=iPrevCoefsCnt=0;return  enc2x(v,NULL,k,iAdd);}
      if(iAdd>1){iPrevCoefsCnt=0;return  enc4x(v,NULL,k,iAdd-2);}
      iPrevCoefsCnt4x=0;
      return enc7x(v,NULL,k,iAdd);
     // iEncValues+=enc6x(v,&img2[iEncValues],k,iAdd);//448
      //iEncValues+=
         //enc4x4(v,&img2[iEncValues],k,iAdd);
      //return 0;
      short blx[120];
      //enc5x(v,&blx[0],k,iAdd);
      //
         //enc4x4(v,&blx[0],k,iAdd);//448
      //if((iPass & 4)==0)return 0;
         enc7x(v,&blx[0],k,iAdd);
      
      //if(iAdd==2){vlc.iBitPos+=2;}else {  vlc.iBitPos++;  vlc.iBitPos+=CodeCoeffInter_CalcBitsT(v,&ZIG_ZAG_TAB[0]);}
         if((iPass & 4)==0)return 0;
       // vlc.iBitPos+=CodeCoeffInter_CalcBitsT(v,&ZIG_ZAG_TAB[0]);
         if(iAdd==2){
            p[1]=p[0]=0;
            return 2;
         }
      
      
      int iMax=0;
      int *old=p;
     // p[0]=iAdd;
      int i;
      int cnt=0;
      int val;


      //p++;
      i=0;
      
    //  const int tabswapDC[5]={4,3,2,0,1};
  //    val=val>=0?val*2:-val*2-1;
//      if(i==0 && val<5)val=tabswapDC[val];
      
      int iValCnt=notZeros(v,pTab,1);
      
      if(0)//iIsKey || iHasDifOnly)
      {
         p[0]=iValCnt>>1;
         if(iValCnt&1)p[0]=-p[0]-1;
      }
      else{
         if(iAdd==1)p[0]=iValCnt;else if(iAdd==0) p[0]=-iValCnt-1;
      }
      
      p++;
      p[0]=v[0];
      iMax=2;

      for(i=1;i<TVAL_DCT_SZ && cnt<iValCnt;i++){

         val=v[pTab[i]];
         p[i]=val;
         iMax++;
         if(val){cnt++;}//iMax=i;}
      }
      
      if(iAdd==0)p[0]-=iPrevDc[k];
      
      
/*
      FILE *f=fopen("dct.txt","ab+");
      fprintf(f,"%s%2d,",k==0?"y":"c",cnt+1);
      for(i=0;i<iMax+1;i++)fprintf(f,"%3d,",p[i]);
      fprintf(f,"\n");

      fclose(f);
      */
      
 
      return iMax;//iValCnt+2;//iMax;
   }
   inline int dec2x(DCT_TYPE *v, int k, int &iAdd, int &coefs){
      //memset(&v[0],0,sizeof(DCT_TYPE)*(TVAL_DCT_SZ));
      //iDecDct4x4=32;
      int j;
      coefs=0;
      int retV=0;
      for(j=0;j<16;j++,v+=4){
         if(!vlc.getB()){*(int*)v=0;*(int*)&v[2]=0; retV<<=1;continue;}
      //   v[0]=vlc.get_L_Val_S(2);
         v[0]=vlc.getDC();
         v[1]=vlc.getDC();
         v[2]=vlc.getDC();
         v[3]=vlc.getAC();

         coefs+=4;
         retV|=1;
         retV<<=1;
      }
      iDecDct4x4=32|(retV<<6);
      iAdd=1;
      return 0;
   }
   inline int dec4x(DCT_TYPE *v, int k, int &iAdd, int &coefs){
      int i,j;
      int iCoefsLeft[4];
      coefs=0;
      
      DCT_TYPE val;
      int *xTab=(int*)&tabzz4x4[0];
/*
      if(iIsKey)
         iAdd=0;
      else if(iHasDifOnly)
         iAdd=1;
      else {
         if(mbType[iMbTypePos]){
            iAdd=1;
         }
         else {
            //v[0]+=iPrevDc[k];
            iAdd=0;
         }
         iMbTypePos++;
      }
*/
//      iCoefsLeft[0]=vlc.get_L_Val(2);
  //    iCoefsLeft[1]=vlc.get_L_Val(2);
     // iCoefsLeft[2]=vlc.get_L_Val(2);
    //  iCoefsLeft[3]=vlc.get_L_Val(2);
      iCoefsLeft[0]=vlc.getVlc();
      iCoefsLeft[1]=vlc.getVlc();
      iCoefsLeft[2]=vlc.getVlc();
      iCoefsLeft[3]=vlc.getVlc();
      coefs= iCoefsLeft[3]+iCoefsLeft[2]+iCoefsLeft[1]+iCoefsLeft[0];

      //v[0]=vlc.getDC();

      if(iCoefsLeft[0]>16 || iCoefsLeft[1]>16 || iCoefsLeft[2]>16 || iCoefsLeft[3]>16){
         return -3;
      }
      int iDC=0;
      
      if(iAdd==0){
         iDecDct4x4=1|2|4|8|16;
         iDC=1;

      }
      else{
         iDecDct4x4=16;
         if(iCoefsLeft[0])iDecDct4x4|=1;
         if(iCoefsLeft[1])iDecDct4x4|=2;
         if(iCoefsLeft[2])iDecDct4x4|=4;
         if(iCoefsLeft[3])iDecDct4x4|=8;
      }
      
      memset(&v[0],0,sizeof(DCT_TYPE)*(TVAL_DCT_SZ));


      for(j=0;j<4;j++){
         //if(iCoefsLeft[j]>0){ val=vlc.getDC();if(val){v[xTab[i]]=val;iCoefsLeft[j]--;}}
         //if(iDC)v[xTab[0]]=vlc.getDC();
         if(iCoefsLeft[j]==0){
            xTab+=16;
            continue;
         }
         //int h=iCoefsLeft[j]>>1;
         
         for(i=0;i<1 && iCoefsLeft[j]>0;i++){
            val=vlc.getDC();
            //const int tt4x[]={2,3,3,2};
            //val=vlc.get_L_Val_S(2);//tt4x[i]);
            //val=vlc.getAC();
            if(val){
               v[xTab[i]]=val;iCoefsLeft[j]--;
            }
         }
         
         for(i=1;i<16 && iCoefsLeft[j]>0;i++){
            const int r=vlc.getNextAC(i);
            v[xTab[i]]=r;iCoefsLeft[j]--;

         }
         xTab+=16;
      }
      //void t_idc2(short*);
      //t_idc2(v);



      iPrevLastDec7x=0;
      return 0;
   }
   
   template <int iDeQDif, class T>
   inline int dec4x1_deq(T *v,int from, int k, int to, int cl=-1, const int *tabDeq=NULL){
      //int cl=vlc.getVlc();

      int xx;
      if(cl==-1){
         cl=vlc.getB();
         if(cl)return 0;
         cl=(to<17?dec_coef_m15():vlc.getVlc())+1;
         xx=1;
      }
      else{
         if(cl>to-from)return -3;
         xx=0;
      }
      /*
      if(sizeof(T)==2){
      *(long long*)&v[0]=0;
      *(long long*)&v[4]=0;
      *(long long*)&v[8]=0;
      *(long long*)&v[12]=0;
      }
      else{
      *(long long*)&v[0]=0;
      *(long long*)&v[4]=0;
      *(long long*)&v[8]=0;
      *(long long*)&v[12]=0;
      *(long long*)&v[16]=0;
      *(long long*)&v[20]=0;
      *(long long*)&v[24]=0;
      *(long long*)&v[28]=0;
      }
      */
      memset(&v[from],0,sizeof(T)*(to-from));
      int i,r,c;
      //int *xTab=(int*)&tabzz4x4[0];
      //(tabzz4x4[i]==1 || tabzz4x4[i]==4) || 
#define POSIB_2Z(_CL,_TO) ((_CL)*2+i>=(((i+(_TO)*3))>>2))
      const int iCL=cl;
      //int iWas2=0;
     // int sh=1;
    //  int iWas2=0;
      //iBitGainX1sc
      for(i=from;;i++){
         if(i>=to)
            return -4;
         //if(cl==1 && iCL>1 &&!iWas2)iBitGainX1sc+=2;

       //  bp=vlc.iBitPos;
         if(i+cl==to){
            r=CTVLCX::decNonZero(vlc);
            //pr1[i]++;

         }
         else if(POSIB_2Z(cl,to)){//iLim){//|| pr1[i]>pr0[i]
            r=CTVLCX::decZero2b(vlc);
           // if(!sh)sh++;
         //   r=vlc.getVlc_PNS(sh);
            if(!r){continue;}
           // sh=(vlc.iBitPos-bp)>>1;
            
         }
         else {
            r=vlc.getAC();
            if(!r){continue;}

         }
         //10 11 00 010 0110s
       //  if(r!=1 && r!=-1)iWas2=1;
         //pr1[i]++;
         c=tabzz4x4[i];
         if(iDeQDif){
            DEQ_DP(v[c],r,tabDeq[c]);
         }
         else {
            v[c]=r;
         }
        // if((unsigned)(r+1)>2)xx=1;
       //  if(!iWas2 && (unsigned)(r+1)>2)iWas2=1;
         cl--;
         if(!cl)break;
      }

      if(iCL==1 &&  !xx){
         if(r<0)r--;else r++;
         if(iDeQDif){
            DEQ_DP(v[c],r,tabDeq[c]);
         }
         else{
            v[c]=r;
         }
         //debugsi("val",r);
      }
      
      //   iBitGainX1sc+=2;
      
      return 1;
   }
 template<int iDeQDif>
   inline int dec4x_15_pic_new_ze(DCT_TYPE *v, int k, const int *tabDeq=NULL){
      int i,j;
      int iCoefsLeft[4];
      int *xTab=(int*)&tabzz4x4[0];
      iDecDct4x4=0;

      //const static int etenc[]={0,1,2,15,3,4,5,6,7,8,9,10,11,12,13,14,};
      //dec_coef_m15();
      //1 0 ,2 1 8 7 9 5
      dec_c_cnt4(&iCoefsLeft[0]);
      int z[4];
      for(i=0;i<4;i++){
         if(iCoefsLeft[i] && iCoefsLeft[i]!=15){
            int pr=iCoefsLeft[i]>>1;
            if(iCoefsLeft[i]>6)pr=(14-iCoefsLeft[i])>>1;
            if(pr>1)z[i]=vlc.getAC()+pr;else z[i]=dec_coef_m15();
         }else z[i]=0;
      }


      int cl;
      for(j=0;j<4;j++){
         cl=iCoefsLeft[j];
         if(cl==0){
            xTab+=16;
            continue;
         }
         iDecDct4x4|=(1<<j);
         //TODO test
         memset(&v[j<<4],0,sizeof(DCT_TYPE)*16);
         //int h=iCoefsLeft[j]>>1;
         //int m=0;if(cl<7)m=vlc.getB();
         
         for(i=1;cl>0;i++){
            if(i>15)return -4;
            if(cl==1){i+=z[j];z[j]=0;}
            if(i+cl==16 || z[j]<=0){
               int r=vlc.getVlc()+1;
               if(vlc.getB())r=-r;
               const int c=xTab[i];
               DEQ_DP(v[c],r,tabDeq[c]);
               cl--;
            }
            else if(z[j]<cl){
               int r;
               if(vlc.getB()){
                  // zero or >1
                  if(vlc.getB()){z[j]--;continue;}
                  
                  
                  if(vlc.getB()){
                     r=-vlc.getVlc()-2;
                  }
                  else{
                     r=vlc.getVlc()+2;
                  }
                  //r=vlc.getAC();if(r<0)r--;else r+=2;
               }
               else{
                  r=vlc.getB()?-1:1;
               }

               const int c=xTab[i];
               DEQ_DP(v[c],r,tabDeq[c]);
               cl--;

            }
            else {

               const int r=vlc.getAC();
               if(!r){z[j]--;continue;}
               const int c=xTab[i];
               DEQ_DP(v[c],r,tabDeq[c]);
               cl--;
               
            }
         }
         xTab+=16;
      }
      return 0;

   }
   template<int iDeQDif>
   inline int dec4x_15_pic_new_last_one(DCT_TYPE *v, int k, const int *tabDeq=NULL){
      int i,j;
      int iCoefsLeft[4]={0,0,0,0};
int iLastID[4]={0,0,0,0};
      int *xTab=(int*)&tabzz4x4[0];
      iDecDct4x4=0;
      //int iLastS;
      int iLastCnt=0;
      const int iLim=k?12:14;

      int findScoreCntLast_dec_def(int code, int id, int &iCnt, int &iLast);

      int tab_id=((iDeQDif==2)<<1)+(!k);
      int cl;
      int iCoDec=0;
      for(j=0;j<4;j++){
//int bp=vlc.iBitPos;iBitGainX1sc--;

         //int code=(k && !iBlocks8orMore)?vlc.getVlc():(((j>=2 && !iCoDec) || iBlocks8orMore)?vlc.getVlc_PN(2-iBlocks8orMore):vlc.getVlc_PNZ(3));
//         int code=(k && !iBlocks8orMore)?vlc.getVlc():((j==3 && !iCoDec)?vlc.getVlc_PN(2+iBlocks8orMore):(iBlocks8orMore?vlc.getVlc_PN(2):vlc.getVlc_PNZ(3)));
         int code=(k && !iBlocks8orMore)?vlc.getVlc():((j==3 && !iCoDec) || iBlocks8orMore || (j>=2 && !iCoDec)?vlc.getVlc_PN(2):vlc.getVlc_PNZ(3));
         //int code=(k)?vlc.getVlc():((j==3 && !iCoDec)?vlc.getVlc_PN(1):vlc.getVlc_PNZ(3));
         //if(iBlocks8orMore){code<<=1;code|=vlc.getB();}
//int iBitsCodeLen=vlc.iBitPos-bp;
         code+=(j==3 && !iCoDec);

         if(!code){
            xTab+=16;
            continue;
         }
         
         if(code>128)return -3;

         findScoreCntLast_dec_def(code-1,tab_id+getPredX(&iCoefsLeft[0],j)*4,iCoefsLeft[j],iLastCnt);
         cl=iCoefsLeft[j];
         iCoDec+=cl;


                     int findScoreCntLast(int iCnt, int iLast, int  *tab);

               //findScoreCntLast(iCoefsLeft[j],iLastCnt,&tab_c_l[(tab_id)*128]);
              
              // int scx=1+findScoreCntLast(iCoefsLeft[j],iLastCnt,&tab_c_l[((tab_id+((!iBlocks8orMore)<<3))+getPredX(&iCoefsLeft[0],j)*8)*128]);//+!(j==3 && !(iCoefsLeft[0]|iCoefsLeft[1]|iCoefsLeft[2]));
              // iBitGainXNZ+=(vlc.bitsLenX2[code]-vlc.bitsLenX2[scx]);
            //void debugsi(char*,int);            debugsi("a",iBitGainXNZ>>3);//iBitsCodeLen-vlc.bitsLen[sc]);

         iDecDct4x4|=(1<<j);
         //TODO test
         memset(&v[j<<4],0,sizeof(DCT_TYPE)*16);
         //int h=iCoefsLeft[j]>>1;
         //int m=0;if(cl<7)m=vlc.getB();
         
         //if(val)pr1[i][!!k]++; else pr0[i][!!k]++;
         int iWasZero=0;
         int r;
         int iLastCo=iLastCnt;
         int iCoReal=iLastCo?(iLastCo-1):0;
         
//if(iLastCnt==0)iBitGainX1+=2;

         for(i=1;cl>0;i++){
            
            if(cl==1 && iLastCo){
               //for(int zzz=i;zzz<i+iCoReal;zzz++)pr0[i]++;
               if(iLastCo<7){
//                  r=vlc.getB()?-1:1;
#if 0
 #define PRXADD 
 #define PRXREM
#else
 #define PRXADD prx[i]++
 #define PRXREM prx[i]--
#endif
                  i+=iCoReal;
                  PRXADD;
                  const int c=xTab[i];
                  if(vlc.getB()){
                     DEQ_DP(v[c],-1,tabDeq[c]);
                  }
                  else{
                     DEQ_DP(v[c],1,tabDeq[c]);
                  }
              //    cl--;
                  break;
               }
               PRXREM;
               iCoReal=0;
               iLastCo=0;
               //iBitGainX1
               i+=6;
            }
            
            if(i>15)
               return -4;
            //const int i2=;
            
            if(i+cl+iCoReal==16){
               r=CTVLCX::decNonZero(vlc);
               
            }//|| coze>0//cl*4+i>iLim && 
            else if((!iWasZero)  
               || prx[i]>0
               ||(cl)*2+((iCoReal*3)>>1)+i>=16 
               
              // ||pr0[i]*5<pr1[i]*4
               ){// && (cl+iCoReal)*4+i>iLim))){

               r=CTVLCX::decZero2b(vlc);
               if(!r){iWasZero=1;PRXREM;;continue;}//iGBits++;
               

            }
            else {
               r=vlc.getAC();
               if(!r){PRXREM;continue;}
               /*
               if(r){
                  iBitGainX1sc+=vlc.bitsLenAC[abs(r)];
                  iBitGainX1sc-=(abs(r)*2+(r>0));
               }
               */
            }
            //if(r>1 || r<-1)iHasBigCoefs=1;else iGBits++;

            const int c=xTab[i];
            DEQ_DP(v[c],r,tabDeq[c]);
            cl--;
           // if(cl==1)iLastID[j]=i;
            
            //coze++;
            PRXADD;
            
         }
         //iBitGainX1sc+=(vlc.iBitPos-bp);
         //encTestBlQ<0,short>(v,tabDeq);
         /*
         
               int co=getPredX2(&iCoefsLeft[0],&iLastID[0],j);
               int sc=findScoreCntLast(iCoefsLeft[j],iLastCnt,&tab_c_l[(tab_id+co*4)*128]);
               iSc[j]+=sc;
               sc++;sc-=(j==3 && !(iCoefsLeft[0]|iCoefsLeft[1]|iCoefsLeft[2]));
               int getLen2x_testI(int v, int st);
               int scN=vlc.bitsLen[sc>>2]+3;//:getLen2x_testI(sc,3);
               iBitGainX1+=(iBitsCodeLen-scN);
               iSc[4]++;
               iSc[5]+=(iBitsCodeLen-scN);
*/
         //for(;i<16;i++)pr0[i]++;
         xTab+=16;
      }
      /*

               int getSaveFlag();
               if(getSaveFlag()){
                  for(i=0;i<24;i++){
                     char bufN[64];
                     sprintf(&bufN[0],"dif_pic_Y_UV_%02d",i);
                     createTable_int(&bufN[0],&tab_c_l[i*128],128,"tab_c_l.cpp");
                  }
               }
*/
      return 0;
   }
   template<int iDeQDif>
   inline int dec1x_15_pic_new_last_one(DCT_TYPE *v, int k, int code, int *iCoefsLeft, int j, const int *tabDeq=NULL){
      int i;
      
//int iLastID[4]={0,0,0,0};
      int *xTab=(int*)&tabzz4x4[0];
      //int iLastS;
      int iLastCnt=0;
      const int iLim=k?12:14;

      int findScoreCntLast_dec_def(int code, int id, int &iCnt, int &iLast);

      int tab_id=((iDeQDif==2)<<1)+(!k);
      int cl;
//int bp=vlc.iBitPos;
         //int code=vlc.getVlc();
//int iBitsCodeLen=vlc.iBitPos-bp;
         //code+=(j==3 && !(iCoefsLeft[0]|iCoefsLeft[1]|iCoefsLeft[2]));

         if(code>128)return -3;
//+getPredX(&iCoefsLeft[0],j)*4
         findScoreCntLast_dec_def(code-1,tab_id,iCoefsLeft[j],iLastCnt);
         cl=iCoefsLeft[j];
                  //   int findScoreCntLast(int iCnt, int iLast, int  *tab);

               //findScoreCntLast(iCoefsLeft[j],iLastCnt,&tab_c_l[(tab_id+getPredX(&iCoefsLeft[0],j)*4)*128]);
         iDecDct4x4|=(1<<j);
         //TODO test
         memset(&v[1],0,sizeof(DCT_TYPE)*15);
         //int h=iCoefsLeft[j]>>1;
         //int m=0;if(cl<7)m=vlc.getB();
         
         //if(val)pr1[i][!!k]++; else pr0[i][!!k]++;
         int iWasZero=0;
         int r;
         int iLastCo=iLastCnt;
         int iCoReal=iLastCo?(iLastCo-1):0;
         
//if(iLastCnt==0)iBitGainX1+=2;

         for(i=1;cl>0;i++){
            
            if(cl==1 && iLastCo){
               //for(int zzz=i;zzz<i+iCoReal;zzz++)pr0[i]++;
               if(iLastCo<7){
                  r=vlc.getB()?-1:1;
                  i+=iCoReal;
                  PRXADD;
                  const int c=xTab[i];
                  DEQ_DP(v[c],r,tabDeq[c]);
                  cl--;
                  break;
               }
               PRXREM;
               iCoReal=0;
               iLastCo=0;
               //iBitGainX1
               i+=6;
            }
            
            if(i>15)
               return -4;
            //const int i2=;
            
            if(i+cl+iCoReal==16){
               r=CTVLCX::decNonZero(vlc);
            }//|| coze>0//cl*4+i>iLim && 
            else if(!iWasZero || 
               ((cl)*2+((iCoReal*3)>>1)+i>=iLim  || 
               //cl*2+iCoReal+i>=(((i+to*3))>>2) || 
               prx[i]>1)){// && (cl+iCoReal)*4+i>iLim))){

               r=CTVLCX::decZero2b(vlc);
               if(!r){iWasZero=1;PRXREM;continue;}

            }
            else {
               r=vlc.getAC();
               if(!r){PRXREM;continue;}
            }

            const int c=xTab[i];
            DEQ_DP(v[c],r,tabDeq[c]);
            cl--;
  //          if(cl==1)iLastID[j]=i;
            
            //coze++;
            //pr1[i]++;
            PRXADD;
         }
         /*
               int co=getPredX2(&iCoefsLeft[0],&iLastID[0],j);
               int sc=findScoreCntLast(iCoefsLeft[j],iLastCnt,&tab_c_l[(tab_id+co*4)*128]);
               iBitGainX1+=(vlc.bitsLen[code]-vlc.bitsLen[sc]);
*/
      /*

               int getSaveFlag();
               if(getSaveFlag()){
                  for(i=0;i<24;i++){
                     char bufN[64];
                     sprintf(&bufN[0],"dif_pic_Y_UV_%02d",i);
                     createTable_int(&bufN[0],&tab_c_l[i*128],128,"tab_c_l.cpp");
                  }
               }
*/
      return 0;
   } 

 template<int iDeQDif>
   inline int dec4x_15_pic_newzzzzzzzzzzzzz(DCT_TYPE *v, int k, const int *tabDeq=NULL){
      int i,j;
      int iCoefsLeft[4];
      int *xTab=(int*)&tabzz4x4[0];
      iDecDct4x4=0;

      //const static int etenc[]={0,1,2,15,3,4,5,6,7,8,9,10,11,12,13,14,};
      //dec_coef_m15();
int bp=vlc.iBitPos;
      dec_c_cnt4(&iCoefsLeft[0]);
int iBits4Cnt=vlc.iBitPos-bp;
      const int iLim=k?12:14;

         //int coze=-5;
int tr[4]={0,0,0,0};
int g[4]={0,0,0,0};
int iLastID[4]={0,0,0,0};

      int cl;
      for(j=0;j<4;j++){
         cl=iCoefsLeft[j];
         if(cl==0){
            xTab+=16;
            continue;
         }
         iDecDct4x4|=(1<<j);
         //TODO test
         memset(&v[j<<4],0,sizeof(DCT_TYPE)*16);
         //int h=iCoefsLeft[j]>>1;
         //int m=0;if(cl<7)m=vlc.getB();
         
         //if(val)pr1[i][!!k]++; else pr0[i][!!k]++;
         int r,z=0;
         for(i=1;cl>0;i++){
            if(i>15)return -4;
            //const int i2=;
            if(cl==1)tr[j]++;


            /*
            if(cl==1){
               int r,z=vlc.getVlc();//+(iCoefsLeft[j]>>2);
               int big=0;
               if(z>15){z-=16;big=1;}
               for(int a=0;a<z;a++)pr0[a+i]++;
               i+=z;
               if(!big)r=1;else r=vlc.getVlc()+1;
               if(vlc.getB())r=-r;
               const int c=xTab[i];
               DEQ_DP(v[c],r,tabDeq[c]);
               cl--;
               pr1[i]++;
               break;
            }*/
            
            if(i+cl==16){
               r=vlc.getVlc()+1;
               if(vlc.getB())r=-r;
               const int c=xTab[i];
               DEQ_DP(v[c],r,tabDeq[c]);
               cl--;
   
               //coze++;
               pr1[i]++;
            }//|| coze>0//cl*4+i>iLim && 
            else if(cl*2+i>iLim  || (pr0[i]*5<pr1[i]*4)){
if(cl==1 && tr[j]<8)g[j]+=2;
               r=CTVLCX::decZero2b(vlc);
               if(!r){pr0[i]++;continue;}
               pr1[i]++;
               const int c=xTab[i];
               DEQ_DP(v[c],r,tabDeq[c]);
               cl--;

            }
            else {
if(cl==1 && tr[j]<8)g[j]++;
               r=vlc.getAC();
               if(!r){pr0[i]++;continue;}
               const int c=xTab[i];
               DEQ_DP(v[c],r,tabDeq[c]);
               cl--;
               //coze++;
               pr1[i]++;
            }
            if(cl==1 && iLastID[j]==0)iLastID[j]=i;
            if(!cl){
               if(tr[j]>7){tr[j]=7;}
               else if((unsigned )(r+1)>2){tr[j]=0;g[j]=0;}
            }
         }
         //for(;i<16;i++)pr0[i]++;
         xTab+=16;
      }
      int iMaxSC=0;
      /*
      if(!this->iVisDecoder){
         int findScoreCntLast(int iCnt, int iLast, int  *tab);
         void debugsi(char *c, int a);
         int bx=0;
         int iBitsN=0;
         for(j=0;j<4;j++){
            if(iCoefsLeft[j]){
               int getLen2x_test(int v);
               
               int tab_id=((iDeQDif==2)<<1)+(!k);

               int co=getPredX2(&iCoefsLeft[0],&iLastID[0],j);
               
               int findScoreCntLast_def(int iCnt, int iLast, int  id);
               //int sc=findScoreCntLast_def(iCoefsLeft[j],tr[j],tab_id+co*4);
               int sc=findScoreCntLast(iCoefsLeft[j],tr[j],&tab_c_l[(tab_id+co*4)*128]);
               if(j!=3 || (iCoefsLeft[0]|iCoefsLeft[1]|iCoefsLeft[2]))sc++;
               iMaxSC=max(sc,iMaxSC);
               //debugsi(k?"kx":"picx",vlc.bitsLen[sc+1]);
               if(1||iDeQDif==1 || k)iBitsN+=vlc.bitsLen[sc];
               else iBitsN+=getLen2x_test(sc);
               //1101
               if(iCoefsLeft[j]+tr[j]>=15)iBitsN-=(iCoefsLeft[j]-1);else//nav 0 sakumaa
               if(iCoefsLeft[j]+tr[j]>=14)iBitsN-=(iCoefsLeft[j]>>1);else
               if(iCoefsLeft[j]>1 && tr[j]>3)iBitsN--;
               
               iBitsN-=(g[j]+1);if(tr[j]==0)iBitsN--;

               

              // void createTable_int(char *name, int *tab, int iSize,char *fn);
               

            }
            else iBitsN++;
         }
       //  static int iBitGainP;
         //iBitGainP+=(iBits4Cnt-iBitsN);
         int ge=iBits4Cnt-iBitsN;;
         if(!k && 0){
            if(iMaxSC<16)ge--;
            if(ge<-1 && 0){
               void debugs2i(char *c, int a, int b);
               debugs2i("bad mc",ge,iMaxSC);
               for(j=0;j<4;j++){
                  
                  debugs2i("e1",iCoefsLeft[j],tr[j]);
               }
            }
            if(ge<-1)ge=-1;
         }
         iBitGainX1+=ge;
         
         
         //debugsi(k?"k":"pic",ge);
      }*/
      return 0;

   }

   template <int iDeQDif>
   inline int dec4x_15(DCT_TYPE *v, int k, const int *tabDeq=NULL){
      int i,j;
      int iCoefsLeft[4];
      iDecDct4x4=0;

#ifdef _TEST_T_BITS
#define T_USE_N_PICD 0
      //||1
//#define T_USE_N_PICD 0
      if(iDeQDif==2|| T_USE_N_PICD)return dec4x_15_pic_new_last_one<iDeQDif>(v,k,tabDeq);
      int ret=0;
      for(j=0;j<4;j++){
         ret=dec1x_15_dif<iDeQDif>(v+(j<<4), &iCoefsLeft[0], j,tabDeq);
         if(ret<0)break;
      }
      return ret;
      
#endif
      
//      DCT_TYPE val;
      int *xTab=(int*)&tabzz4x4[0];

      int bp=vlc.iBitPos;

      iCoefsLeft[0]=vlc.getVlc();
      iCoefsLeft[1]=vlc.getVlc();
      iCoefsLeft[2]=vlc.getVlc();
      iCoefsLeft[3]=vlc.getVlc();
      const int iMaxCo=(iCoefsLeft[0]|iCoefsLeft[1]|iCoefsLeft[2]|iCoefsLeft[3]);
      if(iMaxCo>15){
         return -3;
      }
      
      //dec_c_cnt4(&iCoefsLeft[0]);
#if 0
     // def _TEST_T_BITS
    //  static int i_smMaxCo[4];
      
     /*
      static int non_z[1024];
      int iNonZF=((iCoefsLeft[0]&~3))|((iCoefsLeft[1]&~3)<<2)|((iCoefsLeft[2]&~3)<<4)|((iCoefsLeft[3]&~3)<<6);

      int findScore16(int val, int  *tab);
      int sc=findScore16(iNonZF,&non_z[(k?256:0)+(iDeQDif==2?512:0)]);
      non_z[iNonZF+(k?256:0)+(iDeQDif==2?512:0)]++;
      int iBitsNZ=vlc.iBitPos-bp;
      int iNewLenNZ=vlc.bitsLenx2[c];
      iNewLenNZ++;//addBit(iMaxCo>3);
      
      if(iMaxCo>3){
         if(iCoefsLeft[0])iNewLenNZ+=vlc.bitsLen[iCoefsLeft[0]>>2];
         if(iCoefsLeft[1])iNewLenNZ+=vlc.bitsLen[iCoefsLeft[1]>>2];
         if(iCoefsLeft[2])iNewLenNZ+=vlc.bitsLen[iCoefsLeft[2]>>2];
         if(iCoefsLeft[3])iNewLenNZ+=vlc.bitsLen[iCoefsLeft[3]>>2];
      }
      if(sc<16)iNewLenNZ++;
      if(iNewLenNZ>iBitsNZ+1)iNewLenNZ=iBitsNZ+1;
      iBitGainXNZ+=(iBitsNZ-iNewLenNZ);
      debugss("bnz",iBitGainXNZ>>3,iBitsNZ-iNewLenNZ);
*/
      /*
      static int non_z[1024];
      int iNonZF=((iCoefsLeft[0]&~3))|((iCoefsLeft[1]&~3)<<2)|((iCoefsLeft[2]&~3)<<4)|((iCoefsLeft[3]&~3)<<6);

      int findScore16(int val, int  *tab);
      int sc=findScore16(iNonZF,&non_z[(k?256:0)+(iDeQDif==2?512:0)]);
      non_z[iNonZF+(k?256:0)+(iDeQDif==2?512:0)]++;
      int iBitsNZ=vlc.iBitPos-bp;
      int iNewLenNZ=vlc.bitsLenx2[sc];
      iNewLenNZ++;//addBit(iMaxCo>3);
      
      if(iMaxCo>3){
         iNewLenNZ+=4;
         if(iCoefsLeft[0]>3)iNewLenNZ+=2;//vlc.bitsLen[iCoefsLeft[0]>>2];
         if(iCoefsLeft[1]>3)iNewLenNZ+=2;//vlc.bitsLen[iCoefsLeft[1]>>2];
         if(iCoefsLeft[2]>3)iNewLenNZ+=2;//vlc.bitsLen[iCoefsLeft[2]>>2];
         if(iCoefsLeft[3]>3)iNewLenNZ+=2;//vlc.bitsLen[iCoefsLeft[3]>>2];
      }
      if(sc<16)iNewLenNZ++;
      if(iNewLenNZ>iBitsNZ+1)iNewLenNZ=iBitsNZ+1;
      iBitGainXNZ+=(iBitsNZ-iNewLenNZ);
      debugss("bnz",iBitGainXNZ>>3,iBitsNZ-iNewLenNZ);
*/
      //i_smMaxCo[(k?1:0)+2*(iDeQDif-1)]=iDecDct4x4;
      //++++++++++++++++
#ifdef _TEST_T_BITS
      static int non_z[1024*16*4];
      /*
      {
      static int iCntxx=0;
      void saveFile(const char *fn,void *p, int iLen);
      char *loadFile(const  char *fn, int &iLen);

      if(iCntxx==0){
         int l=0;
         char *p=loadFile("lenCodes.int",l);
         if(l){
            if(l>=sizeof(non_z))l=sizeof(non_z)-1;
            memcpy(non_z,p,l);
            for(i=0;i<1024*16;i++){
               //non_z[i]+=(non_z[i+1024*16]+non_z[i+1024*48]+non_z[i+1024*32]);
            }
            delete p;
         }
      }
      else if((iCntxx&((1<<15)-1))==0){
        // saveFile("lenCodes.int",&non_z[0],sizeof(non_z));
        // debugss("save lenCodes.int",iCntxx,sizeof(non_z));
      }
      iCntxx++;
      }
      */
#endif
      
      int iNonZF=((iCoefsLeft[0]&3))|((iCoefsLeft[1]&3)<<2)|((iCoefsLeft[2]&3)<<4)|((iCoefsLeft[3]&3)<<6);
      
      iNonZF<<=4;
      if(iCoefsLeft[0]>3)iNonZF|=1;
      if(iCoefsLeft[1]>3)iNonZF|=2;
      if(iCoefsLeft[2]>3)iNonZF|=4;
      if(iCoefsLeft[3]>3)iNonZF|=8;
     int scx=iMaxCo;
     int iCurCnt=0;
     static int iPrevCntZ[4];
     //TODO test CBP pred curx 4bit+2bit
      //???????????
    //  while(scx>1){iCurCnt++;scx>>=1;}//31629
      
      int iTabOfs=1024*16*iPrevCntZ[(k?1:0)+(iDeQDif-1)*2];
      iPrevCntZ[(k?1:0)+(iDeQDif-1)*2]=iCurCnt;

      //TODO


      int findScore16(int val, int  *tab);
      int coOfs=(k?256*16:0)+(iDeQDif==2?512*16:0);
      non_z[coOfs+iNonZF+iTabOfs]++;      
      int sc=findScore16(iNonZF,&non_z[coOfs+iTabOfs]);
     // debugss("val",sc,non_z[coOfs+iNonZF+iTabOfs]);
      int iBitsNZ=vlc.iBitPos-bp;
      int iNewLenNZ=0;
      //1 0
      int iScToSave=sc;
      //
      //while(iScToSave>2047*4){iNewLenNZ+=4;iScToSave>>=2;}if(sc){iNewLenNZ+=vlc.bitsLen[iScToSave>>2]+3;}else iNewLenNZ++; 
      while(iScToSave>2047){iNewLenNZ+=4;iScToSave>>=2;}iNewLenNZ+=vlc.bitsLen[iScToSave];
      //while(iScToSave>2047){iNewLenNZ+=2;iScToSave>>=1;}      iNewLenNZ+=vlc.bitsLen[iScToSave>>2]+2;

  
      
      
      //iNewLenNZ++;//addBit(iMaxCo>3);
      
      if(iMaxCo>3){
         //iNewLenNZ+=4;
         if(iCoefsLeft[0]>3)iNewLenNZ+=2;//vlc.bitsLen[iCoefsLeft[0]>>2];
         if(iCoefsLeft[1]>3)iNewLenNZ+=2;//vlc.bitsLen[iCoefsLeft[1]>>2];
         if(iCoefsLeft[2]>3)iNewLenNZ+=2;//vlc.bitsLen[iCoefsLeft[2]>>2];
         if(iCoefsLeft[3]>3)iNewLenNZ+=2;//vlc.bitsLen[iCoefsLeft[3]>>2];
      }

      if(iScToSave<16)iNewLenNZ++;
      iBitsNZ=0;
#define C_B2(_X) iBitsNZ+=vlc.bitsLen[iCoefsLeft[_X]>>2]+2
      
#define C_B(_X) iBitsNZ+=vlc.bitsLen[iCoefsLeft[_X]]
      C_B(0);
      C_B(1);
      C_B(2);
      C_B(3);

      if(iNewLenNZ>iBitsNZ+1){iNewLenNZ=iBitsNZ+1;}
      
      int iGThis=((vlc.iBitPos-bp)-iNewLenNZ);
      iBitGainXNZ+=iGThis;


      //debugss("bnz",iBitGainXNZ>>3,iGThis);


#endif
//iBitGainX+=3;

     
      iDecDct4x4=0;
#ifdef _TEST_T_BITS
int i_mCurDV[4]={0,0,0,0};

int iLastC[4]={0,0,0,0};
int i_mMaxV[4]={0,0,0,0};
int iBitsNewLen=0;
#endif
      int cl;
      int c;
      DCT_TYPE r,t;
      for(j=0;j<4;j++){
         //if(iCoefsLeft[j]>0){ val=vlc.getDC();if(val){v[xTab[i]]=val;iCoefsLeft[j]--;}}
         //if(iDC)v[xTab[0]]=vlc.getDC();
         cl=iCoefsLeft[j];
         if(cl==0){
            xTab+=16;
            continue;
         }
         iDecDct4x4|=(1<<j);
         //TODO test
         memset(&v[j<<4],0,sizeof(DCT_TYPE)*16);
         //int h=iCoefsLeft[j]>>1;
#ifdef _TEST_T_BITS
int iMaxV=0;
int iCurDV=0;
#endif
         for(i=1;cl>0;i++){
            r=(DCT_TYPE)vlc.getNextAC(i);
            if(i>15)return -4;
            c=xTab[i];
            if(iDeQDif==2){
               
               DEQ_PIC(v[c],r,tabDeq[c]);
               //v[c]=r*tabDeq[c];
            }else  if(iDeQDif==1){
               t=tabDeq[c];
               DEQ_DIF(v[c],r,t);
            }else{
               v[c]=r;
            }
#if 0
            //def _TEST_T_BITS
iLastC[j]=i;
iCurDV|=1<<i;

if(r>1 || r<-1)iMaxV=1;
#endif
            cl--;
         }
         xTab+=16;
#if 0 
         //def _TEST_T_BITS
         iCurDV>>=1;
i_mCurDV[j]=iCurDV;
i_mMaxV[j]=iMaxV;
//i_smMaxCo[(k?1:0)+2*(iDeQDif-1)]=iMaxCo;

//--------<<
if(!k && iDeQDif==1 && 
   !this->iVisDecoder ){
   void addCoef(int iCurDV,int dbg, int iPic);
   addCoef(i_mCurDV[j],0,iDeQDif==2);
}
#endif
//------->>
      }


#if 0
      def _TEST_T_BITS
      
   int calcBits_4xTest(int iPic,int l, int iCnt,int iMax2,int iCurDV, unsigned char *bitsLenAC, unsigned char *bitsLenVLC);
     // static int iBitG;
if( //iDeQDif==1 && 
   !this->iVisDecoder ){
      static int iCntZ=0;
      for(j=0;j<4;j++){
         if(iCoefsLeft[j]){
            iBitsNewLen+=calcBits_4xTest(((iDeQDif==2)+k?2:0),iCoefsLeft[j],iLastC[j], i_mMaxV[j], i_mCurDV[j],&vlc.bitsLenx2[0],&vlc.bitsLen[0]);
           iCntZ++;
         }
      }
            iBitGainX1+=iBitsNewLen;
         if(iDeQDif==1)iBlockXCnt++;
            /*
            static int cnta=0;
            cnta++;
            if((cnta&31)==0)debugss("bit Dif",(iBitGainX+max(iBitGainX1,iBitGainXNZ))>>3,(((iBitGainX1)*100))/(1+iCntZ));
            */
}
//else iBitGainX1+=iGThis;
#endif



      iPrevLastDec7x=0;
      return 0;
   }
   inline int dec4xi(DCT_TYPE *v, int k, int &iAdd, int &coefs){
      int i,j;
      int iCoefsLeft[4];
      coefs=0;
      
      DCT_TYPE val;
      int *xTab=(int*)&tabzz4x4[0];
      iCoefsLeft[0]=vlc.getVlc();
      iCoefsLeft[1]=vlc.getVlc();
      iCoefsLeft[2]=vlc.getVlc();
      iCoefsLeft[3]=vlc.getVlc();

      if(iCoefsLeft[0]>16 || iCoefsLeft[1]>16 || iCoefsLeft[2]>16 || iCoefsLeft[3]>16){
         return -3;
      }
      
      if(iAdd==0)
         iDecDct4x4=1|2|4|8|16;
      else{
         iDecDct4x4=16;
      }
      const int fl[]={1,2,3,4};
     // iAdd=vlc.getB();
      

      
      
      memset(&v[0],0,sizeof(DCT_TYPE)*(TVAL_DCT_SZ));


      for(j=0;j<4;j++){
         for(i=0;i<4 && iCoefsLeft[j]>=0;i++){
            val=vlc.get_L_Val_S(2);//tt4x[i]);
            if(val){coefs++;v[xTab[i]]=val;iDecDct4x4|=fl[j];}else iCoefsLeft[j]--;
         }
         for(;i<16 && iCoefsLeft[j]>=0;i++){
            val=vlc.getAC();
            if(val){coefs++;v[xTab[i]]=val;iDecDct4x4|=fl[j];}else iCoefsLeft[j]--;
         }
         xTab+=16;
      }
      iPrevLastDec7x=0;
      return 0;
   }
   inline int enc7xNoDC(DCT_TYPE *v, int k)
   {
      int i;//,j,l=0;
      int iCoefsLeft=0;
      int *xTab=(int*)&ZIG_ZAG_TAB[0];
         int iFrom;//=k==0?3:1;
         if(k==0){
            iFrom=3;
            iCoefsLeft=notZeros(v,xTab,iFrom);
         }
         else{
            iFrom=1;
            iCoefsLeft=notZerosF(v,iFrom);
         }
         int val;

         if(iPrevCoefsCnt>0)
            vlc.toDC(iCoefsLeft-iPrevCoefsCnt);
         else
            vlc.toVLC(iCoefsLeft);
         iPrevCoefsCnt=iCoefsLeft;

         int xv=0;
         if(iFrom==3){
            //vlc.toL_Val_S(v[1],2);
            //vlc.toL_Val_S(v[8],2);
            xv=(mmabs(v[1])+mmabs(v[8]))>>1;
            //xv=max(mmabs(v[1]),mmabs(v[8]));
            vlc.toDC(v[1]);
            vlc.toDC(v[8]);
         }
         for(i=iFrom;i<TVAL_DCT_SZ && iCoefsLeft>0 ;i++){
            val=v[xTab[i]];
            if(val){
               if(iCoefsLeft+xv>16 && iCoefsLeft>3)vlc.toL_Val_S(val,iCoefsLeft+xv>30?3:2);else vlc.toAC(val);
               iCoefsLeft--;
            }else vlc.addB(1);
         }
            
      return 0;

   }
   inline int dec7xNoDC(DCT_TYPE *v, int k, int &coefs){
      int i,iCoefsLeft;

      if(iPrevCoefsCnt>0){
         iCoefsLeft=coefs=vlc.getDC()+iPrevCoefsCnt;
      }
      else{
         iCoefsLeft=coefs=vlc.getVlc();
      }

      if(iCoefsLeft>70 || iCoefsLeft<-70)return -1;
      iPrevCoefsCnt=coefs;
      int iFrom=k==0?3:1;
      memset(&v[1],0,sizeof(DCT_TYPE)*(TVAL_DCT_SZ-1));
      int xv=0;
      if(iFrom==3){
         v[1]=vlc.getDC();
         v[8]=vlc.getDC();
         //v[1]=vlc.get_L_Val_S(2);
         //v[8]=vlc.get_L_Val_S(2);
         if(v[1])coefs++;
         if(v[8])coefs++;
         xv=(mmabs(v[1])+mmabs(v[8]))>>1;
      }
      if(coefs>64)return -1;
      for(i=iFrom;i<TVAL_DCT_SZ && iCoefsLeft>3 && iCoefsLeft+xv>16;i++){
         const int val=vlc.get_L_Val_S(iCoefsLeft+xv>30?3:2);
         if(val){
            v[ZIG_ZAG_TAB[i]]=val;
            iCoefsLeft--;
         }
      }
      for(;i<TVAL_DCT_SZ && iCoefsLeft>0;i++){
         iCoefsLeft--;
         const int val=vlc.getNextAC(i);
         v[ZIG_ZAG_TAB[i]]=val;
      }

      return 0;
   }

   inline int dec7x(DCT_TYPE *v, int k, int &iAdd, int &coefs, int iDecAdd=1){
      
      //int coefs;//vlc.getVlc(NULL);
      int i;
      int iCoefsLeft;
      
//      DCT_TYPE val;
      //int *xTab=(int*)&ZIG_ZAG_TAB[0];

      if(iDecAdd){
         if(0&&iIsKey)
            iAdd=0;
         else if(iHasDifOnly)
            iAdd=1;
         else {
            if(mbType[iMbTypePos]){
               iAdd=mbType[iMbTypePos];
            }
            else {
               //v[0]+=iPrevDc[k];
               iAdd=0;
            }
            iMbTypePos++;
         }
      }
      if(iAdd>1){
         iPrevCoefsCnt=0;
         iPrevLastDec7x=0;
         if(iAdd>3){iPrevCoefsCnt4x=0;return dec2x(v,k,iAdd,coefs);}
         iAdd-=2;
         return dec4x(v,k,iAdd,coefs);
      }
      iDecDct4x4=0;

/*
      //iCoefsLeft=coefs=vlc.getVlc();
      iCoefsLeft=coefs=vlc.getDC()+iPrevCoefsCnt;
      */
      if(iPrevCoefsCnt>0){
         iCoefsLeft=coefs=vlc.getDC()+iPrevCoefsCnt;
      }
      else{
         iCoefsLeft=coefs=vlc.getVlc();
      }

      //iCoefsLeft=coefs=vlc.get_L_Val_S(2)+iPrevCoefsCnt;
      if(iCoefsLeft>70 || iCoefsLeft<-70)return -1;

      iPrevCoefsCnt=coefs;
      v[0]=vlc.getDC();
      if(v[0])coefs++;

      if(v[0]>2048 || v[0]<-2048){
         return -2;
         //err detector
      }
      int iFrom=k==0?3:1;
      memset(&v[1],0,sizeof(DCT_TYPE)*(TVAL_DCT_SZ-1));
      int xv=0;
      if(iFrom==3){
         v[1]=vlc.getDC();
         v[8]=vlc.getDC();
         //v[1]=vlc.get_L_Val_S(2);
         //v[8]=vlc.get_L_Val_S(2);
         if(v[1])coefs++;
         if(v[8])coefs++;
         xv=(mmabs(v[1])+mmabs(v[8]))>>1;
      }
      if(coefs>64)return -1;
      for(i=iFrom;i<TVAL_DCT_SZ && iCoefsLeft>3 && iCoefsLeft+xv>16;i++){
         int val=vlc.get_L_Val_S(iCoefsLeft+xv>30?3:2);
         if(val){
            v[ZIG_ZAG_TAB[i]]=val;
            iCoefsLeft--;
         }
      }
      for(;i<TVAL_DCT_SZ && iCoefsLeft>0;i++){
         iCoefsLeft--;
            const int r=vlc.getNextAC(i);
           
         v[ZIG_ZAG_TAB[i]]=r;
      }
      //iPrevLastDec7x=i;
      //v[0]=-v[0];
   //   memset(&v[1],0,sizeof(DCT_TYPE)*(TVAL_DCT_SZ-1));
      //return 0;
    //  if(i==1)memset(&v[0],0,sizeof(DCT_TYPE)*(TVAL_DCT_SZ-1));
      //else { for(;i<TVAL_DCT_SZ;i++)v[xTab[i]]=0;}

     // if(iAdd==0)v[0]+=iPrevDc[k];
      return 0;


   }
   inline int enc7x(DCT_TYPE *v, short *p, int k, int iAdd)
   {
      //unsigned char *out=(unsigned char*)&bufTmp[0];

      int i;//,j,l=0;
//      short *old=p;
  //    int x=0;
    //  int iLastIs1=0;
      int iCoefsLeft=0;
    //  int valB1=0;
      int dc=0;
      //int iCanNotDiv2=;
      do{
         //if(!iHasDifOnly && !iIsKey)
         {
           // mbType[iMbTypePos]=iAdd==1;
         }
         if(iAdd==1){
            mbType[iMbTypePos]=1;
         }
         else{
            iHasDifOnly=0;
            mbType[iMbTypePos]=0;
         }
         iMbTypePos++;
/*
         if(iAdd==2){
            vlc.toVLC(0);
            vlc.toDC(0);
            return 2;
         }
         */
         int *xTab=(int*)&ZIG_ZAG_TAB[0];//:(int*)&tabzz4x4_second[0];
         dc=v[0];//-iPrevDc[k];
         if(iAdd==0)
            dc-=iPredDC;//iPrevDc[k];
         /*
         if(iAdd==2){
            vlc.toVLC(0);
            vlc.toDC(dc);
            iPrevCoefsCnt=0;
            break;
         }
         */
         
         int iFrom;//=k==0?3:1;
         if(k==0){
            iFrom=3;
            iCoefsLeft=notZeros(v,xTab,iFrom);
         }
         else{
            iFrom=1;
            iCoefsLeft=notZerosF(v,iFrom);
         }
         int val;
/*
         if(1){
            //vlc.toL_Val_S(iCoefsLeft-iPrevCoefsCnt,2);
            vlc.toDC(iCoefsLeft-iPrevCoefsCnt);
            iPrevCoefsCnt=iCoefsLeft;
         }
         else 
            vlc.toVLC(iCoefsLeft);
*/
         if(iPrevCoefsCnt>0)
            vlc.toDC(iCoefsLeft-iPrevCoefsCnt);
         else
            vlc.toVLC(iCoefsLeft);
         iPrevCoefsCnt=iCoefsLeft;

         vlc.toDC(dc);

         int xv=0;
         if(iFrom==3){
            //vlc.toL_Val_S(v[1],2);
            //vlc.toL_Val_S(v[8],2);
            xv=(mmabs(v[1])+mmabs(v[8]))>>1;
            //xv=max(mmabs(v[1]),mmabs(v[8]));
            vlc.toDC(v[1]);
            vlc.toDC(v[8]);
         }
         for(i=iFrom;i<TVAL_DCT_SZ && iCoefsLeft>0 ;i++){
            val=v[xTab[i]];
            if(val){
               if(iCoefsLeft+xv>16 && iCoefsLeft>3)vlc.toL_Val_S(val,iCoefsLeft+xv>30?3:2);else vlc.toAC(val);
               iCoefsLeft--;
            }else vlc.addB(1);
         }
         /*

         
         cnt=notZeros(v,xTab,1);
         int val;

         vlc.toDC(cnt-iPrevCoefsCnt);
         iPrevCoefsCnt=cnt;

         vlc.toDC(dc);
         int iPrevX=cnt>10?16:10;
         static int prevs[64][3];

         for(i=1;i<TVAL_DCT_SZ && cnt>0 ;i++){
            val=v[xTab[i]];
            if(val){
               //vlc.toAC(val);
               iPrevX+=prevs[i][k];iPrevX>>=1;
               if(iPrevX>64 &&  cnt>10)vlc.toL_Val_S(val,6);
               else if(iPrevX>32 &&  cnt>7)vlc.toL_Val_S(val,5);
               else if(iPrevX>16 &&  cnt>5)vlc.toL_Val_S(val,4);
               else if(iPrevX>8 && cnt>3)vlc.toL_Val_S(val,3);
               else if(iPrevX>4 && cnt>1)vlc.toL_Val_S(val,2);
               else vlc.toAC(val);
               iPrevX=mmabs(val);
               prevs[i][k]+=iPrevX;
               prevs[i][k]>>=1;

               cnt--;
            }
            else vlc.addB(1);
         }
      */
        // v[0]=c;
            
      }while(0);
      return 0;

      //tabzz4x4
   }

   inline int enc2x(DCT_TYPE *v, short *p, int k, int iAdd){
      int i,j;
      int val[4];
      int iSend;

      if(iAdd&1){
         mbType[iMbTypePos]=1+4;
      }
      else{
         mbType[iMbTypePos]=0+4;
      }
      iHasDifOnly=0;
      iMbTypePos++;
      
      for(j=0;j<16;j++)
      {
         iSend=0;
         for(i=0;i<4;i++){
           val[i]=v[i];
           if(val[i])iSend=1;
         }
         if(iSend){
            vlc.addB(1);
            //vlc.toL_Val_S(val[0],2);


            vlc.toDC(val[0]);
            vlc.toDC(val[1]);
            vlc.toDC(val[2]);
            vlc.toAC(val[3]);
         }
         else vlc.addB(0);
         v+=4;
      }
      return 0;
   }
   inline int enc2xT(DCT_TYPE *v){
      int i,j,f=0;;
      int vals[4],val;
      int mSend[16],iSend;
      int sc=0;
      int dcs=2;
//      static const int pt[]={0,1,4,3,2,5,6,7,8,9,10,11,12,13,14,15,};
      //f
    //  int findScore2x2(int val, int tid);
      int iFX=0;
      int iMax1=1;
//      int skC=0;
      for(j=0;j<16;j++)
      {
         mSend[j]=0;
         for(i=0;i<4;i++){
            if(v[i+j*4]){mSend[j]|=1<<i; if(abs(v[i+j*4])>1)iMax1=0;}
         }
         if(mSend[j]){
         //int scn=findScore2x2(sc,j+iFX*16);//8%
         //iBitGainX1sc+=vlc.bitsLen[sc];
        // iBitGainX1sc-=(scn+1);//vlc.bitsLen[scn];
         /*
         if(scn==0){skC++;}else{
            iBitGainX1sc-=vlc.bitsLen[skC];skC=0;
            iBitGainX1sc-=vlc.bitsLen[scn-1];
         }
         */
         iFX++;
            enc_coef_m15(vlc,sc);

            //vlc.addXBits(sc,4);
            sc=0;
         }
         else sc++;
         
        // vlc.addB(!!mSend[j]);
         //if(j!=15 && !mSend[j])sc++;
      }
      iBitGainX1sc--;//max1
      //if(sc)vlc.addXBits(sc,4);//
      
      if(sc){
         //int scn=findScore2x2(sc,16+iFX*16);
         //iBitGainX1sc+=vlc.bitsLen[sc];
         //iBitGainX1sc-=vlc.bitsLen[scn];
         /*
         if(scn==0){skC++;}else{
            iBitGainX1sc-=vlc.bitsLen[skC];skC=0;
            iBitGainX1sc-=vlc.bitsLen[scn-1];
         }
         */
         enc_coef_m15(vlc,sc);
      }
      //if(skC)iBitGainX1sc-=vlc.bitsLen[skC];
      int fPred=0;

      for(j=0;j<16;j++)
      {
         iSend=0;//mSend[j];
         if(mSend[j]){
            for(i=0;i<4;i++){
              vals[i]=v[i];
              if(vals[i]){iSend++;}
            }
         }
         // 0 100 101 110 111
         // 0 dc x
        // vlc.toVLC(iSend);
         if(iSend){
            fPred=0;
            if(j&3)fPred|=mSend[j-1];
            if(j>3)fPred|=mSend[j-4];
            fPred=0;
            f|=1;//(1<<(j));
          //----  vlc.addB(1);
#if 0
            vlc.addB((iSend-1)&2);
            vlc.addB((iSend-1)&1);
            for(i=0;i<4 && iSend;i++){
               val=vals[i];
               if( iSend+i==4){
                  if(val<0){vlc.toVLC(-val-1);vlc.addB(1);}else {vlc.toVLC(val-1);vlc.addB(0);} 
               }
               else if(iSend*2+i>3){
                  CTVLCX::encZero2b(vlc,val);
               }
               else {
                  vlc.toAC(val);
               }
               if(val)iSend--;
            }
#else
            //CTVLCX::encZero2b(vlc,vals[0]);
            if(dcs>0 || (fPred&1)){CTVLCX::encZero2b(vlc,vals[0]);if(!vals[0] && iMax1)iBitGainX1sc++;}else {vlc.toAC(vals[0]);if(vals[0] && iMax1)iBitGainX1sc++;}
            if(vals[0]){iSend--;dcs++;}else dcs--;
            if(iSend){
               if(vals[0])vlc.addB(1);
               //CTVLCX::encZero2b(vlc,vals[1]);
               if(fPred&2){CTVLCX::encZero2b(vlc,vals[1]);if(!vals[1] && iMax1)iBitGainX1sc++;} else {vlc.toAC(vals[1]);if(vals[1] && iMax1)iBitGainX1sc++;}
               if(!vals[1] && !(fPred&4)){vlc.toAC(vals[2]);if(vals[2] && iMax1)iBitGainX1sc++;}else {CTVLCX::encZero2b(vlc,vals[2]);if(!vals[2] && iMax1)iBitGainX1sc++;}
               if(vals[1]|vals[2]){if((fPred&8)){CTVLCX::encZero2b(vlc,vals[3]);if(!vals[3] && iMax1)iBitGainX1sc++;}else {vlc.toAC(vals[3]);if(vals[3] && iMax1)iBitGainX1sc++;}}else {CTVLCX::encNonZero(vlc,vals[3]);if(iMax1)iBitGainX1sc++;}
//               vlc.toAC(vals[3]);

               
            }
            else vlc.addB(0);
#endif

         }
         //----else vlc.addB(0);
         f<<=1;
         v+=4;
      }
      return f;
   }
   inline int dec2xT(DCT_TYPE *v, int *qQ){
      int i,j,f=0;;
      int vals[4],val,sc,dcs=2;
      int iSend,mSend[16];
//      static const int pt[]={0,1,4,3,2,5,6,7,8,9,10,11,12,13,14,15,};
//iBitGainX1+=8;
      int bp=vlc.iBitPos;
      sc=dec_coef_m15();
      //sc=vlc.getNBitsC(4);
      for(j=0;j<16;j++){
         //mSend[j]=vlc.getB();
         
         if(!sc){mSend[j]=1;if(j!=15)
            /*sc=vlc.getNBitsC(4);*/
            sc=dec_coef_m15(); 
         }else {sc--;mSend[j]=0;}
      }
      int fPred=0;
      //toVLC_X(,4)
      //iBitGainX1+=4;//(vlc.iBitPos-bp)-8;


      for(j=0;j<16;j++)
      {
         // 0 100 101 110 111
         if(mSend[j]){//vlc.getB()){
            fPred=0;
            if(j&3)fPred|=mSend[j-1];
            if(j>3)fPred|=mSend[j-4];
            fPred=0;
            v[3]=v[2]=v[1]=v[0]=0;
            f|=1;//(1<<(j));
#if 0            
            iSend=0;
            if(vlc.getB())iSend|=2;
            if(vlc.getB())iSend|=1;
            iSend++;
            for(i=0;i<4 && iSend;i++){
               if(iSend+i==4){
                  val=vlc.getVlc()+1;
                  if(vlc.getB())val=-val;
               }
               else if(iSend*2+i>3){
                  int r;
                  /*
                  if(vlc.getB()){
                     // zero or >1
                     if(vlc.getB()){continue;}
                     
                     if(vlc.getB()){
                        val=-vlc.getVlc()-2;
                     }
                     else{
                        val=vlc.getVlc()+2;
                     }
                     
                     //r=vlc.getAC();if(r<0)r--;else r+=2;
                  }
                  else{
                     val=vlc.getB()?-1:1;
                  }
                  */
                  val=CTVLCX::decZero2b(vlc);
                  if(!val){continue;}
               }
               else {
                  val=vlc.getAC();
                  if(!val){continue;}
               }
               v[i]=val*qQ[i];
               iSend--;
            }
#else

            /*
            if(dcs>0 || (fPred&1)){CTVLCX::encZero2b(vlc,vals[0]);if(!vals[0] && iMax1)iBitGainX1sc++;}else {vlc.toAC(vals[0]);if(vals[0] && iMax1)iBitGainX1sc++;}
            if(vals[0]){iSend--;dcs++;}else dcs--;
            if(iSend){
               if(vals[0])vlc.addB(1);
               //CTVLCX::encZero2b(vlc,vals[1]);
               if(fPred&2){CTVLCX::encZero2b(vlc,vals[1]);if(!vals[1] && iMax1)iBitGainX1sc++;} else {vlc.toAC(vals[1]);if(vals[1] && iMax1)iBitGainX1sc++;}
               if(!vals[1] && !(fPred&4)){vlc.toAC(vals[2]);if(vals[2] && iMax1)iBitGainX1sc++;}else {CTVLCX::encZero2b(vlc,vals[2]);if(!vals[2] && iMax1)iBitGainX1sc++;}
               if(vals[1]|vals[2]){if((fPred&8)){CTVLCX::encZero2b(vlc,vals[3]);if(!vals[3] && iMax1)iBitGainX1sc++;}else {vlc.toAC(vals[3]);if(vals[3] && iMax1)iBitGainX1sc++;}}else {CTVLCX::encNonZero(vlc,vals[3]);if(iMax1)iBitGainX1sc++;}
//               vlc.toAC(vals[3]);

               
            }
            else vlc.addB(0);

            */
            //v[0]=CTVLCX::decZero2b(vlc)*qQ[0];
            if(dcs>0 || (fPred&1))
               v[0]=CTVLCX::decZero2b(vlc);
            else 
               v[0]=vlc.getAC();
            if(v[0]){dcs++;v[0]*=qQ[0];}else dcs--;

            if(!v[0] || vlc.getB()){
               //v[1]=CTVLCX::decZero2b(vlc)*qQ[1];
               if((fPred&2))v[1]=CTVLCX::decZero2b(vlc)*qQ[1];else v[1]=vlc.getAC()*qQ[1];
//               v[2]=vlc.getAC()*qQ[2];
  //             v[3]=vlc.getAC()*qQ[3];
               if(!v[1] && !(fPred&4))v[2]=vlc.getAC()*qQ[2];else v[2]=CTVLCX::decZero2b(vlc)*qQ[2];
               if(v[1]|v[2]){if((fPred&8))v[3]=CTVLCX::decZero2b(vlc)*qQ[3];else v[3]=vlc.getAC()*qQ[3];}else v[3]=CTVLCX::decNonZero(vlc)*qQ[3];
            }
            if(v[0])mSend[j]|=1;
            if(v[1])mSend[j]|=2;
            if(v[2])mSend[j]|=4;
            if(v[3])mSend[j]|=8;
            
#endif
         }
         f<<=1;
         v+=4;
      }
      return f;
   }
   int calcG(int v, int sh, int L){
     
      vlcTest.iBitPos=0;
      int av=abs(v);
      if(!v)return 1; 
     // av++;
      //vlcTest.iBitPos++;
      //00 01 10 11 
        if(av<L){
           
           ///01xs
           ///01xs
           

           vlcTest.addXBits(1,((av+1)>>sh)+sh+3);
        }
        else{
           vlcTest.addXBits(1,((L+1)>>sh)+sh+3);
           vlcTest.toVLC_PN((av-L),1);
           vlcTest.addB(v<0);
        }
        return vlcTest.iBitPos;
   }
   template<class T>
   int  enc4x1(CTVLCX &vl,T *v,int from, int k, int to, int cl=-1){
      int i,val;
      int xx=0;
      if(cl==-1){
         cl=notZerosF(v,from,to);
         //  vlc.toVLC(cl);
         vl.addB(!cl);
         if(!cl)return 0;
         if(to>16)vl.toVLC(cl-1);else enc_coef_m15(vl,cl-1);
         xx=1;
      }
     // int *xTab=(int*)&tabzz4x4[0];
      const int iCL=cl;
     // iBitGainX1sc+=2;
      
     // const int iLim=((to)*7)>>3;
     // int bp=vl.iBitPos;
     // int sh=1;
      for(i=from;;i++){

         val=v[tabzz4x4[i]];
         if(val && iCL==1 && !xx){
            if(val<0)val++;
            else val--;
         }
       //if((unsigned)(val+1)>2)xx=1;

         

       //  bp=vl.iBitPos;

         if(i+cl==to){// || z[j]<=0){
           
            CTVLCX::encNonZero(vl,val);
            //if(val==2 || val==-2)iBitGainX1sc++;
           // pr1[i]++;
            cl--;if(!cl)break; 
         }
         //(i<8 && iCL>3) ||
         else if(POSIB_2Z(cl,to)){
            CTVLCX::encZero2b(vl,val);
         //   if(!sh)sh++;
            //vl.toVLC_PNS(val,sh);
//iBitGainX1sc+=(vlc.iBitPos-bp);
//iBitGainX1sc-=calcG(val,1,8);
            if(!val){continue;}
           // sh=(vl.iBitPos-bp)>>1;
            //pr1[i]++;
            cl--;          if(!cl)break;
         }
         else {
            if(val){
/*
        int mask = level[i] >> 15;
        int abs_level = (level[i]^mask)-mask;
        int i_level_code = abs_level*2-mask-2;

*/
//--if(val==2 || val==-2)iBitGainX1sc+=2;
              // pr1[i]++;
              // if(val==2 || val==-2)iBitGainX1sc++;
               vl.toAC(val);  
             //  sh=(vl.iBitPos-bp)>>1;
//iBitGainX1sc+=(vlc.iBitPos-bp);
//iBitGainX1sc-=calcG(val,1,8);

               cl--;if(!cl)break;
            }else {/*pr0[i]++; */ vl.addB(1); }
         }

      }
      return 0;
   }
   template<class T>
   int  enc4x1_dcTest(CTVLCX &vl, T *v, int cl){
      int i,val;
      const int iCL=cl;
     // iBitGainX1sc+=2;
      int sh=0;
     // const int iLim=((to)*7)>>3;
      for(i=1;i<16;i++){

         val=v[tabzz4x4[i]];
         int mask = val >> 31;
         int abs_val = ((val^mask)-mask);
         if(val && iCL==1){
            abs_val--;
         }
         
         if(i+cl==16){// || z[j]<=0){
           
            abs_val--;
            //CTVLCX::encNonZero(vl,val);
            vl.add000n1(abs_val>>sh);if(sh)vl.addXBits(abs_val,sh);
            sh=0;while(abs_val>(3<<sh))sh++;
            vl.addB(val<0);

            //if(val==2 || val==-2)iBitGainX1sc++;
           // pr1[i]++;
            cl--;if(!cl)break; 
         }
         else if(POSIB_2Z(cl,16)){
            if(!val){vl.add000n1(1);continue;}
            vl.add000n1(0);
            abs_val--;
            if(sh>0)sh--;
            vl.add000n1(abs_val>>sh);if(sh)vl.addXBits(abs_val,sh);

            vl.addB(val<0);
            sh=0;while(abs_val>(3<<sh))sh++;
            cl--;if(!cl)break;

         }
         else {
            if(val){
               //vl.toAC(val);  
               vl.add000n1(abs_val>>sh);if(sh)vl.addXBits(abs_val,sh);
               sh=0;while(abs_val>(3<<sh))sh++;
               cl--;if(!cl)break;
               vl.addB(val<0);
            }else {/*pr0[i]++; */ vl.add000n1(0); }
         }

      }
      return 0;
   }
   inline int enc4x(DCT_TYPE *v, short *p, int k, int iAdd)
   {
      
      //unsigned char *out=(unsigned char*)&bufTmp[0];

      int i,j;
//      short *old=p;
  //    int x=0;
    //  int iLastIs1=0;
      int xcnt[4];
    //  int valB1=0;
      int dc=0;
      //int iCanNotDiv2=;
      do{
         if(iAdd==1){
            mbType[iMbTypePos]=1+2;
         }
         else{
            mbType[iMbTypePos]=0+2;
         }
         iHasDifOnly=0;
         iMbTypePos++;

         int *xTab=(int*)&tabzz4x4[0];//:(int*)&tabzz4x4_second[0];
        // dc=v[0];//-iPrevDc[k];
         
         DCT_TYPE dcs[4]={v[0],v[16],v[32],v[48]};
         int iDC=0;
         void t_fdc2(DCT_TYPE *x);
         if(iAdd==0){
            dc=v[0];v[0]-=iPredDC;v[16]-=dc;v[32]-=dc;v[48]-=dc;
            
           // t_fdc2(v);  v[0]-=iPredDC;
            iDC=1;
         }
         //else t_fdc2(v);
//         else if(vlc.iCalcBitsOnly==0)iBitsGain2x2_test--;

         xcnt[0]=notZerosF(v,0,16);
         xcnt[1]=notZerosF(v,16,32);
         xcnt[2]=notZerosF(v,32,48);
         xcnt[3]=notZerosF(v,48,64);
         int val;
         /*
         vlc.toL_Val(xcnt[0],2);
         vlc.toL_Val(xcnt[1],2);
         vlc.toL_Val(xcnt[2],2);
         vlc.toL_Val(xcnt[3],2);
*/
         vlc.toVLC(xcnt[0]);
         vlc.toVLC(xcnt[1]);
         vlc.toVLC(xcnt[2]);
         vlc.toVLC(xcnt[3]);
         //0

         for(j=0;j<4;j++)
         {
            //int h=xcnt[j]>>1;
            
            for(i=0;i<1 && xcnt[j]>0 ;i++){
               val=v[xTab[i]];
               if(val){
                  if(0 && i==0){
                     if(val==-2)val=-1;
                     else if(val==-1)val=-2;
                     else if(val==1)val=2;
                     else if(val==2)val=1;
                  }

                  //const int tt4x[]={2,3,3,2};
                  //vlc.toL_Val_S(val,2);
                  vlc.toDC(val);
                  //vlc.toAC(val);
                  xcnt[j]--;
               }
               else {vlc.addB(1);}
            }
            
            //if(iDC)vlc.toDC(v[xTab[0]]);

            for(i=1;i<16 && xcnt[j]>0 ;i++){
               val=v[xTab[i]];
               if(val){vlc.toAC(val);xcnt[j]--;}else {vlc.addB(1); }
            }
            xTab+=16;
         }

         if(iAdd==0){
            v[0]=dcs[0];
            v[16]=dcs[1];
            v[32]=dcs[2];
            v[48]=dcs[3];
         }
        // v[0]=c;
            
      }while(0);
      
      return 0;

      //tabzz4x4
   }
  inline int dec_coef_m15(){
      int b=vlc.iBitPos;//TODO set bit limit
      int c=vlc.getVlc();
      //if(i==3 && !lc)iCoefsLeft[i]++;
      //lc+=iCoefsLeft[i];
      const static int et[]={0,1,2,4,5,6,7,8,9,10,11,12,13,14,15,3};
      if(c>14 || vlc.iBitPos-b>7){
         /*
0001000 14     7b
000010000 30 9b
           00001xxxx=cnt=15
         */
        // if(iCoefsLeft[i]>30)return -3;
         vlc.iBitPos=b+4;c=15;
      }
      
  //    if(iCoefsLeft[i]==15)iCoefsLeft[i]=3;else if(iCoefsLeft[i]==3)iCoefsLeft[i]=14;
    //  else if(iCoefsLeft[i]==14)iCoefsLeft[i]=15;
      
      return et[c];
   }
   static inline void enc_coef_m15(CTVLCX &vlcx,int e){
      const static int et[]={0,1,2,15,3,4,5,6,7,8,9,10,11,12,13,14,};
      if(e){
         e=et[e];
         vlcx.toVLC(e);
         if(e==15)vlcx.iBitPos-=5;
      }
      else vlcx.addB(1);
   }
   
   inline void enc_c_cnt4(int *c){
      int mi=0;
      int i;
      enc_coef_m15(vlc,c[0]);
      enc_coef_m15(vlc,c[1]);
      enc_coef_m15(vlc,c[2]);
      enc_coef_m15(vlc,c[3]-(!(c[0]|c[1]|c[2])));
return;

      for(i=2;i<4;i++){
         if(i==2)mi=min(c[0],c[1]);
         else if(i==3)mi=GET_MIN3(c[1],c[0],c[2]);
         if(mi){
            if(!c[i])
               vlc.addB(1);
            else{
               vlc.addB(0);
               if(mi==1)enc_coef_m15(vlc,c[i]-1);else vlc.toAC(c[i]-mi);
            }
         }
         else
         {
            enc_coef_m15(vlc,c[i]);
         }
      }
   }
   inline void dec_c_cnt4(int *c){
      int mi=0;
      int i;
      c[0]=dec_coef_m15();
      c[1]=dec_coef_m15();
      
      c[2]=dec_coef_m15();
      c[3]=dec_coef_m15()+(!(c[0]|c[1]|c[2]));
      return;
      
      for(i=2;i<4;i++){
         if(i==2)mi=min(c[0],c[1]);
         else if(i==3)mi=GET_MIN3(c[1],c[0],c[2]);
         if(mi){
            if(vlc.getB())
               c[i]=0;
            else{
               vlc.addB(0);
               if(mi==1)c[i]=dec_coef_m15()+1;else c[i]=vlc.getAC()+mi;
            }
         }
         else
         {
            c[i]=dec_coef_m15();
         }
      }
   }
   inline int enc4x_15_pic_new2(DCT_TYPE *v, int k, int iAdd)
   {
      int i,j;
      int xcnt[4];
      int cl;
      int iDecDct4x4O=0;
    //  int valB1=0;
      //int bp=vlc.iBitPos;
      //int dc=0;
      int *xTab=(int*)&tabzz4x4[0];
      //int iCanNotDiv2=;
      //do{

         iDecDct4x4=0;
         xcnt[0]=notZerosAligned(v,1,16);
         xcnt[1]=notZerosAligned(v,17,32);
         xcnt[2]=notZerosAligned(v,33,48);
         xcnt[3]=notZerosAligned(v,49,64);

         int val;
         int sk[]={0,0,0,0,};

         static const int tDcttxt[4]={1,2,4,8};
         for(j=0;j<4;j++){
            if(xcnt[j]==1){
               if(v[(j<<4)+1]){pr1[1]++;vlc.toVLC(1);sk[j]=1;CTVLCX::encNonZero(vlc,v[(j<<4)+1]);iDecDct4x4|=tDcttxt[j];}
               else if(v[(j<<4)+4]){pr1[4]++;vlc.toVLC(2);sk[j]=1;CTVLCX::encNonZero(vlc,v[(j<<4)+4]);iDecDct4x4|=tDcttxt[j];}
               else vlc.toVLC(xcnt[j]+2);
            }
            else if(xcnt[j]) vlc.toVLC(xcnt[j]+2);
            else vlc.toVLC(0);
         }

         
         //int iLastI=14;
         const int iLim=k?12:14;
         //int coze=-5;

         for(j=0;j<4;j++)
         {
            cl=xcnt[j];
            if(cl && !sk[j]){
               iDecDct4x4|=tDcttxt[j];
                  int z=0;
                  for(i=xcnt[j]==1?3:1;;i++){
                     //if(cl==1 && z[j]>0){i+=z[j];z[j]=0;}
                     const int i2=pr0[i]*5<pr1[i]*4;
                     val=v[xTab[i]];
                     if(val)pr1[i]++; else pr0[i]++;
                     /*
                     if(cl==1){
                        if(!val){z++;continue;}
                        if(val==1 || val==-1){
                           vlc.toVLC(z);
                           vlc.addB(val<0);
                        }
                        else {
                           vlc.toVLC(z+16);
                           if(val<0){vlc.toVLC(-val-1);vlc.addB(1);}else {vlc.toVLC(val-1);vlc.addB(0);} 
                        }
                        break;
                     }
                     */
                     


                     
                     if(i+cl==16){// || z[j]<=0){
                        if(val<0){vlc.toVLC(-val-1);vlc.addB(1);}else {vlc.toVLC(val-1);vlc.addB(0);} 
                        cl--;if(!cl)break; 
                     }//(coze>0) ||//cl*4+i>iLim && 
                     else if(cl*2+i>iLim ||  (i2)){// || z[j]<cl){
                        CTVLCX::encZero2b(vlc,val);
                        if(!val)continue;
                        /*
                        if(val==0){vlc.addB(1); vlc.addB(1);coze--; continue;}//z[j]--;
                        else if(val==1){vlc.addB(0); vlc.addB(0); }
                        else if(val==-1){vlc.addB(0); vlc.addB(1); }
                        else {vlc.addB(1); vlc.addB(0); if(val>0){vlc.addB(0);vlc.toVLC(val-2);}else {vlc.addB(1);vlc.toVLC(-val-2);}}
                        //else {vlc.addB(1); vlc.addB(0); if(val>0)val-=2;else val++;vlc.toAC(val);}
                        */
                        cl--;
                        if(!cl)break;
                     }
                     else {
                        if(val){
                           vlc.toAC(val);   cl--;if(!cl)break;
                        }else   vlc.addB(1); 
                     }
           //          if(val)coze++;else {coze--;}//z[j]--;
                  }

             //     coze++;
                  //iLastI=i-1;

            }
            xTab+=16;
         }
         //iBitGainX1+=((vlc.iBitPos-bp)>>3);

        // v[0]=c;
            
      //}while(0);
      if(iDecDct4x4O)iDecDct4x4=iDecDct4x4O;
      return 0;

      //tabzz4x4
   }
   template<class T>
   int blockParams(T *v, const int *t, int &iCnt, int &iLast ,int &iLastS,int iFrom,int iTo){
      iCnt=0;
      iLast=0;
     //int st=notZerosAligned(v,iFrom,iTo);
      //return;
      iTo--;
      int iLastC=0;
      for(;iTo>=iFrom;iTo--){if(v[t[iTo]]){iLastC=v[t[iTo]];iCnt++;iLast++;;break;}}
      iTo--;
      for(;iTo>=iFrom;iTo--){
         if(v[t[iTo]])iCnt++;
         else if(iCnt==1)iLast++;
      }
     // if(iCnt && iLast)iLast--;
//iLast=0;
      if(iLast>7)iLast=7;
      else if((unsigned)(iLastC+1)>2){
         iLast=0;
      }
      iLastS=(iLastC<0);
/*
      iLast=0;
      if(st!=iCnt){
         return -1;
      }
      */
      return 0;

   }
   int getPredX(int *iCoefsLeft,int j){
   //   return 0;
      int i;
      int co=0;
#if 1
      for(i=1;i<=j;i++){
         if(i==1)co=iCoefsLeft[i-1];else if(iCoefsLeft[i-1]){
         co+=iCoefsLeft[i-1]*2;
         co++;co>>=1;}
      }
#else
      for(i=1;i<=j;i++){
         if(co==0)co=iCoefsLeft[i-1];else if(iCoefsLeft[i-1]){
         co+=iCoefsLeft[i-1];
         co++;co>>=1;}
      }
#endif
      co+=2;co=co>>2;//tabP[co];
      if(co>4)co=4;
      if(j)co++;
      return co;

   }
   int getPredX2(int *iCoefsLeft, int *last,int j){

      int i;
      int co=0;
      int co1=0;
#if 0
      switch(j){
         case 1: co=last[0]+(!!iCoefsLeft[0]);
            break;
         case 2: co=(last[0]+(!!iCoefsLeft[0]));
             if(!co)co1=(last[1]+(!!iCoefsLeft[1]));
             break;
         case 3: co=(last[1]+(!!iCoefsLeft[1]));
                co1=(last[2]+(!!iCoefsLeft[2]));
                if(!(co|co1))co=last[0]+(!!iCoefsLeft[0]);
                break;
      }
      if(co && co1){
         co+=co1+1;co>>=1;
      }
      else if(co1)co=co1;

      co+=2;co=co>>2;
      //const static int t[18]={0,0,1,1,2,2,2,2,3,3,3,3,3,3,3,3,3,3};co=t[co];
      if(j)co++;

#else
      for(i=1;i<=j;i++){
         if(co==0)
            co=last[i-1]+(!!iCoefsLeft[i-1]);
         else if(iCoefsLeft[i-1]){
            co+=last[i-1]+2;
            co>>=1;
         }
      }
      //const static int t[18]={0,0,1,1,2,2,2,2,3,3,3,3,3,3,3,3,3,3};co=t[co];
      
      if(j){co+=6;co=co>>2;}
#endif
      
      return co;

   }
   inline int enc4x_15_pic_new_last_one(DCT_TYPE *v, int k, int iAdd)
   {
      int i,j;
      int iCoefsLeft[4];
      int iLastS[4];
      int iLastT[4];
      int cl;
      int iDecDct4x4O=0;
      int val;
      const int iLim=k?12:14;
    //  int valB1=0;
      //int bp=vlc.iBitPos;
      //int dc=0;
      int *xTab=(int*)&tabzz4x4[0];
      iDecDct4x4=0;
      //int iCanNotDiv2=;
      //do{
      blockParams(v,&tabzz4x4[0],iCoefsLeft[0],iLastT[0],iLastS[0],1,16);
      blockParams(v,&tabzz4x4[0],iCoefsLeft[1],iLastT[1],iLastS[1],17,32);
      blockParams(v,&tabzz4x4[0],iCoefsLeft[2],iLastT[2],iLastS[2],33,48);
      blockParams(v,&tabzz4x4[0],iCoefsLeft[3],iLastT[3],iLastS[3],49,64);
      

      int tab_id=((iAdd==0)<<1)+(!k);
      int iCoEnc=0;
//         int code=(k)?vlc.getVlc():((j==3 && !iCoDec)?vlc.getVlc_PN(1):vlc.getVlc_PNZ(3)));
  //       if(iBlocks8orMore){code<<=1;code|=vlc.getB();}

      //         int code=(k && !iBlocks8orMore)?vlc.getVlc():((j==3 && !iCoDec)?vlc.getVlc_PN(2+iBlocks8orMore):(iBlocks8orMore?vlc.getVlc_PN(2):vlc.getVlc_PNZ(3)));
#define ADD_PCODE(_C)(k && !iBlocks8orMore)?vlc.toVLC(_C):((screm || iBlocks8orMore || (j>=2 && !iCoEnc))?vlc.toVLC_PN(_C,2):vlc.toVLC_PNZ(_C,3));
//#define ADD_PCODE(_C) (k && !iBlocks8orMore)?vlc.toVLC((_C)>>iBlocks8orMore):((j==3 && !iCoEnc)?vlc.toVLC_PN((_C)>>iBlocks8orMore,1):vlc.toVLC_PNZ((_C)>>iBlocks8orMore,3));if(iBlocks8orMore){vlc.addB((_C)&1);}

         for(j=0;j<4;j++)
         {
            cl=iCoefsLeft[j];
            if(!cl){
              // if(k && !iBlocks8orMore)vlc.addB(1);
               //else if((j>=2 && !iCoEnc) || iBlocks8orMore)vlc.toVLC_PN(0,2-iBlocks8orMore);else vlc.toVLC_PNZ(0,3);
               int screm=0;
               ADD_PCODE(0);
               xTab+=16;
               continue;
            }

int bp=vlc.iBitPos;
            
            int findScoreCntLast_def(int iCnt, int iLast, int  id);
            int sc=findScoreCntLast_def(iCoefsLeft[j],iLastT[j],tab_id+getPredX(&iCoefsLeft[0],j)*4);

            int screm=(j==3 && !iCoEnc);
            ADD_PCODE(1+sc-screm);
            //if(k && !iBlocks8orMore)vlc.toVLC(1+sc-screm);
            //else if((j>=2 && !iCoEnc) || iBlocks8orMore)vlc.toVLC_PN(1+sc-screm,2-iBlocks8orMore);else vlc.toVLC_PNZ(1+sc-screm,3);
            iCoEnc+=cl;


            {
               iDecDct4x4|=(1<<j);
                  
               int iWasZero=0;
                  int iLastCo=iLastT[j];
                  int iCoReal=iLastCo?(iLastCo-1):0;
                  for(i=1;;i++){

                     if(cl==1 && iLastCo){
                       // for(int zzz=i;zzz<i+iCoReal;zzz++)pr0[i]++;
                        if(iLastCo<7){
                           vlc.addB(iLastS[j]);
                           i+=iCoReal;
                           PRXADD;
                           break;
                        }
                        PRXREM;
                        iCoReal=0;
                        iLastCo=0;
                        i+=6;
                     }
                     //if(cl==1 && z[j]>0){i+=z[j];z[j]=0;}
                     const int i2=prx[i]>0;//
                     //const int i2=pr0[i]*5<pr1[i]*4;// && (cl+iCoReal)*4+i>iLim;
                     val=v[xTab[i]];
                     if(val){ PRXADD;}else {PRXREM;}
 
                   //  bp=vlc.iBitPos;
                     if(i+cl+iCoReal==16){// || z[j]<=0){
                        CTVLCX::encNonZero(vlc,val);//if(val<0){vlc.toVLC(-val-1);vlc.addB(1);}else {vlc.toVLC(val-1);vlc.addB(0);} 
               //vlc.toVLC_PN((val=val>=0?(val<<1):(((-val)<<1)-1))-1,(18-i)>>1);
                        cl--;if(!cl)break; 
                     }
                     else if((!iWasZero)
                        || (i2) ||
                        ((cl)*2+((iCoReal*3)>>1)+i>=16 )
                        
                        //POSIB_2Z(cl,(16-iCoReal))
                        
                        ){
                        CTVLCX::encZero2b(vlc,val);
//iBitGainX1sc+=(vlc.iBitPos-bp);
//iBitGainX1sc-=calcG(val,1,8);
                        if(!val){iWasZero=1;continue;}

                        cl--;
                        if(!cl)break;
                     }
                     else {
                        if(val){
                          // if(val==2 || val==-2)iBitGainX1sc++;
                           vlc.toAC(val);
//iBitGainX1sc+=(vlc.iBitPos-bp);
//iBitGainX1sc-=calcG(val,1,8);

                           cl--;if(!cl)break;
                        }else   vlc.addB(1); 
                     }
                  }

            }
//   inline int enc1x_15_pic_new_last_one(T *v, int k, int iAdd, CTVLCX *pvlc, int *iCoefsLeft=NULL, int j=0)

 //vlcTest.iBitPos=0;enc1x_15_pic_new_last_one<2,short>(v+j*16,iAdd,k,&vlcTest,&iCoefsLeft[0],j);int nl=vlcTest.iBitPos;iBitGainX1sc-=nl;iBitGainX1sc+=(vlc.iBitPos-bp);

            
            //vlcTest.iBitPos=0;enc1x_15_dif_dc<0,short>(vlcTest,v+j*16,!iAdd,0);int nl=vlcTest.iBitPos;iBitGainX1sc-=nl;iBitGainX1sc+=(vlc.iBitPos-bp);
            //vlcTest.iBitPos=0;enc1x4x15TX<0,short,0>(v+j*16,!iAdd,k,vlcTest,&iCoefsLeft[0],j);int nl=vlcTest.iBitPos;iBitGainX1sc-=nl;iBitGainX1sc+=(vlc.iBitPos-bp);
            //debugs2i("oxn",(vlc.iBitPos-bp),nl);

            xTab+=16;
         }
         //iBitGainX1+=((vlc.iBitPos-bp)>>3);

        // v[0]=c;
            
      //}while(0);
      if(iDecDct4x4O)iDecDct4x4=iDecDct4x4O;
      return 0;

      //tabzz4x4
   }
   int findNextPos(unsigned char *p, int i){
      i++;
      for(;i<16;i++){
         if(p[tabzz4x4[i]]>0)break;
      }
      if(i>15)i=15;
      return i;
   }
   
   CTVLCX vlcTest;
   template<int dc,class T, int X2>
   int enc1x4x15TX_notgood(T *v, int iPic,int k, CTVLCX &xvlc, int *co=NULL, int j=0)
   {
      int findScoreTR_COEFS(int val, int tid);
      int i, c[15];
      int ofs[15];
      int tr=0;
      int iMaxVal=0;
      int iOnes=0;
      int iCoefs=0,iZeros=0;
      int val;
      int sk=0;
      int tid=(!!iPic)|((!!dc)<<1)|((!k)<<2);
 
      int zbtr=0;
      for(i=1;i<16;i++){
         val=v[tabzz4x4[i]];//4771,91
         //val=v[t4x[i]];
         if(val){
            //if(!iWasZero)iCoefsWOZ++;
            c[iCoefs]=val;
            ofs[iCoefs]=sk;
            iCoefs++;
            if(abs(val)>iMaxVal)iMaxVal=abs(val);
            if(sk){
               if((((unsigned)(val+1))<=2)){
                  tr++;
                  iOnes++;
               } 
               else {tr=0;}
            }
            else {
               tr=0;
            }

            
            //if((((unsigned)(val+1))<=2))iPrevCoefMax=2;
//            if(sk)iTR++;else iTR=0;
           // if(!tr)zbtr+=sk;
            iZeros+=sk;
            sk=0;
         }
         else {sk++;}//iCoefsWOZ=0;iWasZero=1;}
      }
      if(!dc)co[j]=iCoefs;
      //if(tr1>3)tr1=3;
      //if(tr>3)tr=3;*2+(_iPrevCoefMax-1)
      //coefi, tikai virs 1,pedejais virs 1, tr01 vai tr0n1,
     // int sc=findScoreTR_COEFS(((iCoefs*16+iLastNotZOne)*16+iFirstB)*8+tr,tid)+!dc;
      //int sc=findScoreTR_COEFS(((iCoefs*16+iLastNotZOne)*16+iFirstZero)*8+tr,tid)+!dc;
     // printf("co=%d,tr=%d,iLastNotZOne=%d\n",iCoefs,tr,iLastNotZOne);
      //iLastNotZOne=15;
      //iLastNotZOne=ofs[0];if(iLastNotZOne>8)iLastNotZOne=8;
      //if(ofs[0]>3 || abs(c[0])>3)iLastNotZOne=15;
      //else iLastNotZOne=(ofs[0])+(abs(c[0])-1)*4;
      const int iCoefsWO_Z1=iCoefs-tr;
      //for(i=iCoefsWO_Z1;i<iCoefs;i++)zbtr+=ofs[i];
      //iLastNotZOne=ofs[iCoefs-1]
      //iLastNotZOne=iCoefs;tr=0;int sc=iCoefs-(!!dc);
      if(iMaxVal>16)iMaxVal=16;
      int sc=findScoreTR_COEFS(((iCoefs*16+iMaxVal-1))*8+tr,tid)+!dc;
#if 0
      if(sc>iMaxXX)iMaxXX=sc;
      static int iAvgX[8];
      static int iAvgC[8];
      int lx=0;
      while(sc>(1<<lx))lx++;
      lx++;
      iAvgC[tid]++;
      iAvgX[tid]+=lx;
      static int iDbgC;iDbgC++;
      if((iDbgC&127)==0 || 1)debugs2i("max",iMaxXX,sc);//iAvgX[tid]/iAvgC[tid]
#endif
#define BSH 4     
     // int sc=findScoreTR_COEFS((tr*16+iZeros),tid)+!dc;
      if(X2){
         
         if(sc>16){
            xvlc.toVLC_X(sc,16);
            xvlc.toVLC_PN(sc-16,3);
         }
         else
         xvlc.toVLC_X(sc,2);
      }else 
      if(1){
         if(!dc){
            //if(tid==3)xvlc.addB(sc?1:0);sc--;
            if(sc>=0)xvlc.toVLC(sc);
         }
         else xvlc.toVLC(sc);
      }else
      if(0){
         if(dc)xvlc.toVLC_PN(sc,3);else
         xvlc.toVLC_PNZ(sc,3);
      }
      else if(dc || !X2){
         if(tid!=5 && tid!=1 && tid!=0){xvlc.addB(sc?1:0);sc--;}
         if(tid!=5 && tid!=1 && tid!=0 && sc<0){}else
         if(tid==1 || tid==0){if(sc<6)xvlc.addXBits(1,sc);else{xvlc.addXBits(1,6);xvlc.toVLC(sc-6); }}else 
         //1 01x

         //if(1)xvlc.toVLC_PNZ(sc,2);else
         //1  01x 01x 001xxxx
         //1 01, 001
         //if(dc){if(sc<1)xvlc.addXBits(1,sc+1);else {xvlc.addXBits(1,2);xvlc.toVLC_PN(sc-1,1);}}else//xvlc.addXBits(1,((sc-2)>>4)+5);} else
         //if(tid==5 ||1){if(sc<3)xvlc.addXBits(1,((sc+1)>>1)+2);else xvlc.addXBits(1,((sc-3)>>4)+5);} else
         //if(tid==5 ||1){if(sc<3)xvlc.addXBits(1,((sc+1)>>1)+2);else {xvlc.addXBits(1,3);xvlc.toVLC_X((sc-3),2);}} else
         //if()xvlc.toVLC(sc);else
         //if(tid==7)xvlc.addXBits(1,(sc>>3)+4);else //1xxx
         //if(tid==5){if(sc==0)xvlc.addXBits(1,1);else if(sc==1)xvlc.addXBits(1,2);else {xvlc.addXBits(1,3);xvlc.toVLC_X((sc-2),3);}}else
         ///if(tid==3){if(sc==0)xvlc.addXBits(1,1);else xvlc.addXBits(1,((sc-1)>>4)+5);}else
         //if(dc && !iPic)xvlc.toVLC_PN(sc,1);else
         if(tid!=5)xvlc.toVLC(sc);else
//1 01xxx
xvlc.toVLC_PNZ(sc,3);
         //{xvlc.toVLC(sc>>2);xvlc.addXBits(sc,2);}
         //{xvlc.toVLC((sc+3)>>2);xvlc.addXBits(sc,2);}
         //{xvlc.addXBits(1,((sc+15)>>BSH)+BSH+1);}
         //{if(sc<3)xvlc.addXBits(1,(sc>>1)+2);else xvlc.addXBits(1,((sc-3)>>4)+5);}
         /*
         if(dc){
            //xvlc.toVLC(sc);
            //xvlc.addXBits(1,(sc>>BSH)+BSH+1);//1xxx 01xxx 001xxx //tr1 tr
            xvlc.toVLC_PN(sc,2);

            //xvlc.addXBits(1,(sc>>2)+3+(!dc));//1xxx 01xxx 001xxx
         }else xvlc.toVLC(sc);
         */
      }
      else if(X2){
         
         if(sc>4){
            xvlc.toVLC_X(sc,4);
            xvlc.toVLC_PN(sc-4,3);
         }
         else
         xvlc.toVLC_X(sc,2);
         
         //xvlc.toVLC_X(4,2);         xvlc.toVLC_PN(sc-1,2);
      }
      else{
         //xvlc.addXBits(1,(sc>>3)+5);
         xvlc.toVLC(sc);
      }
      int pos=1;
      int iSufLen=0;//iCoefsWO_Z1>10 && tr<2;
      while(iMaxVal>(3<<iSufLen))iSufLen++;

      for(i=0;i<iCoefsWO_Z1;i++){
         int iMaxZLeft=16-(iCoefsWO_Z1-i)-(pos+(tr)*2);//+(zbtr-tr));
         int iAdd001=iMaxZLeft>0  &&(i+1<iCoefsWO_Z1 || (c[i]!=-1 && c[i]!=1));
         if(iMaxVal>1){
#if 1
        int mask = c[i] >> 31;
        int iEncV = (c[i]^mask)-mask-1;
        if(i+1==iCoefsWO_Z1 && ofs[i]==0){iSufLen=0;iEncV--;}
           if((iEncV>>iSufLen)<8){
          // if(i_level_code<8){
//101 100 110 111 0101 0100 0111 0110 ,, 1 01 001 0001 00001
              //xvlc.addXBits(1,i_level_code+1);
              xvlc.addXBits(1,(iEncV>>iSufLen)+1);
           if(iSufLen)xvlc.addXBits(iEncV,iSufLen);
              iSufLen>>=1;

           }
           else{
              
              xvlc.addXBits(1,9); xvlc.toVLC((iEncV>>iSufLen)-8);
           if(iSufLen)xvlc.addXBits(iEncV,iSufLen);
              iSufLen++;
              //iSufLen+=2;
             // xvlc.addXBits(1,9);xvlc.toVLC(i_level_code-8);
           }
           if(iMaxVal==iEncV+1)iSufLen>>=1;
           if(iSufLen<0)iSufLen=0;else if(iSufLen>6)iSufLen=6;
           //if(!sufLen)sufLen++;
           //if(abs_v>(3<<(sufLen)) && sufLen<6)sufLen++;
           //if(abs_v<2)sufLen=0;
           

            
//           if(iAdd001) xvlc.toVLC(ofs[i]);
#else
           #define SGN_MAPNZ(_A) (_A>=0?((_A-1)<<1):(((-_A)<<1)-1))
           
            if(iAdd001){
               iAdd001=0;
               int m=16-(iCoefsWO_Z1-i)-(pos+(tr)*2);
               int cr=findScoreCoefRun(SGN_MAPNZ(c[i])*m+ofs[i],tr);
                xvlc.toVLC_PN(cr,2);
            }
            else{
               CTVLCX::encNonZero(xvlc,c[i]);
            }
#endif
            //CTVLCX::encNonZero(xvlc,c[i]);
         }
          xvlc.addB(c[i]<0);
         if(iAdd001) {
            if(iMaxZLeft==1)xvlc.addB(ofs[i]);else xvlc.add000n1(ofs[i]);
         }
         pos+=ofs[i]+1;
         
      }


      for(;i<iCoefs;i++){
         
         
         if(pos+tr*2<16){// && pos+zbtr+tr<16 && tr!=1)
             int iMaxZLeft=16-(iCoefs-i)-(pos+(tr)*2);//+(zbtr-tr));
             //if(iMaxZLeft>7)xvlc.add000n1(ofs[i]-1);else 
             //xvlc.addXBits(x264_run_before[iMaxZLeft-1][ofs[i]-1].i_bits,x264_run_before[iMaxZLeft-1][ofs[i]-1].i_size);
             if(tr==1 && (iMaxZLeft==1 || iMaxZLeft==2))xvlc.addB(ofs[i]-1);else xvlc.add000n1(ofs[i]-1);
         }
      //      xvlc.add000n1(ofs[i]-1);
         //zbtr-=ofs[i];
         tr--;
         xvlc.addB(c[i]<0);
         pos+=(ofs[i])+1;
      }
      return 0;
   }

   template<int dc,class T, int X2>
   int enc1x4x15TX(T *v, int iPic,int k, CTVLCX &xvlc, int *co=NULL, int j=0)
   {
      int findScoreTR_COEFS(int val, int tid);
      int i, c[15];
      int ofs[15];
      int tr=0,iFirstB=0;
      int iLastNotZOne=0;
      int iOnes=0;
      int iCoefs=0,iZeros=0;
      int iFirstZero=0;
      int val;
      int sk=0;
//      int tid=(!!iPic)|((!!dc)<<1)|((!k)<<2);
      int tid=(!!iPic)|((!!dc)<<1)|((this->iDCQuant>199)<<2)|((!k)<<3);
      //int iCoefsWOZ=0;
      //int iWasZero=0;
  //    int iTR=0;
      //int _iPrevCoefMax=iPrevCoefMax;
      //iPrevCoefMax=1;
      const static int t4x[]={
         0,   1,   4,   5,    2,   8,   6,   9,    3,   12,   7,   10,    13,   11,   14,   15,
         //0,   5,1,   4,       2,   8,   6,   9,    3,   12,   7,   10,    13,   11,   14,   15,
      };
      int zbtr=0;
      int iLastCoef=0;
      for(i=1;i<16;i++){
         val=v[tabzz4x4[i]];//4771,91
         //val=v[t4x[i]];
         if(val){
            iLastCoef=i;
            //if(!iWasZero)iCoefsWOZ++;
            c[iCoefs]=val;
            ofs[iCoefs]=sk;
            iCoefs++;
            if(sk){
               if((((unsigned)(val+1))<=2)){
                  tr++;
                  iOnes++;
               } 
               else {iLastNotZOne=iCoefs;tr=0;if(!iOnes)iFirstB=iCoefs;}
            }
            else {
               tr=0;
               if((((unsigned)(val+1))<=2)){
                  iOnes++;
               } 
               else {iLastNotZOne=iCoefs;if(!iOnes)iFirstB=iCoefs;}
            }

            
            //if((((unsigned)(val+1))<=2))iPrevCoefMax=2;
//            if(sk)iTR++;else iTR=0;
           // if(!tr)zbtr+=sk;
            iZeros+=sk;
            sk=0;
         }
         else {sk++;if(iFirstZero==0)iFirstZero=iCoefs;}//iCoefsWOZ=0;iWasZero=1;}
      }
      if(!dc)co[j]=iCoefs;
      //if(tr1>3)tr1=3;
      //if(tr>3)tr=3;*2+(_iPrevCoefMax-1)
      //coefi, tikai virs 1,pedejais virs 1, tr01 vai tr0n1,
     // int sc=findScoreTR_COEFS(((iCoefs*16+iLastNotZOne)*16+iFirstB)*8+tr,tid)+!dc;
      //int sc=findScoreTR_COEFS(((iCoefs*16+iLastNotZOne)*16+iFirstZero)*8+tr,tid)+!dc;
     // printf("co=%d,tr=%d,iLastNotZOne=%d\n",iCoefs,tr,iLastNotZOne);
      //iLastNotZOne=15;
      //iLastNotZOne=ofs[0];if(iLastNotZOne>8)iLastNotZOne=8;
      //if(ofs[0]>3 || abs(c[0])>3)iLastNotZOne=15;
      //else iLastNotZOne=(ofs[0])+(abs(c[0])-1)*4;
      //for(i=iCoefsWO_Z1;i<iCoefs;i++)zbtr+=ofs[i];
      //iLastNotZOne=ofs[iCoefs-1]
      //static int iPrevDCCnt;
      //tr=ofs[iCoefs-1];
      //iLastNotZOne=iCoefs;tr=0;int sc=iCoefs-(!!dc);
     // if(co && !dc)tid=getPredX(co,j)+1;else tid=0;
      
//      int sc=findScoreTR_COEFS(((iCoefs*16+iLastNotZOne)*16-iLastCoef-1),tid)+!dc;tr=0;
      int sc=findScoreTR_COEFS(((iCoefs*16+iLastNotZOne)),tid)+!dc;tr=0;
      //int sc=findScoreTR_COEFS(((iCoefs*16+iLastNotZOne))*8+tr,tid)+!dc;
      const int iCoefsWO_Z1=iCoefs-tr;
    //  if(dc){iPrevDCCnt=iCoefs;if(iPrevDCCnt>7)iPrevDCCnt=7;iPrevDCCnt>>=1;}//+8*(co?(getPredX(co,j)):iPrevDCCnt)
#if 0
      if(sc>iMaxXX)iMaxXX=sc;
      static int iAvgX[8];
      static int iAvgC[8];
      int lx=0;
      while(sc>(1<<lx))lx++;
      lx++;
      iAvgC[tid]++;
      iAvgX[tid]+=lx;
      static int iDbgC;iDbgC++;
      if((iDbgC&127)==0 || 1)debugs2i("max",iMaxXX,sc);//iAvgX[tid]/iAvgC[tid]
#endif
#define BSH 4     
     // int sc=findScoreTR_COEFS((tr*16+iZeros),tid)+!dc;
      if(X2){
         
         if(sc>15){
            xvlc.toVLC_X(sc,16);
            xvlc.toVLC_PN(sc-16,3);
         }
         else
         xvlc.toVLC_X(sc,2);
      }else {
         //static int iP=0;
         //xvlc.toVLC(sc);
         
         if(dc)xvlc.toVLC_PN(sc,1);else xvlc.toVLC_PNZ(sc,1);
         //if(sc>8)iP=0;
         //iP++;
      }
      int pos=1;
      int iSufLen=0;//iCoefsWO_Z1>10 && tr<2;
      int iPrevB=iLastNotZOne>1;

  //    for(i=0;i<iCoefsWO_Z1;i++){
      for(i=iCoefsWO_Z1-1;i>=0;i--){
         //   if(i<iFirstB)CTVLCX::encNonZero(xvlc,c[i]>0?(c[i]-1):(c[i]+1));else 
         //--if(i<iLastNotZOne)CTVLCX::encNonZero(xvlc,c[i]);else xvlc.addB(c[i]<0);
         if(i<iLastNotZOne){
            int mask = c[i] >> 31;
            int iEncV = ((c[i]^mask)-mask)-1;// *2-1-(c[i]>0);
            if(i+1==iLastNotZOne){iEncV-=1;iSufLen=0;}else  iSufLen=iPrevB+((i+1)*2>iLastNotZOne?1:2);
            //   abs_v = abs_v*2-mask-2;
            //sufLen=0;
            //abs_v--;
            /*
            if((iEncV>>iSufLen)<8){
               // if(i_level_code<8){
               //101 100 110 111 0101 0100 0111 0110 ,, 1 01 001 0001 00001
               //xvlc.addXBits(1,i_level_code+1);
               xvlc.addXBits(1,(iEncV>>iSufLen)+1);
               if((iEncV>>iSufLen)==0)iPrevB=0;
               else iPrevB+=(iEncV>>iSufLen)>3?1:0;
               //if()
            }
            else{
               iPrevB=0;while(iEncV>(2<<iPrevB))iPrevB++;
              // iSufLen=3;
               xvlc.addXBits(1,9); xvlc.toVLC((iEncV>>iSufLen)-8);
            }
            
            */
            //xvlc.toVLC_PNZ(iEncV,iSufLen);
            //xvlc.toL_Val(iEncV,1+iSufLen);
            xvlc.toVLC(iEncV>>iSufLen);if(iSufLen)xvlc.addXBits(iEncV,iSufLen);
            //xvlc.add000n1(iEncV>>iSufLen);if(iSufLen)xvlc.addXBits(iEncV,iSufLen);
            //CTVLCX::encNonZero(xvlc,c[i]);
            //xvlc.toVLC_PNZ(iEncV,iSufLen);
            
               
               if(iEncV<2)iPrevB=-1;else {int pb=iPrevB;iPrevB=0;while(iEncV>(3<<iPrevB) && iPrevB<8)iPrevB++;iPrevB+=pb;iPrevB>>=1;}

            
            //xvlc.toVLC_PNZ(iEncV,iSufLen);

            //if(!sufLen)sufLen++;
            //if(abs_v>(3<<(sufLen)) && sufLen<6)sufLen++;
            //if(abs_v<2)sufLen=0;
         }
         xvlc.addB(c[i]<0);
         /*
         if(iAdd001) {
         if(iMaxZLeft==1)xvlc.addB(ofs[i]);else xvlc.add000n1(ofs[i]);
         }
         pos+=ofs[i]+1;
         */

      }
     // for(i=0;i<iCoefs-1;i++){
      for(i=0;i<iCoefsWO_Z1;i++){
         int iMaxZLeft=16-(iCoefsWO_Z1-i)-(pos+(tr)*2);//+(zbtr-tr));
         int iAdd001=iMaxZLeft>0;//  &&(i+1<iCoefsWO_Z1 || (c[i]!=-1 && c[i]!=1));
         if(iAdd001) {
            if(iMaxZLeft==1)xvlc.addB(ofs[i]);else xvlc.add000n1(ofs[i]);
         }
         pos+=ofs[i]+1;
      }
/*

      for(;i<iCoefs;i++){
         
         
         if(pos+tr*2<16){// && pos+zbtr+tr<16 && tr!=1)
             int iMaxZLeft=16-(iCoefs-i)-(pos+(tr)*2);//+(zbtr-tr));
             //if(iMaxZLeft>7)xvlc.add000n1(ofs[i]-1);else 
             //xvlc.addXBits(x264_run_before[iMaxZLeft-1][ofs[i]-1].i_bits,x264_run_before[iMaxZLeft-1][ofs[i]-1].i_size);
             if(tr==1 && (iMaxZLeft==1 || iMaxZLeft==2))xvlc.addB(ofs[i]-1);else xvlc.add000n1(ofs[i]-1);
         }
      //      xvlc.add000n1(ofs[i]-1);
         //zbtr-=ofs[i];
         tr--;
         xvlc.addB(c[i]<0);
         pos+=(ofs[i])+1;
      }
  */    
      return 0;
   }
   
   
   template<int dc,class T>
   int testEncNO(T *v, int iPic, CTVLCX *pvlc=NULL){
      int bn=0;
      int findScore4x4(int val, int tid);
      int findScore4x4dc(int val, int tid);
      int findScore4x4Pic(int val, int tid);
      int sc=0;
      //cl=iCoefsLeft[j];
      if(!dc){
         //if(pvlc){pvlc->addB(1);}bn++;
      }
      int i;
      int cx=0;
      int iSkStart=0;
      static int prevFirst[3]={2,2,2};
      int iFirstId=dc?0:(iPic?2:1);
      int iPrevAV=prevFirst[iFirstId];
      int iMax1=1;
      /*
      
      for(i=1;i<16;i++){
         int val=v[i];
         if(val>1 || val<-1){
            iMax1=0;break;     
         }
      }
      */
      //
      int scC=0;
      int iCurTab=prevFirst[iFirstId]-1;
      unsigned char skips[16];
      skips[1]=0;

      //if(iMax1==1)iCurTab=5;
      for(i=1;i<16;i++){
      //for(i=15;i>=1;i--){
         int val=v[tabzz4x4[i]];
         if(val){
            int av=abs(val);
            int scn;
           // iSkStart=findNextPos(&prx[0],i);
            
            int iTabId=iSkStart+16*cx+(iCurTab)*256;
            if(cx==0){
                prevFirst[iFirstId]=av;
                if(prevFirst[iFirstId]>4)prevFirst[iFirstId]=4;
                iCurTab=prevFirst[iFirstId]-1;
            }
            //else if(av>1)iMax1=0;
            //int iTabId=(iPrevAV>16?16:iPrevAV)+16*cx+iSkStart*256;
            //iPrevAV=av;
            //if(iPrevAV>4)iPrevAV=5;
            if(dc)scn=findScore4x4dc(sc,iTabId);
            else if(iPic)scn=findScore4x4Pic(sc,iTabId);
            else scn=findScore4x4(sc,iTabId);

            
            //if(iMax1)iCurTab=prevFirst[iFirstId]-1+4;

            iSkStart=i;
            //if(scn){bn+=vlc.bitsLen[scC];if(pvlc)pvlc->toVLC(scC);scC=0;bn+=scn;if(pvlc)pvlc->addXBits(0xffff,scn);}else scC++;
               skips[cx]=scn;
            
            if(0&&iMax1){
               bn++;
               if(pvlc)pvlc->addB(val<0);
            }
            else{
            bn+=(vlc.bitsLen[av-1]+1);
            if(pvlc){CTVLCX::encNonZero(*pvlc,val);}//pvlc->toVLC(av-1);pvlc->addB(val<0);
            }
            
            /*
            if(av==1){scC++;bn++;if(pvlc)pvlc->addB(val<0);}
            else {
               bn+=vlc.bitsLen[scC];if(pvlc)pvlc->toVLC(scC);scC=0;//val1 sc
               bn+=(vlc.bitsLen[av-2]+1);
               if(pvlc){pvlc->toVLC(av-2);pvlc->addB(val<0);}
            }
*/
            sc=0;
            cx++;
            //cl--;            if(!cl)break;
         //   prx[i]++;
         }else {sc++;}
      }
      
      if(cx<5 && dc){
         iBitGainX1sc--;//max1
         if(iMax1)iBitGainX1sc+=(cx);
      }

      if(sc && cx){
         //i=iSkStart;
//         int iTabId=(iPrevAV>16?16:iPrevAV)+16*cx+iSkStart*256;
         int iTabId=iSkStart+16*cx+(iCurTab)*256;

         int scn;
            if(dc)scn=findScore4x4dc(sc,iTabId);
            else if(iPic)scn=findScore4x4Pic(sc,iTabId);
            else scn=findScore4x4(sc,iTabId);
            //bn+=scn+1;if(pvlc)pvlc->addXBits(0xffff,scn+1);
            skips[cx]=scn;
            //if(scn){bn+=vlc.bitsLen[scC];scC=0;if(pvlc)pvlc->toVLC(scC);bn+=scn;if(pvlc)pvlc->addXBits(0xffff,scn);}else scC++;
      }

      int findScore4x4Skips(int val, int tid);
      int skTx=0;
      int L=iPic || dc?16:5;
      if(skips[0]<L && skips[1]<L){
         skTx=skips[0]+skips[1]*L+1;
      }
      else{
         skTx=0;
      }
      
      
//      skips[0]+(skips[1]+1)*16;
      int scsk=findScore4x4Skips(skTx,iFirstId)+!dc;
      if(iPic || dc){
         bn+=vlc.bitsLen[scsk];if(pvlc)pvlc->toVLC(scsk);
      }
      else{
         bn+=vlc.bitsLenX2[scsk];if(pvlc)pvlc->toVLC_X(scsk,2);
      }
      

      for(i=skTx==0?0:2;i<cx;i++){
         int scn=skips[i];
         bn+=scn+1;            if(pvlc)pvlc->addXBits(0xffff,scn+1);;
      }
      
         
        // 
      
     // if(scC){bn+=vlc.bitsLen[scC];if(pvlc)pvlc->toVLC(scC);scC=0;}
     return bn;
   }

   template<int dc, class T>
   inline int enc1x_15_pic_new_last_one(T *v, int k, int iAdd, CTVLCX *pvlc, int *iCoefsLeft=NULL, int j=0)
   {
      //testEncN<dc,T,0>(v,!iAdd,k,pvlc);      return 0;
      int i;
      int cl;
      int val;
      int iLastT=0;
      int iLastS=0;
      int iLim=(k?12:14);
     // int *xTab=(int*)&tabzz4x4[0];
      int iCoefsLeftN;//=!dc?iCoefsLeft[j]:0;

      int tab_id=((iAdd==0)<<1)+(!k || dc==1);





      blockParams(v,&tabzz4x4[0],iCoefsLeftN,iLastT,iLastS,1,16);
      cl=iCoefsLeftN;
      if(iCoefsLeft)iCoefsLeft[j]=iCoefsLeftN;

#if 0
      int findScoreCntLast(int iCnt, int iLast, int  *tab);
   //   static int iPredCL=0;if(1||!this->iIsKey)iPredCL=0;
      static int tabs_c[128*16*4];
      int c=iCoefsLeftN;
      /*
      int LL=0;
      for(i=1;i<16;i++){
         if(v[tabzz4x4[i]]){c--;if(!c){LL=i;break;}}
      }
      iLim=LL;
*/
      int sc=findScoreCntLast(iCoefsLeftN,iLastT,&tabs_c[(tab_id)*128]);
//      int sc=findScoreCntLast(iCoefsLeftN*16+LL-1,iLastT,&tabs_c[(tab_id+iPredCL*4)*128*16]);
    //  iPredCL=iCoefsLeftN-1;
      //if(iPredCL>12)iPredCL=12;
  //    iPredCL+=2;iPredCL>>=2;if(iPredCL>3)iPredCL=3;iPredCL*=4;iPredCL+=(iLastT>3?3:iLastT);iPredCL++;
#else
      int findScoreCntLast_def(int iCnt, int iLast, int  id);
      int sc=findScoreCntLast_def(iCoefsLeftN,iLastT,tab_id);
#endif
      if(dc){
         //pvlc->toVLC_X(sc,2);
         //1 33 5555 7777 7777
         if(dc==2){
            pvlc->toVLC_X(1+sc,2);
         }else
            if(k)pvlc->toVLC(sc);else 
            pvlc->toVLC_PN(sc,3);
      }
      else{
         //_ENC_D_CODE(1+sc-(j==3 && !(iCoefsLeft[0]|iCoefsLeft[1]|iCoefsLeft[2])));
         pvlc->toVLC_X(1+sc-(j==3 && !(iCoefsLeft[0]|iCoefsLeft[1]|iCoefsLeft[2])),2);
         pvlc->addB(0);


         iDecDct4x4|=(1<<j);
      } 
      //int iWasZero=1;
      int iLastCo=iLastT;
      int iCoReal=iLastCo?(iLastCo-1):0;
      for(i=1;;i++){

         if(cl==1 && iLastCo){
            // for(int zzz=i;zzz<i+iCoReal;zzz++)pr0[i]++;
            if(iLastCo<7){
               pvlc->addB(iLastS);
               i+=iCoReal;
               if(!dc)PRXADD;
               break;
            }
            if(!dc)PRXREM;

            iCoReal=0;
            iLastCo=0;
            i+=6;
         }
         //if(cl==1 && z[j]>0){i+=z[j];z[j]=0;}
         const int i2=!dc?prx[i]>1:0;// && (cl+iCoReal)*4+i>iLim;
         val=v[tabzz4x4[i]];
         if(!dc){if(val)PRXADD;else PRXREM;}


       //  int bp=vlc.iBitPos;
         if(i+cl+iCoReal>=16){// || z[j]<=0){
            CTVLCX::encNonZero(*pvlc,val);//if(val<0){vlc.toVLC(-val-1);vlc.addB(1);}else {vlc.toVLC(val-1);vlc.addB(0);} 
            cl--;if(!cl)break; 
         }
         else if(//!iWasZero || 
            (i2) || 
            (cl)*2+((iCoReal*3)>>1)+i>=iLim 
            //(cl)*2+i+iCoReal>=15
            ){
               //((cl)*2+((iCoReal*3)>>1)+i>=iLim )){// || z[j]<cl){

               CTVLCX::encZero2b(*pvlc,val);
               
//iBitGainX1sc+=(vlc.iBitPos-bp);
//iBitGainX1sc-=calcG(val,1,8);
               if(!val){continue;}
               cl--; if(!cl)break;
         }
         else {
            if(val){
               pvlc->toAC(val);  
 /*
               
                          if(abs(val)<8){
//101 100 110 111 0101 0100 0111 0110 ,, 1 01 001 0001 00001
              pvlc->addXBits(1,((abs(val)-1)>>1)+3);
           }
           else{
              pvlc->addXBits(1,5);//sign
              pvlc->toVLC_PN(abs(val)-8,1);
           }
           
*/
//iBitGainX1sc+=(vlc.iBitPos-bp);
//iBitGainX1sc-=calcG(val,1,8);

               cl--;if(!cl)break;
            }else   pvlc->addB(1); 
         }
      }

         //iBitGainX1+=((vlc.iBitPos-bp)>>3);

        // v[0]=c;
            
      //}while(0);
      
      return 0;

      //tabzz4x4
   }
   
   inline int enc4x_15_pic_new(DCT_TYPE *v, int k, int iAdd)
   {
      int i,j;
      int xcnt[4];
      int cl;
      int iDecDct4x4O=0;
    //  int valB1=0;
      //int bp=vlc.iBitPos;
      //int dc=0;
      int *xTab=(int*)&tabzz4x4[0];
      //int iCanNotDiv2=;
      //do{

         iDecDct4x4=0;
         xcnt[0]=notZerosAligned(v,1,16);
         xcnt[1]=notZerosAligned(v,17,32);
         xcnt[2]=notZerosAligned(v,33,48);
         xcnt[3]=notZerosAligned(v,49,64);

#if 0
         short bl[64];
            int xcnto[4];
         if(!k){
            iDecDct4x4O|=(xcnt[0]?1:0);
            iDecDct4x4O|=(xcnt[1]?2:0);
            iDecDct4x4O|=(xcnt[2]?4:0);
            iDecDct4x4O|=(xcnt[3]?8:0);
         memcpy(bl,v,128);
         short *vo=v;
         
         v=&bl[0];*(long long*)&xcnto[0]=*(long long*)&xcnt[0];*(long long*)&xcnto[2]=*(long long*)&xcnt[2];

         if(xcnt[0] && xcnt[1]){
            bl[20]-=vo[4];
            bl[24]-=vo[8];
            bl[28]-=vo[12];
            xcnt[1]=notZerosAligned(v,17,32);
         }
         if(xcnto[0] && xcnto[2]){
            bl[33]-=vo[1];
            bl[34]-=vo[2];
            bl[35]-=vo[3];
            xcnt[2]=notZerosAligned(v,33,48);
         }
         
         int i4=0;
         if(xcnto[1]&& xcnto[3]){
            bl[49]-=vo[17];
            bl[50]-=vo[18];
            bl[51]-=vo[19];
            i4++;
         }
         
         if(xcnto[2] && xcnto[3]){
            bl[52]-=vo[36];
            bl[56]-=vo[40];
            bl[60]-=vo[44];
            i4++;
         }
         
         if(i4)xcnt[3]=notZerosAligned(v,49,64);
         }
#endif
         int val;
         
         /*
         
         vlc.toVLC(xcnt[0]);
         vlc.toVLC(xcnt[1]);
         vlc.toVLC(xcnt[2]);
         vlc.toVLC(xcnt[3]);
         */
         //int lc=0;
         enc_c_cnt4(&xcnt[0]);
         /*
         int z[4];
         for(i=0;i<4;i++){
            if(xcnt[i] && xcnt[i] != 15){z[i]=zeros(v+(i<<4),xTab,1);enc_coef_m15(vlc,z[i]);}else z[i]=0;
         }
         */
         /*
         if(k)enc_c_cnt4(&xcnt[0]);else {
         enc_coef_m15(vlc,xcnt[0]);

         vlc.addB(xcnto[1]?1:0);
         vlc.addB(xcnto[2]?1:0);
         vlc.addB(xcnto[3]?1:0);
         if(xcnto[1])enc_coef_m15(vlc,xcnt[1]);
         if(xcnto[2])enc_coef_m15(vlc,xcnt[2]);
         if(xcnto[3])enc_coef_m15(vlc,xcnt[3]);
         }*/
         //0
         static const int tDcttxt[4]={1,2,4,8};
         //int iLastI=14;
         const int iLim=k?12:14;
         //int coze=-5;
//      memset(pr1,0,sizeof(pr1));
  //    memset(pr0,0,sizeof(pr0));

         for(j=0;j<4;j++)
         {
            cl=xcnt[j];
            if(cl){
               iDecDct4x4|=tDcttxt[j];
                  int z=0;
                  for(i=1;;i++){
                     //if(cl==1 && z[j]>0){i+=z[j];z[j]=0;}
                     const int i2=pr0[i]*5<pr1[i]*4;
                     val=v[xTab[i]];
                     if(val)pr1[i]++; else pr0[i]++;
                     
                     if(i+cl==16){// || z[j]<=0){
                        if(val<0){vlc.toVLC(-val-1);vlc.addB(1);}else {vlc.toVLC(val-1);vlc.addB(0);} 
                        cl--;if(!cl)break; 
                     }//(coze>0) ||//cl*4+i>iLim && 
                     else if(cl*2+i>iLim ||  (i2)){// || z[j]<cl){
                        CTVLCX::encZero2b(vlc,val);
                        if(!val)continue;
                        /*
                        if(val==0){vlc.addB(1); vlc.addB(1);coze--; continue;}//z[j]--;
                        else if(val==1){vlc.addB(0); vlc.addB(0); }
                        else if(val==-1){vlc.addB(0); vlc.addB(1); }
                        else {vlc.addB(1); vlc.addB(0); if(val>0){vlc.addB(0);vlc.toVLC(val-2);}else {vlc.addB(1);vlc.toVLC(-val-2);}}
                        //else {vlc.addB(1); vlc.addB(0); if(val>0)val-=2;else val++;vlc.toAC(val);}
                        */
                        cl--;
                        if(!cl)break;
                     }
                     else {
                        if(val){
                           vlc.toAC(val);   cl--;if(!cl)break;
                        }else   vlc.addB(1); 
                     }
           //          if(val)coze++;else {coze--;}//z[j]--;
                  }

             //     coze++;
                  //iLastI=i-1;
               //for(;i<16;i++)pr0[i]++;

            }

            xTab+=16;
         }
         //iBitGainX1+=((vlc.iBitPos-bp)>>3);

        // v[0]=c;
            
      //}while(0);
      if(iDecDct4x4O)iDecDct4x4=iDecDct4x4O;
      return 0;

      //tabzz4x4
   }
  //    template <int iDeQDif>
//   inline int dec4x_15(DCT_TYPE *v, int k, const int *tabDeq=NULL){
#if 0
   static const unsigned char BitsSetTable256[256] = 
{
#   define B2(n) n,     n+1,     n+1,     n+2
#   define B4(n) B2(n), B2(n+1), B2(n+1), B2(n+2)
#   define B6(n) B4(n), B4(n+1), B4(n+1), B4(n+2)
    B6(0), B6(1), B6(1), B6(2)
};

unsigned int v; // count the number of bits set in 32-bit value v
unsigned int c; // c is the total bits set in v

// Option 1:
c = BitsSetTable256[v & 0xff] + 
    BitsSetTable256[(v >> 8) & 0xff] + 
    BitsSetTable256[(v >> 16) & 0xff] + 
    BitsSetTable256[v >> 24]; 

// Option 2:
unsigned char * p = (unsigned char *) &v;
c = BitsSetTable256[p[0]] + 
    BitsSetTable256[p[1]] + 
    BitsSetTable256[p[2]] +	
    BitsSetTable256[p[3]];


// To initially generate the table algorithmically:
BitsSetTable256[0] = 0;
for (int i = 0; i < 256; i++)
{
  BitsSetTable256[i] = (i & 1) + BitsSetTable256[i / 2];
}
#endif
   template<int dc,class T>
   void encTestBlQ(T *v, const int *tq){

      int i,co=0;
      for(int i=1;i<16;i++)if(v[i])co++;
      iBitGainX1sc-=co;
//      addRacValP(co-1,1);

      for(i=1;i<16;i++){
         int va=abs(v[i]);
         if(tq)va/=tq[i];
         addRacValP(va>1?(va+1):va,i-1+dc*16);
         if(va){co--;if(co<=0)break;}
      }
      addRacValP(2,i-1+dc*16);
   }
   void encTestBl(DCT_TYPE *v){
     for(int i=1;i<16;i++){
        if(v[i])iBitGainX1sc--;
        addRacVal(abs(v[i]));
     }
   }
   template<int iDeQDif>
   int dec1x_15_dif(DCT_TYPE *v, int *coefs, int j, const int *tabDeq=NULL){
      
      int i;
      int iCoefs;
  int bp=vlc.iBitPos;
      int scRem=(j==3 && !iDecDct4x4);//(coefs[0]|coefs[1]|coefs[2]));
      _DEC_D_CODE(iCoefs,(scRem));//iCoefs+=scRem;
     // if(iBlocks8orMore && !scRem){if(iCoefs==1)iCoefs=0;else if(iCoefs==0)iCoefs=1;}
      coefs[j]=iCoefs;
      if(!iCoefs)return 0;

      iDecDct4x4|=(1<<j);

      //int co1=((iCoefs+scRem)&1==0);// || iCoefs>32;
      //iCoefs=((iCoefs+scRem)>>1);//(iCoefs<32)?((iCoefs+1)>>1):(iCoefs-16);
      if(iCoefs>15 || vlc.getB()){
      //if(co1){
         if(iCoefs>32767)            return -3;
         int decDifCodeOnes(int sc);
         int code=decDifCodeOnes(iCoefs-1);
/*
         int findScore32K(int val);
         int sc=findScore32K(code);
         static CTVLCX a;
         unsigned char aa[8];
         a.pBitBuf=&aa[0];
         a.iBitPos=0;
         a.toVLC_X(1+sc,2);
        // a.toVLC(1+sc);
         iBitGainX1sc-=a.iBitPos;

         a.iBitPos=0;
         a.toVLC_X(iCoefs,2);
         
         iBitGainX1sc+=a.iBitPos;
*/
    //     short test_bl[16];memset(test_bl,0,32);       int cn=0;
//TODO opt getCoefCnt(iCoefs-1)
         //int f=1;
         /*
#ifdef _WIN64
         *(long long)&v[0]=0;
#else
#endif
         */
         //todo GET FIRST i BY CODE
         memset(v+1,0,sizeof(short)*15); 
         for(i=1;code;i++){
            //if(code&f){
            if(code&1){
               const int c=tabzz4x4[i];
               //code&=~f;
           //    cn++;
               if(vlc.getB()){
                  DEQ_DP(v[c],-1,tabDeq[c]);
  //                test_bl[c]=-1;
               }
               else{
                  DEQ_DP(v[c],1,tabDeq[c]);
//                  test_bl[c]=1;
               }
               
            }//else{ v[c]=0;}
            //f<<=1;
            code>>=1;
         }


/*
         static CTVLCX tv;
         static unsigned char tvc[64];
         tv.pBitBuf=&tvc[0];
         tv.iBitPos=0;
         

         //enc1x_15_pic_new_last_one<1,short>(&test_bl[0],0,1,&tv);
         tv.toVLC_X(cn,2);
         
         tv.addB(0);
         enc4x1(tv,&test_bl[0],1,0,16,cn);
         
         int g=vlc.iBitPos-bp-tv.iBitPos;;


         

if(g>0)iBitGainX1sc+=g;
*/
      }
      else{
         iHasBigCoefs=1;
         
         //if(iCoefs==1)iBitGainX1+=2;//nav 1
         int ret=dec4x1_deq<iDeQDif>(v,1, 0, 16, iCoefs, tabDeq);
      //iBitGainX1sc--;//enc not enc
        // iBitGainX1sc+=(vlc.iBitPos-bp);
        // encTestBlQ(v,tabDeq);

//         int ret=dec1x_15_pic_new_last_one<iDeQDif>(v,0,iCoefs,&coefs[0],j,tabDeq);
         if(ret<0)
            return ret;
      }

      return 0;
   }
#if 0
   int enc1x_15_dif_t(DCT_TYPE *v, int &m, int rem){
      int i;
      m=1;
      int code=0;
#define MAXSC_Q_SZ 122
      int codeN[MAXSC_Q_SZ+6];
    //  unsigned char codeN_Cnt[MAXSC_Q_SZ+4];
      memset(&codeN[0],0,sizeof(char)*(MAXSC_Q_SZ+4));

      int s[15];
      int iBitsNew=0;
      int iMaxL=0;

      //int sr=0;
      int iCoefs=0,c;
      for(i=1;i<16;i++){
         c=v[tabzz4x4[i]];
         if(!c)continue;
         
         if(1){//(unsigned)(c+1)>2){
//code0->codeN[0]
            int lev=abs(c);
            int add=lev-1;
            if(add>=MAXSC_Q_SZ)return 50;//save as pic//add=MAXSC_Q_SZ-1;
            if(add>=iMaxL)iMaxL=add;
            int levFix=(add>MAXSC_Q_SZ?MAXSC_Q_SZ:add);
            //codeN[levFix]|=(1<<i);
            for(int zz=add;zz>=0;zz--){
               codeN[zz]|=(1<<i);
              // codeN_Cnt[zz]++;
            }
            
    //        iSetFlagPic=1;
            //break;
         }
         
//           code|=(1<<i);
  //       s[iCoefs]=c<0;
         //if(c<0)sr|=(1<<iCoefs);
         iCoefs++;
         
      }
      //codeN_Cnt[0]=iCoefs;
      int getDifCodeOnes(int val);

      //return 0;
      //if(!rem)iBitsNew++;
      
      int sc=getDifCodeOnes((codeN[iMaxL]>>1))+1-rem;
/*      
       static const unsigned char i_size0_255[256] =
       {
           1,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
           6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
           7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
           7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
           8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
           8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
           8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
           8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8
       };
       
         sc++;
         sc>>=2;iBitsNew+=2;
         if(sc>=0x00010000){iBitsNew+=16;sc>>=16;}
         if(sc>=256){iBitsNew+=8;sc>>=8;}
         iBitsNew+=i_size0_255[sc]*2-1;
  */
      
      static CTVLCX *tx;
      if(!tx)tx=new CTVLCX();
      static unsigned char pt[16];
      tx->pBitBuf=&pt[0];
      tx->iBitPos=0;
      tx->toVLC_X(sc,2);
      iBitsNew+=tx->iBitPos;

   //if(sc>1023){sc>>=6;iBitsNew+=3;;}
   //iBitsNew+=vlc.bitsLenx2[sc];

         //iBitsNew+=getLen2x_test(sc);
      
      //top lev         T0000
      //enc base level  B0000

      //TABLE 1
    
    iBitsNew+=iMaxL+1;//vlc.bitsLen[iMaxL];
   

if(iMaxL){// && codeN[iMaxL]!=codeN[0]
      //top lev         T0T00000
      //l1              sss0s1ss
      //enc base level  B0BB0B00

   //??vlc.bitsLen[iMaxL-1];nevajag jo redz top cnt
   //--iBitsNew+=(15-codeN_Cnt[iMaxL]);//Bottom
   //int iLadd
      int ba=0;
      int zc=0;
      for(int zz=1;zz<16;zz++){
         int fl=(1<<zz);
         if((codeN[iMaxL]&fl)==0){ba++;if(codeN[0]&fl)zc++;}
      }
      if(ba<8)iBitsNew--;
      iBitsNew+=zc+1;//vlc.bitsLen[zc-1]+1; if(zc==2)iBitsNew--;
     
      for(int zz=1;zc>0 && zz<16;zz++){
         int fl=(1<<zz);
         if((codeN[iMaxL]&fl)==0){iBitsNew++;if(codeN[0]&fl)zc--;}
      }

      //--iBitsNew+=ba;
         
   /*
      int findScore32K(int val);
      sc=findScore32K((codeN[0])>>1);
      debugsi("sc",sc);
      sc++;
      if(sc>=0x00010000){iBitsNew+=16;sc>>=16;}
      if(sc>=256){iBitsNew+=8;sc>>=8;}
      iBitsNew+=i_size0_255[sc]*2-1;
*/
      if(codeN[iMaxL]!=codeN[0]){
         for(int n=1;n<iMaxL;n++){
            for(int zz=1;zz<16;zz++){
               int fl=(1<<zz);
               if((codeN[iMaxL]&fl)==0 && (codeN[n-1]&fl) )iBitsNew++;
            }
            //iBitsNew+=codeN_Cnt[n]-codeN_Cnt[0];//mark last code
            //iBitsNew+=codeN_Cnt[n]-codeN_Cnt[n+1];
            //iBitsNew++;//has lev
         }
      }

      
}
      iBitsNew+=iCoefs;//signs
      return iBitsNew;
   }
#if 0
   int enc1x_15_dif_t2(DCT_TYPE *v, int &m, int scRem){
      int i;
      m=1;
      int code=0;
      int codeB=0;


      int s[15];
      int iBitsNew=0;
      int iMaxL=0;

      //int sr=0;
      int iCoefs=0,c;
      int iBCodes=0;
      int iLastC=1;
     // int iBPval2=0;
      for(i=1;i<16;i++){
         c=v[tabzz4x4[i]];
         if(!c)continue;
         
         if((unsigned)(c+1)>2){
            codeB|=(1<<i);
            iBitsNew+=vlc.bitsLen[abs(c)-2];
            iBCodes++;
         }
         else {code|=(1<<i);}
         iLastC=i;
         
         s[iCoefs]=c<0;
         iCoefs++;
      }
     // iBPval2=iBitsNew;
      

      //code&=~(1<<iLastOne);
      int getDifCodeOnes(int val);
      int findScore32K(int val);
      int sc;
      if(1){
         //sc=findScore32K(code>>1);

          sc=getDifCodeOnes((codeB>>1))+1-scRem;
         iBitsNew+=vlc.bitsLenx2[sc];

         if(iBCodes==15){
         }
         else {
            int iCL=iCoefs-iBCodes;
           iBitsNew+=vlc.bitsLen[iCL];
           if(!iCL){
           }
           else if(iCL<3){
              iBitsNew+=(15-iBCodes)/4+1;
           }
            else  if(iBCodes>4)
            {
               
               iBitsNew+=(15-iBCodes);
            }
            else{
               //sc=getDifCodeOnes((code>>1));
                  sc=findScore32K((code>>1));
                  
               debugsi("sc1",sc);//18837
               if(sc>1000){sc>>=9;iBitsNew+=6;}
               iBitsNew+=vlc.bitsLenx2[sc];
            }
         }
      }
      else
      {
         //iBitsNew+=1;
         
         //if(iCoefs)
       //  if(iLastC==2 || iLastC==3)iBitsNew=0;
            //iBitsNew+=vlc.bitsLenx2[iLastC-scRem];
            //-4 2(2g) last (1g)(11g)
  //          if(iLastC==2){iCoefs=0;iBitsNew-=4;iBitsNew+=vlc.bitsLenAC[v[tabzz4x4[2]]]+vlc.bitsLenAC[v[tabzz4x4[1]]];}//abi 0 
//            else if(iLastC==3){iCoefs=0;iBitsNew-=4;iBitsNew+=vlc.bitsLenAC[abs(v[tabzz4x4[3]])]+vlc.bitsLenAC[abs(v[tabzz4x4[2]])]+vlc.bitsLenAC[abs(v[tabzz4x4[1]])];}//abi 0 
           // if(iLastC==3 || iLastC==2){iBitsNew+=iCoefs;}//abi 0 
            //else if(iLastC==3){iCoefs=0;iBitsNew-=4;iBitsNew+=vlc.bitsLenAC[abs(v[tabzz4x4[3]])]+vlc.bitsLenAC[abs(v[tabzz4x4[2]])]+vlc.bitsLenAC[abs(v[tabzz4x4[1]])];}//abi 0 
           // else if(iLastC==1){
               //only >1
            
      //      }else
         {
            
                sc=//findScore32K((codeB>>1));//
                     getDifCodeOnes(codeB>>1)+1-scRem;


               {
                  
                  //if(sc)sc--;//nevar buut last1
                  //if(sc)sc--;//nevar buut last2s

                  if(sc>1023){sc>>=5;iBitsNew+=8;}
                  iBitsNew+=vlc.bitsLenx2[sc];
               }
               if(iBCodes>10 || iBCodes==15)iBitsNew+=(15-iBCodes);
               else  if(iBCodes<3 ){
                  if(!code){
                     iBitsNew++;
                  }
                  else{
                  sc=getDifCodeOnes((code>>1));//|(codeB>>1)
                  debugsi("sc1",sc);//18837
                  int l1=0;
                  if(sc>1000){sc>>=5;l1+=8;}
                  //iBitsNew+=vlc.bitsLenx2[sc];
                  l1+=vlc.bitsLenx2[sc+1];
                  iBitsNew+=l1;
                  }
               }
               else
               {
                  iBitsNew+=(15-iBCodes);//1 0
               }
            }
         
         
      }
     // debugsi("sc2",sc);

      
      iBitsNew+=iCoefs;//signs
      return iBitsNew;
   }  // int iSetFlagPic;
#endif
#endif
   int iPrevCoefMax;
   int enc1x_15_dif(DCT_TYPE *v, int *coefs, int j){
      int i;
      int code=0;
      int s[15];
      int bpt=vlc.iBitPos;
      //int sr=0;
      int iCoefs=0,c;
      
      //long long *pll=(long long *)v;if((pll[0]|pll[1]|pll[2]|pll[3])){
      for(i=1;i<16;i++){
         c=v[tabzz4x4[i]];
         if(!c)continue;
         
         if((unsigned)(c+1)>2){
            iCoefs++;
            code=-2;
            break;
         }
         s[iCoefs]=c<0;
         //sr|=((c<0)<<iCoefs);
         //if(c<0)sr|=(1<<iCoefs);
         iCoefs++;
         code|=(1<<i);
      //}
      }
      coefs[j]=iCoefs;
      
      if(!iCoefs){
      //iDecDct4x4&=~(1<<j);
         _ENC_D_CODE(0,0);
         return 0;
      }
      //code=-2;
//      int scRem=(j==3 && !(coefs[0]|coefs[1]|coefs[2]));
      int scRem=(j==3 && !iDecDct4x4);
      iDecDct4x4|=(1<<j);

      //int bp=vlc.iBitPos;
/*
      int iLen2=5000;
      int bp=vlc.iBitPos;
      if(code!=-2){
         i++;
         for(;i<16;i++)if(v[tabzz4x4[i]]) iCoefs++;
         
          vlc.iCalcBitsOnly=1;
         _ENC_D_CODE(iCoefs-scRem);
         vlc.addB(0);enc4x1(v,1,0,16,iCoefs);
         vlc.iCalcBitsOnly=0;
         iLen2=vlc.iBitPos-bp;
         vlc.iBitPos=bp;
      }
         
*/

      if(code==-2){
         i++;
         for(;i<16;i++)if(v[tabzz4x4[i]]) iCoefs++;
         

         _ENC_D_CODE(iCoefs,(scRem));
         vlc.addB(0);

  //       iBitGainX1sc++;

         /*
         vlcTest.iBitPos=0;
         int ol=(vlc.iBitPos-bp);
         vlcTest.toVLC_X(((iCoefs-scRem))*2+1,2);
         int nl=vlcTest.iBitPos;iBitGainX1sc+=ol;iBitGainX1sc-=nl;
*/
         enc4x1(vlc,v,1,0,16,iCoefs);
      //int ol=(vlc.iBitPos-bp);vlcTest.iBitPos=1;enc1x4x15TX<0,short,1>(v,0,0,vlcTest,coefs,j);int nl=vlcTest.iBitPos;iBitGainX1sc+=ol;iBitGainX1sc-=nl;
        //iPrevCoefMax=2;
    //  debugs2i("o2n",ol,nl);
         
      }
      else {
         int getDifCodeOnes(int val);
         int sc=getDifCodeOnes((code>>1))+1;
         //int e=((sc-scRem));
         
         //if(sc-scRem>=16)e=sc-scRem+16;

         _ENC_D_CODE(sc,(scRem));//TODO 2x
         if(sc<16)  vlc.addB(1);
         
/*
         vlcTest.iBitPos=0;
         int ol=(vlc.iBitPos-bp);
         vlcTest.toVLC_X(sc-scRem+15,2);
         int nl=vlcTest.iBitPos;iBitGainX1sc+=ol;iBitGainX1sc-=nl;
*/
         /*
         vlcTest.iBitPos=0;
         int ol=(vlc.iBitPos-bp);
         vlcTest.toVLC_X(e<32?e*2:(e+16),3);
         int nl=vlcTest.iBitPos;iBitGainX1sc+=ol;iBitGainX1sc-=nl;
*/

//
         for(i=0;i<iCoefs;i++)vlc.addB(s[i]);
         //vlc.addXBits(sr,iCoefs);
         //iPrevCoefMax=1;
         /*
         int tid=0;
         static int iPrevSC[8];
         static int iPrevPrevSC[8];
         int iPredBits=0;
         int iPS=iPrevSC[tid]+iPrevPrevSC[tid]+1;

         while((iPS)>(1<<iPredBits))iPredBits++;
         //if(iPredBits)iPredBits--;
         iPredBits>>=1;
         vlcTest.iBitPos=0;

*/
         //vlcTest.addXBits(1,((sc-scRem)>>4)+6);
         //iBitGainX1sc-=vlcTest.iBitPos;vlcTest.iBitPos=0;vlcTest.toVLC_X(sc-scRem,2);
         //iBitGainX1sc+=vlcTest.iBitPos;
         //xvlc.addXBits(1,((sc-4)>>3)+4);

         
      
      }
      /*
      if(1){
         int iLastB=0;
         int iBitC=3;
         for(i=1;i<16;i++){
            c=v[tabzz4x4[i]];
            if(!c){iBitC+=2;continue;}
            int bll=(abs(c)>1)?(vlc.bitsLen[abs(c)-2]+3+1):2;
            iBitC+=bll;
            iLastB=iBitC;
         }
         iBitGainX1sc+=(vlc.iBitPos-bpt);
         iBitGainX1sc-=iLastB;

      }
      */
      /*
      if(this->iBlocks8orMore){

         iBitGainX1sc+=(vlc.iBitPos-bpt);
         vlcTest.iBitPos=0;
         enc1x_15_dif_dc<0,short>(vlcTest,v,0,0);
         iBitGainX1sc-=vlcTest.iBitPos;
         iBitGainX1sc+=scRem;
//         debugs2i("o1n",ol,nl);

      }
      */
      
      

      /*
      int ol=(vlc.iBitPos-bp);vlcTest.iBitPos=0;
      enc1x4x15TX<0,short,0>(v,0,0,vlcTest,coefs,j);
  //      enc1x_15_pic_new_last_one<2,short>(v,0,1,&vlcTest);  
        int nl=vlcTest.iBitPos;iBitGainX1sc+=ol;iBitGainX1sc-=nl;
      debugs2i("o1n",ol,nl);
    //  iBitGainX1sc+=2;
*/
      return 0;
   }
   template<int iDeQDif, int dc,class T>
   int dec1x_15_dif_dc(CTVLCX &vl, T *v, int iPic, int f, const int *tabDeq=NULL){
      
      int i;
      int iCoefs;
      iCoefs=vl.getVlc_PN(3+(f==31)-(!dc)-(f==16))+1;

      if(iCoefs>15){
      //if(co1){
         if(iCoefs>32769+16)            return -3;
         int decDifCodeOnes(int sc);
         int code=decDifCodeOnes(iCoefs-16);
/*
         int findScore32K(int val);
         int sc=findScore32K(code);
         static CTVLCX a;
         unsigned char aa[8];
         a.pBitBuf=&aa[0];
         a.iBitPos=0;
         a.toVLC_PN(sc,3+(f==31)-(!dc)-(f==16));
        // a.toVLC(1+sc);
         iBitGainX1sc-=a.iBitPos;

         a.iBitPos=0;
         a.toVLC_PN(iCoefs-1,3+(f==31)-(!dc)-(f==16));
         
         iBitGainX1sc+=a.iBitPos;
*/
         memset(v+1,0,sizeof(T)*15);
         for(i=1;code;i++){
            
            if(code&1){
               const int c=tabzz4x4[i];
           //    cn++;
               if(vlc.getB()){
                  if(iDeQDif){DEQ_DP(v[c],-1,tabDeq[c]);}else v[c]=-1;
             //     test_bl[i]=-1;
               }
               else{
                  if(iDeQDif){DEQ_DP(v[c],1,tabDeq[c]);}else v[c]=1;
               //   test_bl[i]=1;
               }
               
            }
            code>>=1;
         }
      }
      else{
         int ret=dec4x1_deq<iDeQDif>(v,1, 0, 16, iCoefs, tabDeq);
//         int ret=dec1x_15_pic_new_last_one<iDeQDif>(v,0,iCoefs,&coefs[0],j,tabDeq);
         if(ret<0)
            return ret;
      }

      return 0;
   }   
   template<int iDeQDif, int dc,class T>
   int zdec1x_15_dif_dc(CTVLCX &vl, T *v, int iPic, int f, const int *tabDeq=NULL){
      
      int i;
      int iCoefs;
      iCoefs=vl.getVlc_PN(3+(f==31)-(!dc)-(f==16))+1;

      if(iCoefs>15){
      //if(co1){
         //if(iCoefs>32769)            return -3;
         int decDifCodeOnes(int sc);
         int code=decDifCodeOnes(iCoefs-16);
         int f=1;
         for(i=1;i<16;i++){
            const int c=tabzz4x4[i];
            if(code&f){
           //    cn++;
               if(vlc.getB()){
                  DEQ_DP(v[c],-1,tabDeq[c]);
             //     test_bl[i]=-1;
               }
               else{
                  DEQ_DP(v[c],1,tabDeq[c]);
               //   test_bl[i]=1;
               }
               
            }else{ v[c]=0;}
            f<<=1;
         }
      }
      else{
         int ret=dec4x1_deq<iDeQDif>(v,1, 0, 16, iCoefs, tabDeq);
//         int ret=dec1x_15_pic_new_last_one<iDeQDif>(v,0,iCoefs,&coefs[0],j,tabDeq);
         if(ret<0)
            return ret;
      }

      return 0;
   }   
   template<int dc,class T>
   int enc1x_15_dif_dc(CTVLCX &vl, T *v, int iPic, int f){
      int i;
      int code=0;
      int s[15];
      int iCoefs=0,c;
      for(i=1;i<16;i++){
         c=v[tabzz4x4[i]];
         if(!c)continue;
         
         if((unsigned)(c+1)>2){
            //sz=2;
            code=-2;iCoefs++;break;
         }
        // code=-2;iCoefs++;break;
         s[iCoefs]=c<0;
         iCoefs++;
         code|=(1<<i);
      }
      if(dc && !iCoefs)return 0;
      if(!dc ){

         if((!v[0] || !f) && !iCoefs){
            vl.addB(1);
            return 0;
         }
         vl.addB(0);
         if(f){
            vl.toAC(v[0]);
            if(v[0])vl.addB(!!iCoefs);
         }
         if(!iCoefs)return 0;
      }
      
       if(code==-2){
         i++;
         for(;i<16;i++)if(v[tabzz4x4[i]]) iCoefs++;
         vl.toVLC_PN(iCoefs-1,3+(f==31)-(!dc)-(f==16));//vl.addB(0);
         enc4x1(vl,v,1,0,16,iCoefs);
      }
      else {
         int getDifCodeOnes(int val);
         int sc=getDifCodeOnes((code>>1));
         vl.toVLC_PN(sc+15,3+(f==31)-(!dc)-(f==16));
         for(i=0;i<iCoefs;i++)vlc.addB(s[i]);
      }
      return 0;
   }



   template<int dc,class T>
   int enc1x_15_dif_dcx(CTVLCX &vl, T *v, int iPic, int f){
      int i;
      int code=0;
      int s=0;
      //int co[15];      int sz=0;
      //int sr=0;
      int bp=vl.iBitPos;
      int iCoefs=0,c;
      for(i=1;i<16;i++){
         c=v[tabzz4x4[i]];
         if(!c)continue;
         
         if((unsigned)(c+1)>2){
            //sz=2;
            code=-2;iCoefs++;break;
         }
//         co[iCoefs]=c;
         s<<=1;
         s|=c<0;
         //if(c<0)sr|=(1<<iCoefs);
         iCoefs++;
         code|=(1<<i);
      }
      if(dc && !iCoefs)return 0;
      if(!dc ){

         if((!v[0] || !f) && !iCoefs){
            vl.addB(1);
            return 0;
         }
         vl.addB(0);
         if(f){
            vl.toAC(v[0]);
            if(v[0])vl.addB(!!iCoefs);
         }
         if(!iCoefs)return 0;
      }
      

      //const static int ll[]={1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,};
//#define T_SZ_LL (sizeof(ll)/sizeof(int))
   //   int bp=vl.iBitPos;
     // static int iPredSC=1;
      if(code==-2){
         
         i++;
         for(;i<16;i++)if(v[tabzz4x4[i]]) iCoefs++;
         //vl.add000n1(1);enc_coef_m15(vl,(iCoefs-1));
         vl.toVLC_PN(iCoefs-1,3+(f==31)-(!dc)-(f==16));//vl.addB(0);
         //if(iCoefs<3){vl.toVLC(0);vl.addB(iCoefs==1);}//enc_coef_m15(vl,iCoefs-1);
         //else {vl.toVLC(1);enc_coef_m15(vl,iCoefs-3);}
         
         //enc4x1_dcTest(vl,v,iCoefs);
         enc4x1(vl,v,1,0,16,iCoefs);
         
         //enc1x_15_pic_new_last_one<dc,T>(v,0,!iPic,&vl);
       //  iPredSC=ll[iCoefs];
         //iBitGainX1sc++;
      //int ol=(vlc.iBitPos-bp);vlcTest.iBitPos=1;enc1x4x15TX<0,short,1>(v,0,0,vlcTest,coefs,j);int nl=vlcTest.iBitPos;iBitGainX1sc+=ol;iBitGainX1sc-=nl;
        //iPrevCoefMax=2;
    //  debugs2i("o2n",ol,nl);

      }
      else {
         int getDifCodeOnes(int val);
         int sc=getDifCodeOnes((code>>1));
         //1,3,3,5,5,5,5
         /*
         if(sc<32){
            vl.toVLC((sc&1)+1);enc_coef_m15(vl,sc>>1);
         }
         else{
            vl.toVLC(sc-30);
         }
         */
         
         //vl.toVLC_X(sc+1,3+(f==31)-(!dc)-(f==16));
         //vl.addB(0);vl.toVLC_PN(sc,2+(f==31)-(!dc)-(f==16));
         vl.toVLC_PN(sc+15,3+(f==31)-(!dc)-(f==16));
         //vl.toVLC((sc&1)+1);vl.toVLC_PN(sc>>1,2+(f==31)-(!dc)-(f==16));
         vl.addXBits(s,iCoefs);
         /*
         int bpx=vl.iBitPos-bp;
         vl.iBitPos=bp;
           vl.toVLC_PN(iCoefs-1,3+(f==31)-(!dc)-(f==16));//vl.addB(0);
           enc4x1(vl,v,1,0,16,iCoefs);
           if(vl.iBitPos-bp>bpx){
              vl.iBitPos=bp+bpx;
           }
         */
      }
      return 0;
   }
   inline int enc4x_15(DCT_TYPE *v, short *p, int k, int iAdd)
   {
      int i,j;
      int xcnt[4];
      iDecDct4x4=0;
#ifdef _TEST_T_BITS 
      if(!iAdd || T_USE_N_PICD)return  enc4x_15_pic_new_last_one(v,  k, iAdd);
      for(j=0;j<4;j++){
         enc1x_15_dif(v+(j<<4), &xcnt[0], j);
      }
      return 0;

#endif
    //  int valB1=0;
      int dc=0;
      int *xTab=(int*)&tabzz4x4[0];
      //int iCanNotDiv2=;
      //do{
         
         xcnt[0]=notZerosAligned(v,1,16);
         xcnt[1]=notZerosAligned(v,17,32);
         xcnt[2]=notZerosAligned(v,33,48);
         xcnt[3]=notZerosAligned(v,49,64);
         int val;
         
         vlc.toVLC(xcnt[0]);
         vlc.toVLC(xcnt[1]);
         vlc.toVLC(xcnt[2]);
         vlc.toVLC(xcnt[3]);
         
         //enc_c_cnt4(&xcnt[0]);
         //0
         static const int tDcttxt[4]={1,2,4,8};
         //int ctxb[16]={1,1,1,1, 1,1,1,1, 1,1,1,1, 1,1,1,1,};
         for(j=0;j<4;j++)
         {
            if(xcnt[j]){
               iDecDct4x4|=tDcttxt[j];
               for(i=1; ;i++){
                  val=v[xTab[i]];
                  if(val){
//                     vlc.addB(0);  if(ctxb[i]<4)vlc.toVLC(mmabs(val)-1);else vlc.toAC(mmabs(val)-ctxb[i]);  vlc.addB(1);ctxb[i]+=mmabs(val);     ctxb[i]>>=1;
                     vlc.toAC(val);

                     xcnt[j]--;
                     if(!xcnt[j])break;
                     //ctxb[i]*=3;
                     
                  }else {
                     vlc.addB(1); 
                  }
               }
            }
            xTab+=16;
         }

        // v[0]=c;
            
      //}while(0);
      
      return 0;

      //tabzz4x4
   }
   inline int enc4xi(DCT_TYPE *v, short *p, int k, int iAdd)
   {

      int i,j;
      int xcnt[4];
      int dc=0;
      do{
         if(iAdd==1){
            mbType[iMbTypePos]=1+2;
         }
         else{
            mbType[iMbTypePos]=0+2;
         }
         iHasDifOnly=0;
         iMbTypePos++;

         int *xTab=(int*)&tabzz4x4[0];//:(int*)&tabzz4x4_second[0];
         
         DCT_TYPE dcs[4]={v[0],v[16],v[32],v[48]};
         if(iAdd==0){
            dc=v[0];
            v[0]-=iPredDC;
            v[16]-=dc;v[32]-=dc;v[48]-=dc;
         }
         
         xcnt[0]=zeroCnt(v,xTab,0,16);
         xcnt[1]=zeroCnt(v,xTab,16,32);
         xcnt[2]=zeroCnt(v,xTab,32,48);
         xcnt[3]=zeroCnt(v,xTab,48,64);
         
         int val;

         vlc.toVLC(xcnt[0]);
         vlc.toVLC(xcnt[1]);
         vlc.toVLC(xcnt[2]);
         vlc.toVLC(xcnt[3]);
         

         for(j=0;j<4;j++)
         {
            for(i=0;i<4 && xcnt[j]>=0 ;i++){
               val=v[xTab[i]];
               if(val){vlc.toL_Val_S(val,2);} else {vlc.addB(1);xcnt[j]--;}

            }
            for(;i<16 && xcnt[j]>=0 ;i++){
               val=v[xTab[i]];
               if(val){vlc.toAC(val);}else {vlc.addB(1); xcnt[j]--;}
            }
            xTab+=16;
         }
         if(iAdd==0){
            v[0]=dcs[0];
            v[16]=dcs[1];
            v[32]=dcs[2];
            v[48]=dcs[3];
         }
            
      }while(0);
      
      return 0;

      //tabzz4x4
   }

   int dec(DCT_TYPE *v, int *p, int k, int &iAdd, int &coefs){
      pTab=(int*)&ZIG_ZAG_TAB[0];
      return dec7x(v, k,iAdd,coefs);
      int iMin=p[0];
      if(iMin==4){
         iAdd=2;
         //memset(v,0,64*sizeof(DCT_TYPE));
         return 1;
      }
      if(iMin==0)
         pTab=(int*)&ZIG_ZAG_TAB[0];
      else if(iMin==1)
         pTab=(int*)&ff_alternate_v_scan[0];
      else if(iMin==2)
         pTab=(int*)&ff_alternate_h_scan[0];
      else if(iMin==3)
         pTab=(int*)&tabzz4x4_second[0];

      return decR(v,p+1, k,iAdd)+1;
   }
   int decR(DCT_TYPE *v, int *p, int k, int &iAdd){
     
     // return dec7x(v,k,iAdd);
      int cnt=*p;
      if(cnt==0 && p[1]==0){v[0]=0;iAdd=2;return 2;}
      /*
      if(cnt==-1 || cnt==0)
      {
         memset(v,0,64*sizeof(DCT_TYPE));
         iAdd=2;//cnt==-1?2:1;//cnt==2;//0?1:2;
         return 1;
      }
      */
      int iDec=0;
      if(0){//iIsKey || iHasDifOnly){
         if(cnt<0)cnt=(-1-cnt)*2+1;
         else cnt*=2;
         iAdd=iIsKey?0:1;
      }else{

      if(cnt>=0){
         iAdd=1;
      }
      else
      {
         cnt=-cnt-1;
         iAdd=0;
      }
      }
      
      //cnt--;
      p++;
      iDec++;
      //cnt++;
      int i;
     // memset(v,0,TVAL_DCT_SZ*sizeof(DCT_TYPE));
      i=0;
//      int val;
      //const int tabswapDC[5]={4,3,2,0,1};//enc
      /*
      {
         if(p[i]==-2)p[i]=0;
         else if(p[i]==2)p[i]=1;
         else if(p[i]==0)p[i]=-2;
         else if(p[i]==1)p[i]=2;
         */
      v[0]=p[0];
      if(iAdd==1 && cnt==0 && v[0]==0){
         iAdd=2;
         return 2;
      }
      
      //}
      iDec++;
      int xx=0;
      for(i=1;i<TVAL_DCT_SZ && xx<cnt;i++){

         v[pTab[i]]=p[i];
         if(p[i])xx++;
         iDec++;
      }
      for(;i<TVAL_DCT_SZ;i++)v[pTab[i]]=0;
      //if(cnt==0 && v[0]==0)iAdd=2;

      //if(iAdd==0)v[0]+=iPrevDc[k];
      //if(iAdd==0) iAdd=(v[0]==0)?2:0;
      return iDec;//iRDif?(ll+1):(i+1);//1;
      //return ll==0?(cnt+1):(ll+1);
   }
   int iPredGlob;

   int findSetBestPred(DCT_TYPE *v,unsigned char *pCur, unsigned char *pRef, int stride, int iFlag, int &sad, int iPred=-1)
   {
      int res[12];
      int iBest=-1;
      //iFlag=0;
      for(int i=iFlag==0?11:0;i<12;i++){
         fncPred[i](pCur,stride,iFlag);
         res[i]=sadIntMd(pCur,pRef,stride,iBest==-1?0x7fff:res[iBest]);
         if(iPred!=-1){
            res[i]+=mmabs(iPred-i)*2;
         }
         if(iBest==-1 || res[iBest]>res[i]){
            iBest=i;
         }
      }
      fncPred[iBest](pCur,stride,iFlag);
//      int xx;
      sad=res[iBest];
      //c_dif(v,pCur,pRef,stride,xx,-2,0);
      return iBest;
   }
   IMG_MB *mbFirst;
   int testBlocks(unsigned char *pCur, unsigned char *pRef, int w, int h, int q, int iMaxLen)
   {
      init(w,h,q);
      T_ALIGN_64(DCT_TYPE,q_quant,64);
      int i,j,k,ofs;
      vlc.reset();
      vlc.iCalcBitsOnly=1;
      int stride=w*3;
      IMG_MB *mb=mbFirst;
      int r;
      int ch=iSkipUV?1:3;

      //iMaxLen*=3;iMaxLen>>=2;
      
      ch=1;//
      if(iPass==1)
      {
         //5%
         iMaxNonDifAddCnt=xc*yc/20;
         //memset(mb,0,sizeof(IMG_MB)*xc*yc*ch);

         k=0;{
               int isY=k==0;
            for(j=0;j<yc;j++){
               ofs=j*TVAL_24*w+k;
               iPrevDc[k]=0;
               for(i=0;i<xc;i++,ofs+=TVAL_24){
                  mb[xc*yc].iSkip=mb[xc*yc*2].iSkip=mb->iSkip=0;
                  
                  mb->iIsDif=1;
                  mb->iEncBits=0;
                  mb->dc_quantized=0;
                  mb->iHasUpAndLeft=i && j;
                  mb->iMbPerRow=xc;
                  mb->iMaxCoef=-1;
                  mb->iCanBePic=1;
                  mb->iCanRestore=0;
                  mb->iStartPsnr=0;

                  int iSad=1000,iMinPosSad=1200,iMode=0,iTm=0,iVecLen;
                  mb->iPicMean=iSad*2;
                  if(i+1!=xc && iEncPicOnly==0 && getMBParams(i, j,  k,  w, iMode, iSad, iMinPosSad,iTm, mb->iPicMean,iVecLen)){
                     if(iLowQval && iSad<1200 && iVecLen>((w>>6)+3) && (iSad+300<iMinPosSad ||(iSad*10<mb->iPicMean)|| (iVecLen>3 && iSad*2<iMinPosSad)))iTm=128;
                     if(iSad*3+100<iMinPosSad*2 && iSad<getMinPosSad())iTm=128 ;
                     if(iSad*6<iMinPosSad)iTm=128;
                     if(iTm==128 || (iTm && iSad<iMinPosSad && iSad<600)||
                        (iLowQval && iSad>0 && ((iSad<500 && iSad<iMinPosSad) || (iSad<900 && iSad*2<iMinPosSad) ||(iSad<1100 && iSad*5<iMinPosSad*2)))
                        ||(!iLowQval && iSad>0 && ((iSad<300 && iSad<iMinPosSad) || (iSad<600 && iSad*2<iMinPosSad))))
                     //if(iSad>0 && iSad<4000 && iSad<iMinPosSad)
                     {
                        if(0){
                        mb->iSkip=1;
                        mb->iDifSad=(iSad>>3)+200;
                        mb++;
                        continue;
                        }
                     }
                     mb->iCanBePic=(iSad*3>iMinPosSad*8) || iSad*3>mb->iPicMean*2 || (mb->iPicMean<300 && iSad>iMinPosSad);
                     if(mb->iCanBePic && (iSad*15<mb->iPicMean || iSad<iMinPosSad))mb->iCanBePic=0;
                     mb->iCanRestore=(iSad*2<iMinPosSad) || (iSad<iMinPosSad && iSad<1100)  || (iSad*8<iMinPosSad*7 && iSad<900);
                  }
                  
                  mb->iDifSad=(iSad>>3)+200;
                  mb->iIs4x4=(iMode==0 && iTm>0 && iSad<iMinPosSad) || (iSad*2<iMinPosSad*3 && iMode>1) || (iSad<iMinPosSad+200 && iSad<1500);
                  if(mb->iPicMean>0 && mb->iPicMean==10 && iSad>800)mb->iSkip=5;
                  else if(mb->iPicMean>0 && mb->iPicMean==10 && iSad>200)mb->cnt+=2;
                  else if(mb->iPicMean>0 && mb->iPicMean<50 && iSad>1000)mb->iSkip=5;
                  else if(mb->iPicMean>0 && mb->iPicMean<100 && iSad>800)mb->cnt+=2;

                  //if(mb->iIs4x4 && iSad*3>iMinPosSad)mb->iIs4x4=3;

                  //if(getSkipVal(i,j,xc))
                  //mb[xc*yc*2].iSkip=mb[xc*yc].iSkip=mb->iSkip=1;else 
                  r=encMB(mb,&q_quant[0], pCur+ofs, pRef+ofs,  stride, isY);
                  mb++;

               }
            }
         }
         iPass=2;
      }

//--fast
     if(iMaxLen==0) return 0;
      mb=mbFirst;
      int iMinLen=iMaxLen*15;iMinLen>>=4;
      iMaxLen*=17;iMaxLen>>=4;

      //iMaxLen*=9;iMaxLen/=8;

      //int ch=dctx->iSkipDct?1:3;
      int id=0;
      k=0;{
            int isY=k==0;
      for(j=0;j<yc;j++){
         ofs=j*TVAL_24*w+k;
         iPrevDc[k]=0;
         for(i=0;i<xc;i++,ofs+=TVAL_24,mb++){
            id++;
            mb->iEncBits=0;
            mb->dc_quantized=0;
            
            
            

            if(mb->iSkip==1){iPrevDc[k]=0;continue;}
            r=encMB(mb,&q_quant[0], pCur+ofs, pRef+ofs,  stride, isY);
            
            if(!r || mb->iSkip==1){iPrevDc[k]=0;continue;}
            
            //if(((i && mb[-1].iEncBits==0 ) || !i) && j  && mb[-xc].iEncBits)iPrevDc[k]=mb[-xc].dc_quantized;
            int iAddData,iAddPos=0;
            iPredDC=!isY?0:getPredDC(i,j,xc,mb,0,&iAddData,iAddPos);
            

//            short blx[120];
            int iAdd=mb->iIsDif?1:0;//(mb->iQuantCoefSum>0?0:2);
            int iBO=vlc.iBitPos;
            //mb->dc_quantized=q_quant[0];
            if(0&& q==84){//i==46 && j==27 && mb->iQuantCoefSum==25){
               debugss("tb3-i,j",i,j);//49,43
               debugss("tb3-m,d",mb->iIs4x4,mb->iIsDif);//49,43
               debugss("tb3-cnt,mc",mb->cnt,mb->iMaxCoef);//49,43
               debugss("tb3-cq.cdct",mb->iCoefsQuant,mb->iCoefsDct);//49,43
               debugss("tb3-sum,iAdd",mb->iQuantCoefSum,iAdd);//49,43
               char bufC[512];
               for(int tt=0;tt<64;tt+=4){
                  sprintf(&bufC[0],"%4d %4d %4d %4d",q_quant[tt+0],q_quant[tt+1],q_quant[tt+2],q_quant[tt+3]);
                  debugss(&bufC[0],0,vlc.iBitPos>>3);
               }


            }
            encR(&q_quant[0],NULL,k,iAdd+mb->iIs4x4);
            mb->iEncBits=vlc.iBitPos-iBO;
            if(vlc.iBitPos>100){
            if(iAdd==0 && mb->cnt>10)vlc.iBitPos-=(mb->iEncBits>>1);
            if(iAdd==0 && mb->cnt>30)vlc.iBitPos-=(mb->iEncBits);
            if(iAdd==0 && mb->cnt>3)vlc.iBitPos-=(mb->iEncBits>>2);
            if(vlc.iBitPos<0)vlc.iBitPos=0;
            }
            vlc.iBitPos+=5;
//if(i==46 && j==27 && mb->iQuantCoefSum==25)debugss("tb23-",i,j);//49,43
         }
         if(vlc.getBytePos()>iMaxLen && id>(xc*yc>>2)){
            vlc.iBitPos*=(xc*yc);vlc.iBitPos/=id;
            vlc.iBitPos+=(iMaxLen<<3);
            vlc.iBitPos>>=1;
            return 1;
         }
      }
      }

      return vlc.getBytePos()<iMinLen?-1:0;
   }
   int iPredTLB;
   template< class T >
   inline int getPredDC(int i, int j, int xc, T *mb, int  iIsDec ,int *encDat, int &iPos){
      int dc=0;
     // return 0;
      iPredTLB=0;
      if(mb->iIsDif==0)
      {
         
         int dcs[3]={0,0,0};
         int iM=0;
         int iDCs=0;
         if(i && mb[-1].iSkip!=1  &&  mb->iIsDif==mb[-1].iIsDif && mb[-1].iCanUseAsPred){dcs[iDCs]=mb[-1].dc_quantized;iDCs++;}
         if(j && mb[-xc].iSkip!=1  && mb->iIsDif==mb[-xc].iIsDif&& mb[-xc].iCanUseAsPred ){dcs[iDCs]=mb[-xc].dc_quantized;iDCs++;}
         else if(iDCs==0 && i && j && mb[-xc-1].iSkip!=1  && mb->iIsDif==mb[-xc-1].iIsDif && mb[-1-xc].iCanUseAsPred){dcs[iDCs]=mb[-xc-1].dc_quantized;iDCs++;}
         else if(iDCs==0 && i+1<xc && j && mb[1-xc].iSkip!=1  && mb->iIsDif==mb[1-xc].iIsDif && mb[1-xc].iCanUseAsPred){dcs[iDCs]=mb[1-xc].dc_quantized;iDCs++;}
         if(iDCs){
            dc=dcs[0];
            iPredTLB=1;
            if(iDCs>1)
            {
               if(iIsDec){
                  if(dcs[0]!=dcs[1])
                  {
                     if(vlc.getB()){
                        dc=dcs[1];
                        iPredTLB=2;
                     }
                     
                  }
                  else iPredTLB=3;
               }
               else{

                   if(dcs[0]!=dcs[1])
                   {
                      int iM2;
                      iM=mmabs(mb->dc_quantized-dcs[0]);
                      iM2=mmabs(mb->dc_quantized-dcs[1]);
                      if(iM>iM2)
                      {
                         encDat[0]=1;
                         iPos++;
                         //vlc.addB(1);
                         dc=dcs[1];
                         iPredTLB=2;
                      }
                      else {
                         encDat[0]=0;
                         iPos++;
                        // vlc.addB(0);
                         dc=dcs[0];
                      }
                      //TODO rle
                      //,(unsigned char*)&bufTmp[0]);
                      //encDat[0]=iM>iM2;iPos++;
                   
                   }
                   else iPredTLB=3;
               }
            }
            //else dc=dcs[0];

         }

      }
      return dc;

   }
   int adjQ(int q){
      q/=4;
      q*=4;
      return q;
   }
   int saveHdr(unsigned char *pOut, int w, int h, int &q){
      //*(short*)pOut=w;
      //*(short*)(&pOut[2])=h;
      pOut[0]=(w&0xff);pOut[1]=(w>>8);
      pOut[2]=(h&0xff);pOut[3]=(h>>8);
      if(q>98)q=98;
      if(q<4)q=4;
      q-=4;
      q/=4;
      pOut[4]=q;
      q*=4;
      q+=4;
    //  q=50;
      
      if(iIsB)pOut[4]|=0x20;
      if(iIsKey)pOut[4]|=0x40;
      pFlag=&pOut[4];
      pData=pFlag+2;

      pOut[5]=1;
      
      return 6;
   }
   unsigned char *pFlag;
   unsigned char *pData;
   int encPass7(unsigned char *pCur, unsigned char *pRef, int w, int h, int q, unsigned char *pOut)
   {
      if(iSkipId && iSkipId==xc*yc*3 && w==this->iW && h==this->iH){iSkipId=0;return 0;}//or w!h

      initMem(w,h);
      if(iSkipId==0)iYLen=0;

      pOut+=saveHdr(pOut,w,h,q);
      iTotalCoefs=0;
      vlc.iCalcBitsOnly=0;
      int iMin=101-q;
      if(iMin<12)iMin=12;
      int iMinSum=q>65?(q>85?2:1):1;
      iEncValues=0;
      int qIn=q;
      init(w,h,q);
      //iYLen=0;
      int i,j,k,ofs;
      T_ALIGN_64(DCT_TYPE,q_dct,64*3);
      T_ALIGN_64(DCT_TYPE,q_quant,64*3);
      T_ALIGN_64(DCT_TYPE,savedBlock,64*3);
      int id=0;
      int stride=w*3;
//      int sum;
      int iCnt=0;
      int iLen=0;
      int iSk=0;
      int iAdd;
      int r;
      int iWasSum=0;
      int iLastSkPos=-1;
      iCurBl=0;
      iBlStride=xc;
      int skr=0;
      IMG_MB *mb=mbFirst;
      IMG_MB *mbY=mbFirst;
      int iSkStart[3]={-1,-1,-1};
      int ch=iSkipDct||iSkipUV?1:3;
      int iHasLimitFound=0;
      int mxcXyc=-xc*yc;
      
      int iPassK=0;
      for(k=0;k<ch;k++){
         if(iPassK && k==1)iYLen+=vlc.getBytePos();
         iPassK=1;
         iPrevCoefsCnt4x=iPrevCoefsCnt=0;

            int isY=k==0;
            iSkStart[k]=iSkipValues;
            mbY=mbFirst;
      for(j=0;j<yc;j++){
         ofs=j*TVAL_24*w+k;
         iPrevDc[k]=0;
         if(this->iPartLimitSize && vlc.getBytePos()>iPartLimitSize)
         {
            if(k==0)iYLen+=vlc.getBytePos();
            iSkipId=id;
            iSk+=xc*(yc-j)+(ch-k-1)*xc*yc;
            iHasLimitFound=1;
            k=100;
            break;
         }
         for(i=0;i<xc;i++,id++,ofs+=TVAL_24,iCurBl++,mb++,mbY++){
            if(iSkipId && id<iSkipId){
               mb->iCanUseAsPred=0;
               iSk++;
               continue;
            }
            mb->iCanUseAsPred=1;

            
            // || (mb->iIsDif && mb->iCoefsQuant==0)

            if(k){
               r=0;
               mb->iIsDif=1;
               mb->dc_quantized=0;
               //if(k!=2 || mb[mxcXyc].iSkip!=1 || mbY->iSkip!=1)
               {
                  mb->iMaxCoef=-1;
                  mb->iSkip=0;
                  mb->iHasUpAndLeft=i && j;
                  mb->iMbPerRow=xc;
                  r=encMB_UV(mbY,k==2?&mb[mxcXyc]:NULL,mb,&q_quant[0], pCur+ofs, pRef+ofs,  stride, isY,1,0);
               }
              
               //iPass=7;
              //r=encMB(mb,&q_quant[0], pCur+ofs, pRef+ofs,  stride, isY);
            }
            else {
              //if(mb->iSkip==1)//{if(iIsB==0)mb->cnt++;setDCT_STAT(i,j,k,w,mb->iMaxCoef,0);iPrevDc[k]=0;iSk++;mb->iEncBits=0;mb->dc_quantized=0;mb->iIsDif=1;continue;}
              if(mb->iSkip==1)
                 r=0;
              else
                 r=encMB(mb,&q_quant[0], pCur+ofs, pRef+ofs,  stride, isY);
            }
            if(!r || mb->iSkip==1){
               iPrevDc[k]=0;iSk++;mb->iEncBits=0;mb->dc_quantized=0;
               mb->iSkip=1;
               mb->iIsDif=1;
               if(iIsB==0)mb->cnt++;
               setDCT_STAT(i,j,k,w,mb->iMaxCoef,0,mb);
               iPrevCoefsCnt4x=iPrevCoefsCnt=0;

               continue;
            }
//debugss("enc",i,j);//49,43
            if(iIsB==0){if(mb->iIsDif)mb->cnt++;else mb->cnt=0;}
            mb->dc_quantized=q_quant[0];
            int imgAdddata=-1;
            int iImgAddPos=0;
            iAdd=mb->iIsDif;//?1:(mb->iQuantCoefSum?0:2);
            iPredDC=getPredDC(i,j,xc,mb,0,&imgAdddata,iImgAddPos);

            //if(iAdd==2)mb->dc_quantized=0;


            if(iIsKey)filter(pCur+ofs,stride,j==0,i==0,k);

            //iLen+=setSkipLen(&img[iLen],iSk);
            iSkipValues+=setSkipLen(&skVal[iSkipValues],iSk);
            iSk=0;
            
            int bp=vlc.iBitPos;
           // memcpy(&mb->dct[0],&q_quant[0],128);
            iLen+=encR(&q_quant[0],NULL,k,iAdd+mb->iIs4x4);
//debugss("enc ok",i,j);
            if(iImgAddPos){vlc.addB(imgAdddata);}
            setDCT_STAT(i,j,k,w,mb->iMaxCoef,vlc.iBitPos-bp,mb);
            //iPrevDc[k]=q_quant[0];
            iWasSum=1;//sum>0 || rem;
            continue;

         }
         
         }
         
      }
      if(!iHasLimitFound)iSkipId=3*xc*yc;

      if(!iWasSum ){iSkipId=0;return 0;}

//      iLen+=setSkipLen(&img[iLen],iSk);
      iSkipValues+=setSkipLen(&skVal[iSkipValues],iSk);
      int t_zipIt(char* pData, int iDataLen, char *pOut);
      int encAritm(unsigned char *out , int *in ,int iCnt);
      int encAritmC(unsigned char *out , short *in ,int iCnt);
      int encAritmUS_I(unsigned char *out , int *in ,int iCnt);
      int encAritmNH_S(unsigned char *out , int *in ,int iCnt);
      int compress_coefs(int *v, int iCnt, unsigned char* buffer);
      int compress_coefsSH(short *v, int iCnt, unsigned char* buffer);

      if(iHasDifOnly)pFlag[0]|=0x80;
      iLen=s_encAritm(a_int,pData,&skVal[0],iSkipValues);
      if(!iHasDifOnly/* && !iIsKey*/)
         iLen+=s_encAritmUC(a_uc,pData+iLen , mbType ,iMbTypePos);
      int iVlcLen=vlc.getBytePos();
      memcpy(pData+iLen,vlc.pBitBuf,iVlcLen);
      iLen+=iVlcLen;

#if 0
      iLen=enc2UintValues(pOut,&img[0],iLen);//encAritmNH_S
      //int iLenO=iLen;
      
      if(1)//iEncValues>0)
      {

         if(1)//iEncValues<800)
         {
            iEncValues=vlc.getBytePos();
            
         //   iEncValues=encAritmUS_I(pOut+iLen*4,&img[0],iEncValues);
            iSkipValues=encAritm(pOut+iLen*4,&skVal[0],iSkipValues);
            iEncValues+=iSkipValues;
            //iEncValues+=encAritm(pOut+iLen*2+iEncValues,&skVal[iSkStart[0]],iSkStart[1]-iSkStart[0]);//iSkipValues);
            //iEncValues+=encAritm(pOut+iLen*2+iEncValues,&skVal[iSkStart[1]],iSkStart[2]-iSkStart[1]);
            //iEncValues+=encAritm(pOut+iLen*2+iEncValues,&skVal[iSkStart[2]],iSkipValues-iSkStart[2]);
         }
         else
         {
            //for(i=0;i<iEncValues;i++)img2[i]=tab_enc_dct[(int)img2[i]+128];
            iEncValues=t_zipIt((char*)&img2[0],iEncValues,(char*)pOut+iLen*2);
            //iEncValues+=encAritm(pOut+iLen*4,&skVal[0],iSkipValues);
            iEncValues+=vlc.getBytePos();
            //iEncValues+=((iPredValues>>1));
         }
         
         iEncValues+=((iSigns+7)>>3);
         //iEncValues+=((iPredValues>>1));//t_zipIt(&predv[0],iPredValues,(char*)pOut+iLen*2);
      }
      if(iHasDifOnly)pFlag[0]|=0x80;
     // if()pFlag
#endif 
      
      return iLen+6;

   }
   CTAritmCoding<int> a_int;
   CTAritmCoding<unsigned char> a_uc;
   int iPrevQ;
   int iYLen;
   int iKeyYLen;
   int changeQ(int ret, int q, int iMaxLen, int iCurSize, int jumpSzInc=1){
      int iMinLen=(iMaxLen*7)>>3;
       //iMaxLen=(iMaxLen*9)>>3;
     // if(iMinLen<=iCurSize && iCurSize<=iMaxLen)return q;

      int avg=(iMinLen+iMaxLen)>>1;
      int qN=q;
      //if(ret==0)
      {
  //       if(iCurSize*8<iMinLen*7)ret=-1;
    //     else if(iCurSize*7>iMaxLen*8)ret=1;
      }
      //too big
      if(iCurSize<1)iCurSize=1;
      int d;
      if(ret==1){
         qN=q*avg/(iCurSize);
         //if(qN>q)qN=q-4*jumpSzInc;
         //else
         {
            d=mmabs(qN-q);
            if(d>10)qN=q-6*jumpSzInc;
            else if(d<4)qN=q-4*jumpSzInc;
         }
      }
      else if(ret==-1){
         qN=q*(avg)/(iCurSize);
         //if(qN<q)qN=q+4*jumpSzInc;
         //else
         {
            d=mmabs(qN-q);
            if(d>6)qN=q+5*jumpSzInc;
            else if(d<4)qN=q+4*jumpSzInc;
         }
      }
      else if(ret==0){
      //   qN=q*(avg)/(iCurSize);
        // if(qN>q && qN-q>4)qN=q+4;
       //  else if(q>qN && q-qN>4)qN=q-4;
      }
      if(qN>98)qN=98;else if(qN<12)qN=12;
      q=qN;
      

      return q;
   }
   int iWasRet;
   int iPrevIsLowQval;
   int encTest(unsigned char *pCur, unsigned char *pRef, int w, int h,int iQIn, unsigned char *pOut, int iMaxLen)
   {
      
      if(iNextQ>iQIn+8){
         iNextQ+=iQIn;
         iQIn>>=1;
      }
      int iQStep=24;
      int iAvgLen=iMaxLen=(int)sqrt((float)w*(float)h)*8;//+((w*h*10)>>8);
      iMaxLen=((iKeyYLen/4)+iAvgLen)>>1;//(w*h)>>6;//(iPrevRefSize*3)>>2;//(w*h*12)>>8; // div 25
      if(iMaxLen*3<iAvgLen*2 || iMaxLen*3>iAvgLen*4)iMaxLen=iAvgLen;

      if(!iLowQval){
         iMaxLen*=3;iMaxLen>>=1;iQIn+=4;
         iMaxLen=(iKeyYLen+iAvgLen)>>2;
         if(iSkipId==0 && iPrevIsLowQval)iNextQ+=4;
      }
      else if(iSkipId==0 && !iPrevIsLowQval){iNextQ-=4;}
      iPrevIsLowQval=iLowQval;
      //iMaxLen=500;//w*h/40;




      int iMaxQ=iQIn;
//      if(iQIn<64)iMaxQ+=4;
      //if(iQIn<54)iMaxQ+=4;
      if(iQIn<40)iMaxQ+=4;
     // if(iMaxQ>92)iMaxQ=92;
      int iMinQ=(iQIn*3)>>3;
      if(this->iIsB){iMaxQ=iQIn-4;}
      if(iMinQ<12)iMinQ=12;

      //iMaxLen=3000;iMinQ=12;iMaxQ=96;
      //iMaxLen=1000;//iMaxQ=96;

      //iMaxQ=98;
      //iMinQ=8;
      if(iNextQ*8<iQIn*3)iNextQ=(((iQIn*3)>>2));
      int ret=0;
      int q=iNextQ;


     
 
      //iMaxLen*=2;iMaxLen/=3;//if  testBlocks Y only

      iQIsMax=q>((iMaxQ*15)>>4);
      

      int l;
      if(iSkipId){
         iPass=4|2;
         l= encPass7(pCur,pRef,w,h,iNextQ,pOut);

         if(iWasRet>0 && iSkipId>=(xc*yc>>1)  && iSkipId<=(xc*yc) && 4*iYLen*xc*yc/iSkipId>5*iMaxLen){
            q-=4;
            q=q<iMinQ?iMinQ:(q>iMaxQ?iMaxQ:q);
         }
        
         if(iSkipId>=xc*yc  && iYLen>iMaxLen*2){
            if(iWasRet){
               iWasRet=0;
               q-=12;
               q=q<iMinQ?iMinQ:(q>iMaxQ?iMaxQ:q);
            }
            //iYLen=0;
         }
         if(iSkipId>=xc*yc  && iYLen*2<iMaxLen){
            if(iWasRet){
               iWasRet=0;
               q+=4;
               q=q<iMinQ?iMinQ:(q>iMaxQ?iMaxQ:q);
            }
            //iYLen=0;
         }
         
         iNextQ=q;

         return l;
      }
      iYLen=0;

      //if(mbFirst==NULL)mbFirst=new IMG_MB[(2048*1024*3)>>6];
      iPass=1;
      //double dq;
      iHasDifOnly=1;
      int qcheked[]={0,0,0,0,0,0,0,0,0,0};
      //int iChecked=0;
      int iF=0;

      int zz;
      int zzz;

      q=adjQ(q);
      iPrevQ=q;
      const int tjm[]={8,4,8};
      const int tja[]={4,4,4};
      int res[]={0,0,0,0,0};
      int iMChecks=2;

      for(zz=0;zz<iMChecks;zz++){

         iQIsMax=q>((iMaxQ*15)>>4);

         for(zzz=0;zzz<zz;zzz++){if(q==qcheked[zzz]){iF=1;break;}}
         if(iF)break;
         
         ret=testBlocks(pCur,pRef,w,h,q,iMaxLen);
         qcheked[zz]=q;
         res[zz]=vlc.getBytePos();
         //q=changeQ(ret,q,iMaxLen,vlc.getBytePos(),zz==0?3:1);
         int qPr=q;
         if(ret==1)q-=tjm[zz];
         else if(ret==-1){
            int d=(iMaxLen-vlc.getBytePos())*100/iMaxLen;
            if(d<6){ret=0;break;}
            if(d<12){q+=4;}
            else q+=tja[zz];
         }

         if(q<iMinQ){
            //zz++;
            q=(iMinQ+qPr)>>1;
         }
         else if(q>iMaxQ){
           // zz++;
            q=(iMaxQ+qPr)>>1;
         }
         q=adjQ(q);

         if(ret==0)break;
      }
      int iBestId=0;
      
      if(ret){
         for(zz=1;zz<iMChecks;zz++){
            if(mmabs(iMaxLen-res[zz])<mmabs(iMaxLen-res[iBestId]))
               iBestId=zz;
         }
         q=qcheked[iBestId];
      }
      iWasRet=ret;
      iPass=4+2;


      iQIsMax=q>((iMaxQ*15)>>4);
      
      l=encPass7(pCur,pRef,w,h,q,pOut);
      if(iWasRet>0 && iSkipId>=(xc*yc>>1) && iSkipId<=(xc*yc) && 4*iYLen*xc*yc/iSkipId>5*iMaxLen){
         q-=4;
         q=q<iMinQ?iMinQ:(q>iMaxQ?iMaxQ:q);
         iWasRet=0;
      }

      if(iSkipId>=xc*yc){
         if(iWasRet>0){
            if(iYLen*3>iMaxLen*4){
               if(iYLen>iMaxLen*2)q-=8;
               else q-=4;
            }
            else if(iYLen*4<iMaxLen*3 && q<55){
               q+=4;
            }
            q=q<iMinQ?iMinQ:(q>iMaxQ?iMaxQ:q);
            iWasRet=0;
//            iYLen=0;
         }
      }

      iNextQ=q;
      //if(iIsB==0 && l*5<iMaxLen*4)q+=12;
      return l;
   }
   int iNextQ;
   int iPrevRefSize;
   int iSkipId;

   int iXLen;
   int encode(unsigned char *pCur, unsigned char *pRef, int w, int h, int q, unsigned char *pOut,int iDecode=1){

      if(iSkipId && iSkipId==xc*yc*3 && w==this->iW && h==this->iH){
         iSkipId=0;
         return 0;
      }//or w!h
      if(iIsKey && iSkipId==0){
         iKeyYLen=0;
      }
      if(iSkipId==0){
         iXLen=0;
      }
      /*
      //straadaaa
      static int qOutV=q;

      int iMaxFrLen=3000;//12000;
      int iCheckStart=iSkipId==0?100:400;

      if(iSkipId && iSkipId<xc*yc){
         
         int iPredSz=iXLen*xc*yc/iSkipId;
         if(iPredSz*4>iMaxFrLen*5)qOutV-=4;
         else if(iPredSz*5<iMaxFrLen*4)qOutV+=4;
         if(qOutV>92)qOutV=92;else if(qOutV<12)qOutV=12;
         

      }
      q=qOutV;

*/


      initMem(w,h);
      iPass=7;
      pOut+=saveHdr(pOut,w,h,q);
      vlc.reset();
      vlc.iCalcBitsOnly=0;
      //if(mbFirst==NULL)mbFirst=new IMG_MB[(2048*1024*3)>>6];
      int iMin=101-q;
      if(iMin<12)iMin=12;
      int iMinSum=q>65?(q>85?2:1):1;
      iEncValues=0;
      int qIn=q;
      init(w,h,q);
      int i,j,k,ofs;
      T_ALIGN_64(DCT_TYPE,q_dct,64*3);
      T_ALIGN_64(DCT_TYPE,q_quant,64*3);
      T_ALIGN_64(DCT_TYPE,savedBlock,64*3);
      if(iDecode==0)iPrevRefSize=0;


      int id=0;
      int stride=w*3;
//      int sum;
//      int iCnt=0;
      int iLen=0;
      int iSk=0;
      int iAdd;
      int r;
      int iWasSum=0;
      int iLastSkPos=-1;
      iCurBl=0;
      iBlStride=xc;
      int skr=0;
      IMG_MB *mb=mbFirst;
      IMG_MB *mbY=mbFirst;
      iHasDifOnly=1;
      DCT_TYPE dcRowtart[3]={0,0,0};
      int ch=iSkipDct||iSkipUV?1:3;
      int iUsePrevDC=1;
      int iHasLimitFound=0;
      int mxcXyc=-xc*yc;
      if(iDecode==0 && iSkipId==0)iMaxNonDifAddCnt=xc*yc/5;
      int iPassK=0;
      int iEncPicOnlyIn=iEncPicOnly;
      int iDecodeIn=iDecode;
      for(k=0;k<ch && iHasLimitFound==0;k++){
      int iRowsSent=0;
      iPrevCoefsCnt4x=iPrevCoefsCnt=0;
/*
         if(iDecode==0 && k==1){
            int bp=vlc.getBytePos();
            int ma=w*h/10;
            int mi=w*h/40;
            if(bp>ma || bp<mi)bp=w*h/20;
            iPrevRefSize=(bp+iPrevRefSize+1)>>1;
         }
         */
         if(iPassK==1){
            if(k==1 && iIsKey) iKeyYLen+=vlc.getBytePos();
            if(k==1)iXLen+=vlc.getBytePos();
         }
         iPassK=1;

         int isY=k==0;
         mbY=mbFirst;
      for(j=0;j<yc;j++){
         ofs=j*TVAL_24*w+k;
         iPrevDc[k]=dcRowtart[k];
            iPredDC=0;
            //int iPredSz=k==0  && j?iXLen*yc/j:iMaxFrLen;
         if(this->iPartLimitSize && (vlc.getBytePos()>iPartLimitSize || (iRowsSent>6 && iIsKey)))// || (vlc.getBytePos()>iCheckStart && ((qOutV<92 &&  iPredSz*5<iMaxFrLen*4) || (iPredSz*4>iMaxFrLen*5 && qOutV>12)))))
         {
            iSkipId=id;
            iSk+=xc*(yc-j)+(ch-k-1)*xc*yc;
            iHasLimitFound=1;
            if(k==0 && iIsKey) iKeyYLen+=vlc.getBytePos();
            if(k==0)iXLen+=vlc.getBytePos();
          //  k=100;
            break;
         }
         for(i=0;i<xc;i++,id++,ofs+=TVAL_24,iCurBl++,mb++,mbY++){
            if(iSkipId && id<iSkipId){
               mb->iCanUseAsPred=0;
               iSk++;
               continue;
            }
            mb->iIs4x4=0;
            mb->iCanUseAsPred=1;
            mb->iMaxCoef=-1;
            mb->iSkip=iIsKey && iEncPicOnly==0?5:0;
            mb->iIsDif=1;
            mb->iHasUpAndLeft=i && j;
            mb->iMbPerRow=xc;
            mb->iEncBits=0;
            mb->dc_quantized=0;
            int iSad=1000,iMinPosSad=1200,iMode=0,iTm=0,iVecLen=0;
            mb->iPicMean=iSad*2;
            mb->iCanBePic=1;
            mb->iCanRestore=0;
            mb->iStartPsnr=0;
         
            if(0&&(iEncPicOnly|iIsKey) && k==0 && i && j){       
               iEncPicOnly=0;
               iUsePrevDC=0;
               int iFlag=0;
               if(i+1!=xc && j)iFlag|=MB_TOPRIGHT;
               if(i && j)iFlag|=MB_TOPLEFT;
               mb->iIsDif=1;
               //iPass=6;
               mb->iSkip=0;
               int iPredVal=findSetBestPred(&mb->dct[0],pCur+ofs, pRef+ofs,stride,iFlag,iSad);
               vlc.toVLC(iPredVal);
               //vlc.iBitPos++;
               
               iDecode=0;
            }
            else{
               iDecode=iDecodeIn;
               iEncPicOnly=iEncPicOnlyIn;
             /*  
               if(k==0 && iIsKey==0 && iEncPicOnly==0 &&    getMBParams(i, j,  k,  w, iMode, iSad, iMinPosSad,iTm, mb->iPicMed)){
                  //TODO check vec
                  if(iSad>0 && iIsB&& i+1!=xc && iSad>0 && ((iSad<800 && iSad<iMinPosSad) || (iSad<1200 && iSad*2<iMinPosSad) ||(iSad<1800 && iSad*3<iMinPosSad))){
                     iPrevDc[k]=0;iSk++;mb->iEncBits=0;mb->dc_quantized=0;
                     mb->iSkip=1;
                     mb->iDifSad=(iSad>>3)+200;
                     iPredDC=0;
                     if(iIsB==0)mb->cnt++;
                     setDCT_STAT(i,j,k,w,mb->iMaxCoef,0,mb);
                     iPrevCoefsCnt4x=iPrevCoefsCnt=0;
                     continue;
                  }
                  mb->iDifSad=(iSad>>3)+200;
                  
               }
               */
//               int iVecLen=0;
               if(k==0 && iIsKey==0 && iEncPicOnly==0 && i+1!=xc && iEncPicOnly==0 && getMBParams(i, j,  k,  w, iMode, iSad, iMinPosSad,iTm, mb->iPicMean,iVecLen)){
                  if((iIsB && (iSad<1200 && iVecLen>((w>>7)+2) && (iSad<iMinPosSad || iSad*6<mb->iPicMean)))||(iSad<2*iMinPosSad && iVecLen>((w>>4)+8)  && iMode<2))iTm=128;
                  if(getMinPosSad()>iSad){
                     if(iIsB ||(iDecode==0 && mb->cnt<8 && (iSad*2+80<iMinPosSad || iSad<10)))iTm=129 ;
                  }
//if(iIsB && iSad<iMinPosSad*2)iTm=129;
                  if(iIsB && iSad*2+100<iMinPosSad)iTm=129;
                  if(iIsB && iSad*2<iMinPosSad && iSad<getMinPosSad()+600)iTm=129 ;
                  if((iIsB && iTm>0 && iTm<128 && iSad<iMinPosSad)|| (iTm==129) || 
                     (iIsB==0 && (iSad<400 && iSad*2<iMinPosSad))||
                     (iIsB &&  iSad>0 && ((iSad<500 && iSad<iMinPosSad) || (iSad<900 && iSad*2<iMinPosSad) ||(iSad<1100 && iSad*5<iMinPosSad*2))))
                  {
                     if(iIsB){
                     iPrevDc[k]=0;iSk++;mb->iEncBits=0;mb->dc_quantized=0;
                     mb->iSkip=1;
                     mb->iDifSad=(iSad>>3)+200;
                     iPredDC=0;
                     //if(iIsB==0)mb->cnt++;
                     setDCT_STAT(i,j,k,w,mb->iMaxCoef,0,mb);
                     iPrevCoefsCnt4x=iPrevCoefsCnt=0;
                     continue;
                     }
                  }
                  mb->iCanBePic=iSad>iMinPosSad*2 || iSad*3>mb->iPicMean*2 || mb->iPicMean<1000;
                  mb->iCanRestore=(iSad*2<iMinPosSad) || (iSad<iMinPosSad && iSad<2200)  || (iSad*8<iMinPosSad*7 && iSad<900);


                  mb->iDifSad=(iSad>>3)+200;
                  mb->iIs4x4=(iMode==0 && iTm>0 && iTm<128 && iSad<iMinPosSad) || (iSad*2<iMinPosSad*3 && iMode>1) || (iSad<iMinPosSad+200 && iSad<1500);
                  if(iIsB==0){
                     if(mb->iPicMean>0 && mb->iPicMean==10 && iSad>300)mb->iSkip=5;
                     else if(mb->iPicMean>0 && mb->iPicMean<50 && iSad>1000)mb->iSkip=5;
                     else if(mb->iPicMean>0 && mb->iPicMean<200 && iSad>500)mb->cnt+=10;
                  }

               }
               
               

            }

            if(k){
  //             r=0;
//if(iIsB )r=0;else
               //if(k!=2 || mb[mxcXyc].iSkip!=1 )
                  r=encMB_UV(mbY,k==2?&mb[mxcXyc]:NULL,mb,&q_quant[0], pCur+ofs, pRef+ofs,  stride, isY,iDecode,iDecode==0);
               
            }
            else{
               if(iEncPicOnly==0){
                 // mb->iIs4x4=(iMode==0 && iTm>1 && iSad>iMinPosSad) || iMode>1?1:0 || iSad<iMinPosSad+400;
                  //if(mb->iIs4x4 && iSad*3>iMinPosSad )mb->iIs4x4=3;
               }
             //  if((i<xc/2 && i>7) || (j<yc/2 && j>7))mb->iSkip=5;

               r=encMB(mb,&q_quant[0], pCur+ofs, pRef+ofs,  stride, isY,iDecode);
            }

            if(!r || mb->iSkip==1 ){
               iPrevDc[k]=0;iSk++;mb->iEncBits=0;mb->dc_quantized=0;
               mb->iSkip=1;
               iPredDC=0;
               if(iIsB==0)mb->cnt++;
               setDCT_STAT(i,j,k,w,mb->iMaxCoef,0,mb);
               iPrevCoefsCnt4x=iPrevCoefsCnt=0;
               continue;
            }
            
            //if(((i && mb[-1].iEncBits==0 ) || !i) && j  && mb[-xc].iEncBits)iPrevDc[k]=mb[-xc].dc_quantized;
            mb->dc_quantized=q_quant[0];
            //iPrevDc[k]=0;
            if(iIsB==0){if(mb->iIsDif)mb->cnt++;else mb->cnt=0;}
            int imgAdddata=-1;
            int iImgAddPos=0;
         //   if(iUsePrevDC)
            {
               iAdd=mb->iIsDif;//?1:(mb->iQuantCoefSum?0:2);
               iPredDC=getPredDC(i,j,xc,mb,0,&imgAdddata,iImgAddPos);

            }
            


            if(iIsKey || iEncPicOnly)filter(pCur+ofs,stride,j==0,i==0,k);

          //  iLen+=setSkipLen(&img[iLen],iSk);
            iSkipValues+=setSkipLen(&skVal[iSkipValues],iSk);
            iSk=0;
            
            int bp=vlc.iBitPos;
            
            iLen+=encR(&q_quant[0],NULL,k,iAdd+mb->iIs4x4);
            
            if(iImgAddPos){vlc.addB(imgAdddata);}
           // memcpy(&mb->dct[0],&q_quant[0],64*2);
            setDCT_STAT(i,j,k,w,mb->iMaxCoef,vlc.iBitPos-bp,mb);

//mb->dc_quantized=q_quant[0];
            //if(iImgAddPos){img[iLen]=imgAdddata;iLen++;}
            //iPrevDc[k]=q_quant[0];
            iWasSum=1;//sum>0 || rem;
            if(i==0)iRowsSent++;
            continue;

         }
         
         }
         
      }
      if(!iHasLimitFound)iSkipId=xc*yc*3;

      if(!iWasSum ){iSkipId=0;return 0;}
      /*
      FILE *f=fopen("zz.txt","wb");
      static int frcnt=0;
      for(int y=0;y<TVAL_DCT_SZ;y++){
         //haarzz[y]=0;
         fprintf(f,"%8d,",zigZagCreate[y]);
         if((y%8)==7)fprintf(f,"\n");
      }
      frcnt++;
      fprintf(f,"//frames=%d\n",frcnt);
      fclose(f);
      */
      //iLen+=setSkipLen(&img[iLen],iSk);
      iSkipValues+=setSkipLen(&skVal[iSkipValues],iSk);
      int t_zipIt(char* pData, int iDataLen, char *pOut);
      

//      int compress_coefs(int *v, int iCnt, unsigned char* buffer);
      //if(iSkipDct)
       //  iLen=s_encAritm(a_int,pOut,&img[0],iLen);
      //else
        // iLen=enc2UintValues(pOut,&img[0],iLen);//encAritmNH_S
      
     //
      if(iEncPicOnly)pFlag[0]|=0x40;
      if(iHasDifOnly)pFlag[0]|=0x80;
      iLen=s_encAritm(a_int,pData,&skVal[0],iSkipValues);
      if(!iHasDifOnly)// && !iIsKey)
         iLen+=s_encAritmUC(a_uc,pData+iLen , mbType ,iMbTypePos);
      int iVlcLen=vlc.getBytePos();
      memcpy(pData+iLen,vlc.pBitBuf,iVlcLen);
      iLen+=iVlcLen;

      //iLen+=encAritmUC(pData+iLen , mbType ,iMbTypePos);

      void tblock4x4(unsigned char *pic, int w, int h, int q);

      return iLen+6;
   }
   int iDecodedDCTs;

   static inline int setSkipLen(int *p, int iSk)
   {
      int v;
      int *pin=p;
      while(1)
      {
         v=iSk>1024?1024:iSk;
         *p=v;
         p++;
         if(v!=1024)break;
         iSk-=v;
      }
      return p-pin;
   }
   static inline int getSkipLen(int *p,int &iPos)
   {
      int v=0;//p[iPos];
      int iSk=0;
      while(1)
      {
         v=p[iPos];iPos++;
         iSk+=v;
         if(v!=1024)break;
      }
      return iSk;
   }
   int iDecodededLast,iLastSk,iYIsRestored;;
   int decode(unsigned char *pBin, int iLen, unsigned char *pCur){
     // return 0;
      int iVisDec=0;//*(int*)pCur==0xaa99aa99;
#if !defined(__SYMBIAN32__) && !defined(_WIN32_WCE) && !defined(ARM) && !defined(ANDROID_NDK) && !defined(__APPLE__)
      iVisDecoder=iVisDec=*(int*)pCur==0xaa99aa99;
      iSkipPutBlocks=*(int*)pCur==0xaa88aa99;
#endif
      iDecDct4x4=0;
      iDecodedDCTs=0;
      int iLenIn=iLen;
      if(iLen<=7)return 0;
      int iErrs=0;
      int w,h;

      //w=*(short*)(pBin+0);
      //h=*(short*)(pBin+2);
      w=pBin[0]+(pBin[1]<<8);
      h=pBin[2]+(pBin[3]<<8);

      if(!w || w>10000)return -8;
      if(!h || h>10000)return -9;
      int q=(((pBin[4]&0x1f)*4)+4);
      //q=50;
      //int iZiped=0;
      //if(q>100){iZiped=1;q-=100;}
      iIsB=0;
      iEncPicOnly=iIsKey=0;
      iHasDifOnly=0;
      if(pBin[4]&0x20)iIsB=1;
      if(pBin[4]&0x40)iEncPicOnly=iIsKey=1;
      if(pBin[4]&0x80)iHasDifOnly=1;

      int iProfile=pBin[5];
      if(iProfile>32)return 0;


      //debugss("fr",iIsB+(iEncPicOnly<<1)+(iHasDifOnly<<2),q);

//      if(iIsKey)return 0;
      //if(q>100){iIsB=1;q-=100;}
      int qIn=q;
      pBin+=6;
      iLen-=6;

      init(w,h,q,1);
      if(iProfile&2){
        // debugsi("dec-Len",iLen);
         //if(iVisDec)return 0;
         vlc.pBitBuf=(unsigned char *)&pBin[0];
         int fastT_dec(TDCTX *ed, unsigned char *pCur, unsigned char *pRef,int w, int h,int  iIsB);
         int ret=fastT_dec(this,pCur,NULL,w,h, iIsB);
         if(ret<0)debugsi("---------fastT_dec------------",ret);
         //if(ret<0)debugsi("fastT_dec",ret);
         return ret;
      }

      //debugss("fr2",iIsB+(iEncPicOnly<<1)+(iHasDifOnly<<2),q);
      int i,j,k,ofs;
      //T_ALIGN_32(DCT_TYPE,q_dct,64*2);
      //T_ALIGN_32(DCT_TYPE,q_quant,64*2);
      DCT_TYPE q_dct[128];
      DCT_TYPE q_quant[128];
      int id=0;
      int stride=w*3;
      int iSk=0;
      //if(!iVisDec)memset(pCur,128,w*h*3);

      //int t_unzipIt(char* pData, int iDataLen, char *pOut);
      //if(iZiped){iLen=t_unzipIt((char*)pBin,iLen,&bufTmp[0]);pBin=(unsigned char *)&bufTmp[0];}
      //--slikti --if(iZiped){iLen=t_unzipIt((char*)pBin,iLen,(char*)&img[0]);}


      int encAritmD(unsigned char *in , int *out ,int iCnt);
      int decompress_coefs(unsigned char *buffer, int buffer_size, int *out);
//      iLen=dec2UintValues((unsigned char *)&pBin[0],&img[0],0);//encAritmD
int encAritmDec(unsigned char *in , int *out ,int iMaxLen);
int encAritmGetValCnt(unsigned char *in );
int encAritmDUC(unsigned char *in , unsigned char *out ,int iMaxLen);

      
      int iBitsRead=s_encAritmDec(a_int,(unsigned char *)&pBin[0],&skVal[0],iLen);
      iSkipValues=encAritmGetValCnt((unsigned char *)&pBin[0]);
      if(iSkipValues>xc*yc*3)return -2;
      if(!iHasDifOnly /*&& !iIsKey*/)iBitsRead+=s_encAritmDUC(a_uc,(unsigned char *)&pBin[iBitsRead],mbType,iLen-iBitsRead);
      vlc.pBitBuf=(unsigned char *)&pBin[iBitsRead];
      if(iBitsRead>=iLen)return 0;

     // return 0;

      //iLen=encAritm(pData,&skVal[0],iSkipValues);
      //if(!iHasDifOnly && !iIsKey)
        // iLen+=encAritmUC(pData+iLen , mbType ,iMbTypePos);

     // memcpy(pData+iLen,vlc.pBitBuf,iVlcLen);
      //iLen+=iVlcLen;


      if(iLen==0)return 0;
     // iLen=decompress_coefs((unsigned char *)&pBin[0],iLen,&img[0]);
      int iPos=0;
      iSk=getSkipLen(&skVal[0],iPos);//iPos++;
      //int iFirstSk=iSk;

      int *tab_zx;
      int *tab_z;

      IMG_MB_DEC *mb=mbFirstDec;
      
      int iAdd,po;

      //int iMSk=0;
      //if(iSk<0)iMSk=-iSk;
      iCurBl=0;
      iBlStride=xc;
    //  if(iVisDec)return 0;
      int iCoefs;
      int iDecRet=0;
      if((iIsKey||iEncPicOnly) && (iSk==0 || iLastSk>iSk) && mbFirstDec){
         int to=xc*yc*3;
         for(i=0;i<to;i+=xc)mbFirstDec[i].iDecoded=0;
         iYIsRestored=0;
      }
      iDecodededLast=0;
//      if(iIsKey)debugss("key",iSk,0);
      //int iHasLast=0;

         for(k=0;k<3;k++)
         
         {
            iPrevCoefsCnt4x=iPrevCoefsCnt=0;
           // if(iIsKey && k==1 && iHasLast)decRestColor(pCur,stride,k-1);
            //iHasLast=0;
            //iDecodededLast=0;
           // if(k==1)break;
            int isY=k==0;
            tab_zx=isY?&tab_y[0]:&tab_uv[0];
      for(j=0;j<yc;j++){
         ofs=j*TVAL_24*w+k;
         iPredDC=0;
         //int iRowLost=!mb[-k*xc*yc].iDecoded;
         for(i=0;i<xc;i++,id++,ofs+=TVAL_24,iCurBl++,mb++){
         //ofs=i*24+j*24*w;
        // int iPredRet=0;
//         if(iVisDec && mb->iCoefsQuant<=-2 && iSk>0)fill_dc128(pCur+ofs-k+2,stride);
         
         
            //dcVal[id]=0;
            mb->dc_quantized=0;//q_quant[0];
            mb->iIsDif=1;
            mb->iSkip=1;

            if(0&&(iIsKey ||iEncPicOnly)&& k==0 && i && j ){
               int iFlag=MB_TOPLEFT;
               if(i+1!=xc )iFlag|=MB_TOPRIGHT;
               int b=vlc.getVlc();
               if(b>11)
                  b=11;//e
               fncPred[b](pCur+ofs+k,stride,iFlag);
               //mb->iDecoded=1;
            }
            if(iSk>0){iPrevCoefsCnt4x=iPrevCoefsCnt=0;mb->iCanUseAsPred=0;iPredDC=0;iSk--;continue;}
            mb->iCanUseAsPred=1;
            mb->iDecoded=1;
            //if(iVisDec)fill_dc128(pCur+ofs-k,stride);
          
            //iAdd=0;

            iDecRet=dec7x(&q_quant[0],k,iAdd,iCoefs);
            if(iDecRet<0){
               k=3;i=xc;j=yc;
               break;
            }
            
            //iPos+=ll;

            mb->iSkip=0;//iAdd==1?0:5;
            mb->iIsDif=iAdd==1;
            //if(iAdd==0){int dc=getPredDC(i,j,xc,mb,1,&img[iPos],iPos);q_quant[0]+=dc;}//&dcVal[id]);
       

            if(iAdd==0){
               po=0;
               int iWasQ=q_quant[0];
               q_quant[0]+=getPredDC(i,j,xc,mb,1,NULL,po);//q_quant[0]+=dc;
               if(iDecDct4x4&16){
                  int iWasQ16=q_quant[16];
                  int iWasQ32=q_quant[32];
                  int iWasQ48=q_quant[48];
                  
                  q_quant[16]+=q_quant[0];
                  q_quant[32]+=q_quant[0];
                  q_quant[48]+=q_quant[0];

                  //void t_idc2(DCT_TYPE *x);
                  //t_idc2(q_quant);

                  if(iWasQ16 && !q_quant[16])iCoefs--;
                  else if(!iWasQ16 && q_quant[16]){iCoefs++;iDecDct4x4|=2;}

                  if(iWasQ32 && !q_quant[32])iCoefs--;
                  else if(!iWasQ32 && q_quant[32]){iCoefs++;iDecDct4x4|=4;}

                  if(iWasQ48 && !q_quant[48])iCoefs--;
                  else if(!iWasQ48 && q_quant[48]){iCoefs++;iDecDct4x4|=8;}

                  if(iWasQ && !q_quant[0])iCoefs--;
                  else if(!iWasQ && q_quant[0]){iCoefs++;iDecDct4x4|=1;}
               }
               else{
                  if(iWasQ && !q_quant[0])iCoefs--;
                  else if(!iWasQ && q_quant[0]){iCoefs++;}
               }
               //else 
                 //if(iCoefs==0 && q_quant[0]==0)
                   // iAdd=2;

               
            }
            tab_z=tab_zx;
            if(iDecDct4x4)tab_z+=128;
            

            mb->dc_quantized=q_quant[0];
            
            iDecodedDCTs++;
          //  rem=iAdd!=1?1:0;
//if(rem && !k){iPredRet=img[iPos];iPos++; if(iPredRet<0 || iPredRet>11){iErrs++;j=yc;i=xc;break;}}
            //iPredRet=11;
            if(iVisDec)
            {
               
               int cc=iAdd==1?20:235;
               if(iDecDct4x4)cc=240;
               if(iDecDct4x4>=32)cc=160;
               //memset(&q_dct[0],cc,TVAL_DCT_SZ *sizeof(DCT_TYPE));
               for(int ccc=0;ccc<TVAL_DCT_SZ;ccc++)q_dct[ccc]=cc;
               int o=stride*8*(yc-j-1)+i*24; 
               //::fill
               copy_16_8(&q_dct[0],pCur+o+(iAdd==2?2:0),stride);
               if(iDecDct4x4){
                  if(iAdd!=1){
                    memset(&q_dct[16],128,8 *sizeof(DCT_TYPE));
                    memset(&q_dct[48],128,8 *sizeof(DCT_TYPE));
                  }
                  copy_16_8(&q_dct[0],pCur+o+(iAdd==2?0:2),stride);
               }
               //a_dif(&q_dct[0],pCur+ofs+1,stride);
            }
            else if(iAdd==0 && iCoefs==0)
            {
               mb->dc_quantized=0;
               //
               //void t_idct8_s_put(DCT_TYPE *t, unsigned char *dst, int stride);
               //if(iDecDct4x4)
                 // t_idct8_s_put(&q_quant[0],pCur+ofs,stride);
               //else 
                  fill_dc128(pCur+ofs,stride);
            }else{
               //if(iAdd==1 && k==0)
                 // predict_8x8_xdc(200,pCur+ofs,stride,0);
               //else 
               {
                //  iCoefs=64;
                  if(iAdd!=1)
                  {
                     
                     if(iDecDct4x4){
                        deQ<1,0>(&q_quant[0],&q_dct[0],tab_z,iCoefs,1);
                      //  x4idct_fnc_dc128(&q_dct[0],iCoefs);
                        void t_idct8_s_put(DCT_TYPE *t, unsigned char *dst, int stride);
                        t_idct8_s_put(&q_dct[0],pCur+ofs,stride);
                     }
                     else{ 
                        deQ<2,0>(&q_quant[0],&q_dct[0],tab_z,iCoefs,0);
                        idct_fnc_dc128(&q_dct[0],iCoefs);
                        copy_16_8(&q_dct[0],pCur+ofs,stride);
                     }
                     
                     
                     //der tik rgbif(k && iIsKey && iRowLost)copy_16_8_avg_lost_y(&q_dct[0],pCur-k+ofs,stride);
                     
                     
                  }
                  else if(1){
                     
                     //if(D_4x4==0 || !iIsY)

                     if(iDecDct4x4){
                        if(iDecDct4x4>=32){
                           //debugss("dec2x2",iCoefs,0);
                           deQ<0,1>(&q_quant[0],&q_dct[0],tab_z,iCoefs);
                           void t_idct_2x2_8_s_d(DCT_TYPE *d, unsigned char *dst, int stride,int iX );
                           t_idct_2x2_8_s_d(&q_dct[0],pCur+ofs,stride,iDecDct4x4);;
                           //debugss("dec2x2 ok",iCoefs,0);
                        }
                        else{
                           deQ<0,0>(&q_quant[0],&q_dct[0],tab_z,iCoefs,1);
                           void t_idct8_s(DCT_TYPE *t, unsigned char *dst, int stride, int iX);
                           t_idct8_s(&q_dct[0],pCur+ofs,stride,iDecDct4x4);
                        }
                     }
                     else {
                        //idct_fnc(&q_dct[0],iCoefs);  
//                        a_dif(&q_dct[0],pCur+ofs,stride);
                        deQ<0,0>(&q_quant[0],&q_dct[0],tab_z,iCoefs);
//                        void t_idct_int32_s(short *const block, unsigned char *dst, int stride);
                        t_idct_int32_s(&q_dct[0],pCur+ofs,stride);
                     }
                     //a_dif(&q_quant[0],pCur+ofs,stride);
                  }

               
               }
            }

           //if(iIsKey)filter(pCur+ofs,stride,j==0,i==0,k);
           // if(iMSk<=0){
            //   iSk=getSkipLen(&img[0],iPos);
           // if(iPos+4>iSkipValues){
              // iErrs=0;
            //}
            if(j+1==yc && iIsKey)iDecodededLast=k+1;
            iLastSk=k*xc*yc;
            iSk=getSkipLen(&skVal[0],iPos);;//iPos++;
            
            if(iSk<0){iErrs+=100;j=yc;i=xc;k=10;break;}
               //if(iSk<0)iMSk=-iSk;else iMSk=0;
            //}else iMSk--;
            
         }
         
         }
         //iHasLast=1;
         //if(iIsKey && k==0)
         
      }
      if(iDecRet<0){
         debugss("iDecRet len err",iDecRet,iErrs);return -1;
      }
      if(iIsKey && !iYIsRestored && iLastSk>=xc*yc){decRestColor(pCur,stride,0);iYIsRestored=1;}
      else if(iDecodededLast==3 && iIsKey)decRestColor(pCur,stride,1);
      
//      void tblock4x4(unsigned char *pic, int w, int h, int q);
      //tblock4x4(pCur,w,h,qIn);
//        int a,b;
  //    getAlphaBetaValues(qIn,a,b);
  //    void tblock(unsigned char *pic, int w, int h, int a, int b);
//      tblock(pCur,w,h,a,b);

      if(iBitsRead+vlc.getBytePos()+6!=iLenIn || iErrs){debugss("d len err",iLenIn-iBitsRead-vlc.getBytePos()-6,iErrs);return -1;}
      

      return 0;
   }
   void decRestColor(unsigned char *pCur,int stride, int col){
      int i;
         //if(iIsKey)
         {
            int to=xc*yc;
            int iLostFrom;
            int iLostTo;
            int iRow=0;
//            int z;
            int k=col?1:0;
            int tok=col?3:1;

            for(k=0;k<tok;k++)
            {
               IMG_MB_DEC *mbT=mbFirstDec+k*xc*yc;
               iRow=0;
               iLostFrom=-1;
               iLostTo=-1;
               for(i=0;i<to;i+=xc,iRow++){
                  if(mbT[i].iDecoded==0){
                     if(iLostFrom==-1){
                        iLostFrom=iRow;
                        iLostTo=iRow+1;
                     }
                     else iLostTo=iRow+1;
                  }
                  else if(iLostFrom!=-1 && mbT[i].iDecoded){
                     decLost(pCur+k,stride,iLostFrom,iLostTo);
                     iLostFrom=-1;
                     iLostTo=-1;
                  }
                  //mbT[i].iDecoded=1;
               }
               if(iLostFrom!=-1)decLost(pCur+k,stride,iLostFrom,iLostTo);
            }
         }
   }
   void decLost(unsigned char *pCur,int stride,int iLostFrom, int iLostTo){
      int j,z;
      int losth=(iLostTo-iLostFrom)*8;

      if(losth<=0)return ;
      
      unsigned char *row_s=pCur;
      unsigned char *row_e=pCur+(iLostTo)*8*stride;
      unsigned char *pLFrom=pCur+iLostFrom*8*stride;

      if(iLostFrom==0){
         row_s=row_e;
      }
      else row_s+=((iLostFrom*8)-1)*stride;
//      int sh=0;
      int mult=((1<<14)/losth+1);

      //TODO sh div tbl


      for(z=0;z<losth;z++){
         const int losthz=losth-z;
        for(j=0;j<stride;j+=3){
           int dres=((row_e[j]*z+row_s[j]*(losthz))*mult)>>14;
          pLFrom[j]=dres;
        }
        pLFrom+=stride;
      }
   }
   static void decY2x(unsigned char *in, unsigned char *out, int w, int h){
      int i,j;
      int str=w*3;
      for(j=0;j<h;j+=2){

         for(i=0;i<w;i+=2){
            const int r=(in[0]+in[3]+in[0+str]+in[3+str]+2)>>2;
            in+=6;
            out[0]=r;
            out+=3;
         }
         in+=str;
      }

   }
   int predKey(unsigned char *pCur, unsigned char *pRef, int w, int h, unsigned char *pOut, int q){
      static int ret;
      ret=!ret;
      if(ret){return 0;}
      void decSizeXTimes(int cx, int cy, int iTimes, unsigned char *pIn, unsigned char *pOut);
      void incSize2x(unsigned char *in, unsigned char *out, int cx, int cy);
      static unsigned char *p=new unsigned char [1024*1024*2];
      decSizeXTimes(w,h,2,pRef,p);
      //decY2x(pRef,p,w,h);

      iIsKey=0;
      iEncPicOnly=1;

      unsigned char *po=p+w*h*3/2;
      int l=0;
      int r;
      iSkipUVFilter=1;
      iSkUV=0;
      do{
        r=encode(po,p,w/2,h/2,(q*2+96*2)>>2,pOut+l,0);
        if(r<=0)break;
        l+=r;
      }while(1);
      iEncPicOnly=0;
      iSkipUVFilter=0;
      iIsKey=0;

      if(q<24){
        void filter_x_pic(unsigned char *p ,int w, int h, int stride);
        //filter_x_pic(po,w/2,h/2,w*3/2);
      }
      
//      unsigned char *p2=p+w*h*3;

      //incSize2x(po,p2,w/4,h/4);
      void incSize2xY(unsigned char *in, unsigned char *out, int cx, int cy);
      //incSize2x(po,pCur,w/2,h/2);

      iIsB=0;
      iSkipRestore=0;
      
      iEnc4x4Only=2;
      iSkUV=1;
      iKeyYLen=l*6;
      do{
        r=encTest(pCur,pRef,w,h,q,pOut+l,3000);
        if(r<=0)break;
        l+=r;
      }while(1);
      iSkUV=0;
      iSkipRestore=0;
      iEnc4x4Only=0;

      //dctx->iEncPicOnly=1;
      return l;

   }
   int encF(unsigned char *pCur, unsigned char *pRef, int w, int h, int q, unsigned char *pOut){
      if(iSkipId && (iSkipId==xc*yc*3 || iSkipId==-1) && w==this->iW && h==this->iH){
         iSkipId=0;
         return 0;
      }//or w!h

      init(w,h,q);
//      initMem(w,h);
      int ret=0;
#ifndef _TEST_T_BITS
      ret+=6;
      pOut+=saveHdr(pOut,w,h,q);
      pFlag[1]=2;
#endif
      vlc.reset();
      vlc.iCalcBitsOnly=0;
      int fastT_enc(TDCTX *ed, unsigned char *pCur, unsigned char *pRef,int w, int h,int  iIsB);
//      iSkipId=(h>>3)*(w>>3)*3;
      vlc.pBitBuf=pOut;
      ret+=fastT_enc(this,pCur,pRef,w,h, iIsB);
      if(!ret){iSkipId=0;return 0;}
      return ret;

   }
};
TDCTX *dctx=NULL;
TDCTX *dctDec=NULL;

int testVlcLensX(int val){
   if(dctx==NULL)dctx=new TDCTX();
   //dctx->vlc.iCalcBitsOnly=1;
   int r=dctx->vlc.bitsLen[val<0?((-val)<<1)-1:val<<1];

   return r;
}
int testVlcLensUnsigned(int iReset, int val){
   if(dctx==NULL)dctx=new TDCTX();
   dctx->vlc.iCalcBitsOnly=1;
   if(iReset){int ret=dctx->vlc.iBitPos;dctx->vlc.reset();return ret;}
   unsigned char buf[8];

    //dctx->vlc.toAC_val(&buf[0],val<0?((-val)<<1)-1:val<<1);
     dctx->vlc.toAC_val(&buf[0],val);

   return dctx->vlc.iBitPos;
}
int testVlcLens(int iReset, int val)
{
   if(dctx==NULL)dctx=new TDCTX();
   dctx->vlc.iCalcBitsOnly=1;
   if(iReset){int ret=dctx->vlc.iBitPos;dctx->vlc.reset();return ret;}
   unsigned char buf[8];

    dctx->vlc.toAC_valSM(&buf[0],val);
    //dctx->vlc.toAC_valSigned(&buf[0],val);

   return dctx->vlc.iBitPos;
}

void f_31_C(unsigned char *Src1, unsigned char *Src2, const int BpS, int Nb_Blks)
{
  Nb_Blks *= 8;
  while(Nb_Blks-->0) {
    unsigned char a = ( 3*Src1[0] + 1*Src2[0] + 2 ) >> 2;
    unsigned char b = ( 1*Src1[0] + 3*Src2[0] + 2 ) >> 2;
    *Src1 = a;
    *Src2 = b;
    Src1 += BpS;
    Src2 += BpS;
  }
}
void filterUV(unsigned char *p, int wi, int hi){   
//   int i,j;
   int l=wi*hi>>4;

   f_31_C(p+1,p+4,6,l);
   f_31_C(p+2,p+5,6,l);

   /*
   for(i=0;i<wi-1;i++)
   {
      //f_31_C(p+i*3,p+i*3+wi*3,wi*3,hi>>3);
      p++;
      f_31_C(p+i*3,p+i*3+wi*3,wi*3,hi>>3);p++;
      f_31_C(p+i*3,p+i*3+wi*3,wi*3,hi>>3);p++;
      p-=3;
   }
   */
   for(int i=0;i<hi;i++)
   {
      //f_31_C(p+i*wi*3,p+i*wi*3+3,3,(wi>>3)-1);
      p++;
      f_31_C(p+i*wi*3,p+i*wi*3+3,6,(wi>>4)-1);p++;
      f_31_C(p+i*wi*3,p+i*wi*3+3,6,(wi>>4)-1);p++;
      p-=3;
   }
   
}

//int decodeDctX2(unsigned char *pBin, int iLen, unsigned char *pCur){return 0;}
static int iTestFilter=0;

int decodeDctX2(unsigned char *pBin, int iLen, unsigned char *pCur, int iIsB)
{
   //return 0;
   //debugss("dec1",iLen,0);
   //return 1;
   if(dctDec==NULL)dctDec=new TDCTX();
#if 0
   //!defined(_WIN32_WCE) && !defined(__SYMBIAN32__)

   if(dctDec->iIsKey){
      FILE *f=fopen("testfilter","r");
//debugss("key",0,0);
      iTestFilter=f?1:0;
      if(f)fclose(f);
   }
   //iTestFilter=1;
#endif
   if(dctDec==NULL){
      memcpy(pCur,pBin,iLen);
      return 0;
   }
  // return 0;
   dctDec->iThisWasB=iIsB;


   int iIsVis=1;

/*
   if(iLen>1){
      unsigned char r=5;
      int zz;
      for(zz=0;zz<iLen-1;zz++)r+=pBin[zz];
      if(pBin[zz]==r){
         iLen--;
      }
      else 
         iLen=0;

   }
*/
   iIsVis=0;
   /*
   if(iLen>5 && *(int*)pCur!=0xaa99aa99){
      //filterUV(pCur,*(short*)pBin, *(short*)&pBin[2]);
      iIsVis=0;
   }
   */
   //if(iIsVis)return 0;
//repk:
   int l=dctDec->decode(pBin,iLen,pCur);
  // pBin+=dctDec->vlc.getBytePos();iLen-=dctDec->vlc.getBytePos();
  // if(l==0 && dctDec->iIsKey && iLen>10){goto repk;}
   if(0 && dctDec->iIsKey){
      void incSize2x(unsigned char *in, unsigned char *out, int cx, int cy);
      unsigned char *tmp=new unsigned char [dctDec->xc*8*dctDec->yc*8*3];
      memcpy(tmp,pCur,dctDec->xc*8*dctDec->yc*8*3);
//      incSize2x(tmp,pCur,dctDec->xc*8,dctDec->yc*8);
      delete tmp;
      //
      //dctDec->decode(pBin+dctDec->vlc.getBytePos(),iLen,pCur);
      l=0;
   }
   if(iLen>6 && !dctDec->iVisDecoder){
         ::iBitGainXNZ+=8*(6);
      
   }
   /*
   if(dctDec->iIsKey && dctDec->iDecodededLast
      ){
       unsigned char *tmp=new unsigned char [dctDec->iW*dctDec->iH*3];
       memcpy(tmp,pCur,dctDec->iW*dctDec->iH*3);

       void incSize2x(unsigned char *in, unsigned char *out, int cx, int cy);
       incSize2x(tmp,pCur,dctDec->iW,dctDec->iH);
       delete tmp;
   }
   */

/*  
   if(!iIsVis && l==0){
   int w=dctDec->iW;
   int h=dctDec->iH;
   int stride=w*3;
   memcpy(pCur-stride,pCur,stride);
   memcpy(pCur+w*h*3,pCur+w*(h-1)*3,stride);
   }
   */
   //debugss("dec1",iLen,l+100);
   return l;
}

#define ABS(_a) ((_a)<0?-(_a):(_a)) 

static int iGain=0;
int t_hGain(){
         static int iPrevGX[4];
         int r=((iBitGainX1-iPrevGX[1])+(iBitGainXNZ-iPrevGX[2])+(iBitGainX-iPrevGX[0])+(iBitGainX1sc-iPrevGX[3]))>>3;
         
         if(iBitGainX1sc!=iPrevGX[3]){
            debugsi("g-len-Byte-GainFrame",(iBitGainX1sc-iPrevGX[3]+4)>>3);
            debugsi("g-len-Byte-GainTotal",iBitGainX1sc>>3);
         }
         iPrevGX[0]=iBitGainX;
         iPrevGX[1]=iBitGainX1;
         iPrevGX[2]=iBitGainXNZ;
         iPrevGX[3]=iBitGainX1sc;
         
         //debugsi("g-len-r",r);
         /*

if(iSc[4]){
      debugsi("sc0",iSc[0]);
      debugsi("sc1",iSc[1]);
      debugsi("sc2",iSc[2]);
      debugsi("sc3",iSc[3]);
      debugsi("scAvg",(iSc[0]+iSc[3]+iSc[2]+iSc[1])*100/(iSc[4]+1));
      debugsi("scBits",iSc[5]);
}
*/

   int v=iGain;
   iGain=0;
   return r;//+8;
   //return v?v+75:32;
}
void rangeEncode(int* source, int source_size, unsigned char* result, int& result_size);
int getBlockPSNR_SQ(unsigned char *p ,unsigned char *o, int w, int h, int stride, int step, int &iDif);
int getBlockPSNR_UV_SQ(unsigned char *p ,unsigned char *o, int w, int h, int stride, int step, int &iDif);
#ifndef __SYMBIAN32__
extern "C" {
float get_ssim(unsigned char *cur, unsigned char *ref, int stride, int k);
};
#else
float get_ssim(unsigned char *cur, unsigned char *ref, int stride, int k){return 0.7f;}
#endif


static int analize(unsigned char *cur, unsigned char *ref, int stride, int k,int iIsB, const int *t){
   /*
//dc,psnr,sqerr
   T_ALIGN_64(unsigned char,c,64*3);
   T_ALIGN_64(unsigned char,r,64*3);
   T_ALIGN_64(DCT_TYPE,bl,64);
   T_ALIGN_64(DCT_TYPE,bld,64);
   int i,j,pos=0;
   for(j=0;j<16;j+=2){
      for(i=0;i<48;i+=6){
         int p1=(i+j*stride);
         int p2=p1+3;
         int p3=p1+stride;
         int p4=p3+3;
         c[pos]=(cur[p1]+cur[p2]+cur[p3]+cur[p4]+2)>>2;
         r[pos]=(ref[p1]+ref[p2]+ref[p3]+ref[p4]+2)>>2;
         pos+=3;
      }
   }
   int iSQErrStart;
   void t_fdct8_s_d(unsigned char *src,unsigned char *src2, int stride, DCT_TYPE *d );
   int psnr=getBlockPSNR_SQ(c,r,8,8,24,3,iSQErrStart);
   if(psnr<2200)return iIsB?1:7;
   if(psnr>4700)return 0;

   t_fdct8_s_d(c,r,24,bl);

   int res=TDCTX::QFast<0>(bld,bl,t,64,iIsB,0,0);
if(iIsB && !(bld[0]|bld[16]|bld[32]|bld[48]))return 0;

if(res>iIsB+1)return 1;
*/
   return 0;
}

static int calcUVDC(unsigned char *cur, unsigned char *ref, int stride){
   int i,j,dc=0;
   for(j=0;j<16;j++){
      for(i=0;i<48;i+=3){
         dc+=(cur[i]-ref[i]);
      }
      if(((j&3)==3)){
         if(((mmabs(dc)))>8*16*(j+1))return ((dc*16/(j+1))+128)>>8; 
      }
      cur+=stride;ref+=stride;
   }

   return (dc+128)>>8;
}


typedef struct{
   int i,j;
   int w,h;
   int m;
   int iIsHada;
   int iIsPic;
   int iWorstPsnr[3];
   int iThisWorstPsnr[3];
   int iLastBlockPsnr;
   int iUVSad;
   int iUVSadSQ;
   int iUVPsnr;
   int iDCDifAbs;
   int iDCDif;
   int iHasUVMode;
   int iUseDct8x8;
   int iBlocksEnc16;
   int iDCQ;
   int iMeanUV;
   int iPrevDCCnt;
   MB16_2 *mb;
}ENC_BL_CTX;

template< int iPic>
static int getDCQuant4x4(TDCTX *ed, int k, int iIsB){
   const int *t=k?&ed->tab_uv[128]:&ed->tab_y[128];
   int iDCQ;
   if(iPic){
      iDCQ=(t[0]*3+ed->iDCQuant)>>2;//(t[0]*4+ed->iDCQuant+4)>>2;
      //iDCQ=((t[0]*2+ed->iDCQuant+8))>>1;
      if(iDCQ>512){iDCQ+=512;iDCQ>>=1;}
      else if(iDCQ<8){iDCQ+=8;iDCQ>>=1;}
   }
   else{
    //  iDCQ=((t[0]*4+ed->iDCQuant*2+16))>>1;
      iDCQ=(t[0]*4+ed->iDCQuant+8)>>2;//(t[0]+16)>>1;
      if(iDCQ>1024){iDCQ+=1024;iDCQ>>=1;}
      else if(iDCQ<16){iDCQ+=16;iDCQ>>=1;}
      
   }
 
   if(k)iDCQ+=64;
   
   if(ed->iIsB)iDCQ+=128;
   //if(k)iDCQ=t[0];
   iDCQ++;iDCQ&=~1;
#ifdef _TEST_T_BITS
   //if(iPic && !ed->iIsKey){iDCQ=(t[0]+2)>>1;iDCQ<<=3;}
   //if(iPic && !ed->iIsKey){iDCQ=(t[0]*6+9)>>4;iDCQ<<=3;}
#define SET_DCQ 
   //iDCQ=(t[0]*2)+(!!ed->iIsB)*16;
   SET_DCQ
   iDCQ=k?ed->iDCQuantUV:ed->iDCQuant;
   //if(iPic && !ed->iIsKey){iDCQ*=3;iDCQ>>=1;iDCQ|=3;iDCQ&=~3;}//iDCQ=t[0]*4;}
   if(iPic && !ed->iIsKey){iDCQ*=5;iDCQ>>=2;iDCQ|=7;iDCQ&=~7;}
   //if(iPic && !ed->iIsKey){iDCQ*=2;}
   //??if(k)iDCQ=ed->tab_y[128]*2;
#endif

   //iDCQ+=3;iDCQ&=~3;
   return iDCQ;
}
//#define T_encMB16_DCTd24x4_UV

static int tryEncDCOnly(int iDif, ENC_BL_CTX *ctx, TDCTX *ed, unsigned char *pCur, unsigned char *pRef, int stride,int k, int iIsB){
#ifdef T_encMB16_DCTd24x4_UV

   return 1;
#endif
   ctx->iPrevDCCnt=1;
   int iDCQ=getDCQuant4x4<0>(ed,k,iIsB);;
   //int iDif=(iDC-iDCCur)*2;
   int val;
   /*
   iDif*=2;
   if(iDif<0)
      val=-((-iDif+(iDCQ>>2))/iDCQ);
   else 
      val=(iDif+(iDCQ>>2))/iDCQ;
   DCT_TYPE dc=(val*iDCQ+4)>>3;
*/
   iDif*=4;
   int iDCQ2=iDCQ*2;
//102000 66KB
   DCT_TYPE dc;
   int iDQ=iDCQ>>2;
   if(iDif<0){
      val=((-iDif+(iDCQ-1))/iDCQ2);
      
      dc=(val*iDQ+1)>>1;
      dc=-dc;val=-val;
   }else{ 
      val=(iDif+(iDCQ-1))/iDCQ2;
      dc=(val*iDQ+1)>>1;
      //val/16/8*16
   }
   /*
   void idct4x4dc_s( int *d);
   int bl[]={
      val*iDCQ,0,0,0,
      0,0,0,0,
      0,0,0,0,
      0,0,0,0,
   };
   idct4x4dc_s(&bl[0]);
   dc=bl[0];
*/
   //DCT_TYPE dc=(val*iDCQ+8)>>4;
//256/16
    //int iLimDC=iDCQ>>2;//----(ed->tab_y[128]/4+(iDCQ>>4))>>1;//
   int iLimDC=(ed->tab_y[128]/4+(iDCQ>>3)+64)>>2;//
   //int iLimDC=(ed->tab_y[128]/2+(iDCQ>>4))>>1;
   if(iLimDC>(ed->tab_uv[128]>>2))iLimDC=(ed->tab_uv[128]>>2);
   if(iLimDC<12)iLimDC=12;// || (val>1 || val<-1)
   if(iIsB || ed->iThisWasB || ed->iThisWasBX)iLimDC+=16;
   //int dc16=dc&15;if(dc16>14 || dc16<2)iLim=0;

   //#define T_FIX_DC(_D,_Q) if(_D<0)_D-=(8);else if(_D>0)_D+=(8);

#define UV_DC_DEF 10
   if(val && 
      (dc>iLimDC || dc<-iLimDC)){
      if(ctx->iUseDct8x8==2)ed->vlc.addB(0);
      ed->vlc.toDC(UV_DC_DEF-1);
      //if(val==2){val=1;}else if(val==-2){val=-1;}
      ed->vlc.toL_Val_S(val,2);
      ed->vlc.addXBits(0,4);
      /*
      ed->vlc.addB(0);
      ed->vlc.addB(0);
      ed->vlc.addB(0);
      ed->vlc.addB(0);
      */
      //debugss("dc",dc,iSad);

      if(!iIsB){
        // T_FIX_DC(dc,iDCQ);
         void addDC16x16(DCT_TYPE dc_c, unsigned char *dstp, int stride);
         addDC16x16(dc,pCur,stride);
      }
      return 4;
   }
   return 0;
}
#if 1
template  <int iDec, int iPic>
int encMB16_DCTd2_UV(ENC_BL_CTX *ctx, TDCTX *ed, unsigned char *pCur, unsigned char *pRef, int stride,int k,int  iIsB, int i_CanRestore,int &iIsBigCost, int iBestBits=0)
{
   int i,j;
   const int *t=1?&ed->tab_uv[0]:&ed->tab_y[0];
   int t0=16;//(t[0]+8)>>1;
   //if(ed->iIsB || iIsB){t0*=3;t0>>=1;}
   //else if(iPic){t0*=3;t0>>=2;t0+=2;}
   int iBitPos=ed->vlc.iBitPos;
   t0=//((getDCQuant4x4<iPic>(ed,k,iIsB)*8)>>7)+1;//
   (ed->tab_y[129]*2>>3)+1;
   //int t0_0Mult=t0*3/16;
   //if(t0_0Mult<1)t0_0Mult=1;
   DCT_TYPE dct[64];
   DCT_TYPE q_dct[64];
   ed->iPrevCoefsCnt=0;
   if(!iDec){
      int iBitPos=ed->vlc.iBitPos;

      int pos=0;
      for(j=0;j<16;j+=2){
         for(i=0;i<48;i+=6){
            const int p1=(i+j*stride);
            const int p2=p1+3;
            const int p3=p1+stride;
            const int p4=p3+3;
            if(iPic){
               dct[pos]=((DCT_TYPE)pRef[p1]+(DCT_TYPE)pRef[p2]+(DCT_TYPE)pRef[p3]+(DCT_TYPE)pRef[p4]);
            }
            else{
               dct[pos]=((DCT_TYPE)pRef[p1]+(DCT_TYPE)pRef[p2]+(DCT_TYPE)pRef[p3]+(DCT_TYPE)pRef[p4])
                       -((DCT_TYPE)pCur[p1]+(DCT_TYPE)pCur[p2]+(DCT_TYPE)pCur[p3]+(DCT_TYPE)pCur[p4]);//+2)>>2;
            }
            //dct[pos]+=2;dct[pos]>>=2;
            pos++;
         }
      }
      dct_fnc(&dct[0]);
      if(iPic){dct[0]*=2;}
      int s=0;
#if 0
      
      //s=ed->QTest<iPic>(&dct[0],t,iIsB,k);
      ///if(!iPic && !s)return 0;
      for(i=0;i<64;i++)dct[i]=(dct[i]+2)>>2;
      s=ed->QFast<iPic>(&q_dct[0],&dct[0],t,64,0,0,0);
      if(!iPic && s<2)return 0;
#else 
      int td0=iPic?(t0/3+1):((t0+2)/6);//(iPic?3:3);
      int iLim=iPic?(t0-td0):t0;
      if(iIsB)iLim+=td0;

      for(i=0;i<64;i++){
         if(dct[i]<=-iLim)
            q_dct[i]=-((-dct[i]+td0)/t0);
         else if(dct[i]>=iLim)
            q_dct[i]=(dct[i]+td0)/t0;
         else {q_dct[i]=0;continue;}
         if(q_dct[i])s++;
      }
      if(!iPic && !s)return 0;
#endif
      if(i_CanRestore==5)return 1;
      

      if(iPic){
         ed->vlc.toDC(q_dct[0]-ed->iPredDC);
      }
      else{
         ed->vlc.toDC(q_dct[0]);
      }
      ed->enc7xNoDC(&q_dct[0],k);
      if(iPic && iBestBits>0 && iBestBits<ed->vlc.iBitPos-iBitPos) //   ?????
         return 0;

      if(iPic)ed->iPredDC=q_dct[0];

   }
   else{
      if(iPic){
         q_dct[0]=ed->vlc.getDC()+ed->iPredDC;
         ed->iPredDC=q_dct[0];
      }
      else{
         q_dct[0]=ed->vlc.getDC();
      }
      int iCoefs;
      if(ed->dec7xNoDC(&q_dct[0],k,iCoefs)<0)return -1;

   }
   //t0>>=2;
#if 1
   if(iPic){
      dct[0]=(q_dct[0]*t0+4)>>3;//16;
      for(i=1;i<64;i++)dct[i]=(q_dct[i]*t0+2)>>2;//16;
   }
   else{
      const int iDCAdd=((t0+2)/4)-((t0+3)/6);
      for(i=0;i<64;i++){
         if(!q_dct[i]){dct[i]=0;continue;}
         if(q_dct[i]<0){
            dct[i]=-((3-q_dct[i]*t0)>>2);
            //dct[i]=q_dct[i]*t0-iDCAdd;//16;
         }
         else{
            dct[i]=((q_dct[i]*t0+3)>>2);
          //  dct[i]=q_dct[i]*t0+iDCAdd;//16;
         }

         //dct[i]+=2;dct[i]>>=2;
      }
   }
#else
   ed->deQ<iPic,0>(&q_dct[0],&dct[0],t);//,iCoefsOut);//,64,0);
#endif
  // if(iPic)dct[0]=(dct[0]+1)>>1;
   idct_fnc(&dct[0]);
   {
      unsigned char *cr=::getCropTbl();
      int pos=0;
      for(j=0;j<16;j+=2){
         for(i=0;i<48;i+=6){
            const int p1=(i+j*stride);
            const int p2=p1+3;
            const int p3=p1+stride;
            const int p4=p3+3;
            //dct[pos]+=2;dct[pos]>>=2;
            if(iPic){
               pCur[p1]=pCur[p2]=pCur[p3]=pCur[p4]=cr[dct[pos]];
            }
            else{
               
            
//            dct[pos]>>=2;
               pCur[p1]=cr[pCur[p1]+dct[pos]];
               pCur[p2]=cr[pCur[p2]+dct[pos]];
               pCur[p3]=cr[pCur[p3]+dct[pos]];
               pCur[p4]=cr[pCur[p4]+dct[pos]];
            }
            pos++;
         }
      }

   }
//if(iDec)debugss("bits-UY-8x8x2",ed->vlc.iBitPos-iBitPos,iPic);

   return  1;
}
template  <int iDec, int iPic>
int encMB16_DCTd24x4_UV(ENC_BL_CTX *ctx, TDCTX *ed, unsigned char *pCur, unsigned char *pRef, int stride,int k,int  iIsB, int i_CanRestore,int &iIsBigCost, int iBestBits=0)
{
   int i,j;
   const int *t=&ed->tab_y[128];
  // if(ed->iIsB || iIsB || ed->iThisWasB){return 0;}
   //else if(iPic){t0*=3;t0>>=2;t0+=2;}
   int iBitPos=ed->vlc.iBitPos;
   DCT_TYPE dctX[64];
   DCT_TYPE dct[64];
   DCT_TYPE q_dct[64];
   int dctDC[4];
   int r01,r02,r03,r04;
   int t0=(t[0]>>1)*4;
//   unsigned char ref[64];
  // unsigned char cur[64];
   ed->iPrevCoefsCnt=0;
   int iDecFlags=0;
   const static int tz[]={
      0,1,2,3,  16,17,18,19,
      4,5,6,7,  20,21,22,23,
      8,9,10,11, 24,25,26,27,
      12,13,14,15, 28,29,30,31,
     32,33,34,35,  48,49,50,51,
     36,37,38,39, 52,53,54,55,
     40,41,42,43, 56,57,58,59,
     44,45,46,47, 60,61,62,63,
   
   };
   if(!iDec){
      int iSum=0;
      int iBitPos=ed->vlc.iBitPos;

      int pos=0;
      for(j=0;j<16;j+=2){
         for(i=0;i<48;i+=6){
            const int p1=(i+j*stride);
            const int p2=p1+3;
            const int p3=p1+stride;
            const int p4=p3+3;
            if(iPic){
               dctX[pos]=((unsigned char)pRef[p1]+(unsigned char)pRef[p2]+(unsigned char)pRef[p3]+(unsigned char)pRef[p4]+2)>>2;
               dctX[pos]-=128;
            }
            else{
               dctX[pos]=(((unsigned char)pRef[p1]+(unsigned char)pRef[p2]+(unsigned char)pRef[p3]+(unsigned char)pRef[p4])
                        -((unsigned char)pCur[p1]+(unsigned char)pCur[p2]+(unsigned char)pCur[p3]+(unsigned char)pCur[p4])+2)>>2;
            }
            //dct[pos]+=2;dct[pos]>>=2;
            pos++;
         }
      }
      //void t_fdct8_s_d(unsigned char *src,unsigned char *src2, int stride, DCT_TYPE *d );;
      //void t_fdct8_s(unsigned char *src, int stride, DCT_TYPE *d );;
      void trxF(short *p);
      for(i=0;i<64;i++)dct[tz[i]]=dctX[i];


      trxF(&dct[0]);
      trxF(&dct[16]);
      trxF(&dct[32]);
      trxF(&dct[48]);

      r01=dct[0];dct[0]=0;
      r02=dct[16];dct[16]=0;
      r03=dct[32];dct[32]=0;
      r04=dct[48];dct[48]=0;

      dctDC[0] = (+ r01 + r02 + r03 + r04) ;
      dctDC[1] = (- r01 + r02 - r03 + r04) ;
      dctDC[2] = (- r01 - r02 + r03 + r04) ;
      dctDC[3] = (+ r01 - r02 - r03 + r04) ;


      int dcs=0;
      for(i=0;i<4;i++){
         if(dctDC[i]<0)dctDC[i]=-(((t0>>1)-dctDC[i])/t0);
         else if(dctDC[i]>0)dctDC[i]=(((t0>>1)+dctDC[i])/t0);
         else continue;
         if(dctDC[i]){dcs++;iSum+=mmabs(dctDC[i]);}
      }
      if((iIsB|ed->iThisWasB) && !dcs)return 0;
      int s=ed->QTestN<iPic>(&dct[0],iIsB,k);

      if(!dcs && !s && !iPic)return 0;
      if(s){
         s=ed->QFast<iPic>(&q_dct[0],&dct[0],t,64,iIsB,k,iIsB);
         if(!dcs && !s && !iPic)return 0;
         iSum+=s;//(s<<1);
      }
      if(!iPic && iSum<2)return 0;
      memset(dct,0,sizeof(dct));
      

      ed->vlc.toDC(iPic?(dctDC[0]-ed->iPredDC):dctDC[0]);
      if(dctDC[0])dcs--;
      ed->vlc.toVLC(dcs);
      for(i=1;i<4 && dcs>0;i++){ed->vlc.toAC(dctDC[i]);if(dctDC[i])dcs--;}

      if(s){
         ed->vlc.addB(1);
         ed->enc4x_15(&q_dct[0],0,k,!iPic);
         iDecFlags=ed->iDecDct4x4;
         ed->deQ4x4_Flag<iPic>(&q_dct[0],&dct[0],t,iDecFlags);

      }
      else{
         ed->vlc.addB(0);
         
      }
      if(iPic && iBestBits>0 && iBestBits+10<ed->vlc.iBitPos-iBitPos) //   ?????
         return 0;

      if(iPic)ed->iPredDC=dctDC[0];

      
   }
   else{
      memset(q_dct,0,sizeof(q_dct));
      memset(dct,0,sizeof(dct));
      int iAdd=0,iCoefs=0;
      dctDC[1]=dctDC[2]=dctDC[3]=0;

      dctDC[0]=ed->vlc.getDC();
      if(iPic){dctDC[0]+=ed->iPredDC;ed->iPredDC=dctDC[0];}

      int dcs=ed->vlc.getVlc();
      for(i=1;i<4 && dcs>0;i++){dctDC[i]=ed->vlc.getAC();if(dctDC[i])dcs--;}
      
      if(ed->vlc.getB()){
                  if(iPic){
                     int ret=ed->dec4x_15<2>(&dct[0],k,&t[0]);if(ret<0)return ret;
                  }
                  else{
                     int ret=ed->dec4x_15<1>(&dct[0],k,&t[0]);if(ret<0)return ret;
                  }

//         int ret=ed->dec4x_15<0>(&q_dct[0],k);if(ret<0)return ret;
         iDecFlags=ed->iDecDct4x4;
  //       ed->deQ4x4_Flag<iPic>(&q_dct[0],&dct[0],t,iDecFlags);
      }


   }

 
      int tm=t[0]>>1;
      for(i=0;i<4;i++)dctDC[i]*=tm;

      r01=dctDC[0];
      r02=dctDC[1];
      r03=dctDC[2];
      r04=dctDC[3];

       dct[0] = (r01 - r02 - r03 + r04);
      dct[16] = (r01 + r02 - r03 - r04);
      dct[32] = (r01 - r02 + r03 - r04);
      dct[48] = (r01 + r02 + r03 + r04);
   
   void itrxF(short *p);
   itrxF(&dct[0]);
   itrxF(&dct[16]);
   itrxF(&dct[32]);
   itrxF(&dct[48]);
  
   
   {
      unsigned char *cr=::getCropTbl();
      int pos=0;
      for(j=0;j<16;j+=2){
         for(i=0;i<48;i+=6){
            int co=dct[tz[pos]];
            co+=8;co>>=4;
            const int p1=(i+j*stride);
            const int p2=p1+3;
            const int p3=p1+stride;
            const int p4=p3+3;
            //dct[pos]+=2;dct[pos]>>=2;
            if(iPic){
               pCur[p1]=pCur[p2]=pCur[p3]=pCur[p4]=cr[co+128];
            }
            else{
               pCur[p1]=cr[pCur[p1]+co];
               pCur[p2]=cr[pCur[p2]+co];
               pCur[p3]=cr[pCur[p3]+co];
               pCur[p4]=cr[pCur[p4]+co];
            }
            pos++;
         }
      }

   }
//if(iDec)debugss("bits-UY-8x8x2",ed->vlc.iBitPos-iBitPos,iPic);

   return  1;
}

#endif
template  <int iDec, int iPic>
int encMB16_DCT(ENC_BL_CTX *ctx, TDCTX *ed, unsigned char *pCur, unsigned char *pRef, int stride,int k,int  iIsB, int i_CanRestore,int &iIsBigCost, int iBestBits=0){

   if(0){//0&&!iPic){
      //return encMB16_DCTd2_UV<iDec,iPic>(ctx,ed,pCur,pRef,stride,k,iIsB,i_CanRestore,iIsBigCost,  iBestBits);
      int iBPX=ed->vlc.iBitPos;
      int zz=encMB16_DCTd2_UV<iDec,iPic>(ctx,ed,pCur,pRef,stride,k,iIsB,0,iIsBigCost,  iBestBits);
      return  zz;
      ed->vlc.iBitPos=iBPX;
      if(!zz)return 0;
   }
   
   //if(k)return encMB16_DCTd24x4_UV<iDec,iPic>(ctx,ed,pCur,pRef,stride,k,iIsB,i_CanRestore, iIsBigCost, iBestBits);
   //return encMB16_DCTd2_UV<iDec,iPic>(ctx,ed,pCur,pRef,stride,k,iIsB,i_CanRestore,iIsBigCost,  iBestBits);
   //T_ALIGN_64(unsigned char,saved,256);
   unsigned char saved[256];
   int iHasSaved=0;
   DCT_TYPE dct[4][64];
   DCT_TYPE q_dct[4][64];
   int iStartPsnr=0;
   int ofs;
   int dctDC[4];
   int iBitPos=ed->vlc.iBitPos;
   int i,s;
   int r01, r02, r03, r04;
  //k=0;
   const int *t=k?&ed->tab_uv[0]:&ed->tab_y[0];
   int i_mCoefs[4]={1,1,1,1};
   int iDCSkip=0;

   int iDCQ=(t[0]+t[2])>>3;
   iDCQ+=8;iDCQ>>=1;
   if(!iPic)iDCQ=t[0]*2;
   //iDCQ=(t[0]+2)>>1;
//iDCQ=t[0];
   iDCQ++;iDCQ&=~1;
//iDCQ=t[0]>>1;
   int iEncBlocks=0;
/*
   if(!iDec && !iPic && k && !ed->iIsReferenceFrame){
      ed->x_dif(NULL,pCur,pRef,stride);
      ed->x_dif(NULL,pCur+24,pRef+24,stride);
      ed->x_dif(NULL,pCur+stride*8,pRef+stride*8,stride);
      ed->x_dif(NULL,pCur+24+stride*8,pRef+24+stride*8,stride);
      return 0;
   }
*/

   int iSQErrStart=0;
   int iPsnrLim=ed->iQVal*12+3600;
   //int iPsnrLim=ed->iQVal*11+3800;
   int iCanRestore=ed->iIsKey==0 && !iPic;
   if(k && ctx->iHasUVMode && (ctx->iDCDifAbs*8>iDCQ*2 || (ctx->iDCDifAbs*8>iDCQ && ctx->iDCDifAbs>3)))  iCanRestore=0;  
   if(k && ctx->iHasUVMode && ctx->iMeanUV<60 && ctx->iDCDifAbs>((iDCQ+4)>>3))iCanRestore=0;
   if(k && ctx->iHasUVMode && ctx->iMeanUV==1 )iCanRestore=0;
   
//if(iPic==0 && k==0)return 0;
/*
   if(iCanRestore &&!iPic && !iDec && (k && !iIsB)){
   int getBlockPSNR_UV(unsigned char *p ,unsigned char *o, int w, int h, int stride, int step);
   int ar=analize(pCur, pRef,  stride,  k, iIsB, t);
   if(ar==7)return 7;
   if(ar==0)return 0;
   return 7;
   iCanRestore=0;
   }
*/
  int iSSim=0;//(int)(ssim*1000.f);   
  int iDif=-2;
   int iSadUV=3000;
   int iSADUVMax=ed->iIsReferenceFrame?256*4:256*9;
   //int iSADUVMax=256*8;
   int iSADUVSkip=ed->iIsReferenceFrame?150:380;
   int m=0,iSad=3000,iMinPosSad=2000,iTryMode=1,iDev=6000,iVecLen=4;
   int iCanFastSkip=1;
   if(!iPic && !iDec && !ed->iIsKey){
      getMBParams(ctx->i>>3, (ctx->j)>>3, k, ctx->w, m, iSad, iMinPosSad, iTryMode, iDev, iVecLen);
      int iHasSad=0;
      if(!iIsB && k && getMBParamUV(ctx->i>>3, (ctx->j)>>3, k, ctx->w,iSadUV)){
         iHasSad=iSadUV>=0;
//         if(iSadUV>=0 && iSadUV<280-ed->iIsReferenceFrame*100+iIsB*70)return 0;
         if(iSadUV>=0){
            if(iSadUV>iSADUVMax)iCanRestore=0;
           // iDif=iSadUV/120;
            //int sC=pCur[0]+pCur[3]+pCur[12]+pCur[42]+pCur[0+stride*4]+pCur[3+stride*4]+pCur[12+stride*4]+pCur[42+stride*4];
            //int sR=pRef[0]+pRef[3]+pRef[12]+pRef[42]+pRef[0+stride*4]+pRef[3+stride*4]+pRef[12+stride*4]+pRef[42+stride*4];
            //iDif=max((mmabs(((sC+4)>>3)-((sR+4)>>3))-iIsB),iDif);
         }

      }
      if(iSad>3000+iIsB*500 && (iSad*2>iMinPosSad*(4+iIsB) || (iSad>5000 && iSad*2>iMinPosSad*(3+iIsB))))iCanRestore=0;
      
      if((iIsB || iSadUV<iSADUVMax*2) && iCanRestore){
         if(k && ctx->iHasUVMode){iSadUV=ctx->iUVSad*4;iDif=ctx->iDCDifAbs;}else 
         iSadUV=sadGainUU_16(pCur,pRef,stride,&ed->t_d1[0]);
         //iDCQ
         if(iSadUV<40 || iSadUV<t[0]*(24-ed->iIsReferenceFrame*16)+iIsB*128){
//         if(iSadUV<40 || iSadUV<t[0]*(24-ed->iIsReferenceFrame*16)+iIsB*128){
            setSSIM_STAT(ctx->i>>4,ctx->j>>4,k,ctx->w,-iSadUV*1000-2);
            return 0;
         }
         if(!ctx->iHasUVMode)
         iDif=(iSadUV+100)>>8;
         //--if(iSadUV>t[0]*64+256*(3+iIsB))iCanRestore=0;
         if(iSadUV>t[0]*80+256*(1+iIsB))iCanRestore=0;
         if(iSadUV>(t[0])*48+256*(1+iIsB))iCanFastSkip=0;//iCanRestore=0;
         if(ed->iIsReferenceFrame && iSadUV>t[0]*20)iCanFastSkip=0;
      }
      

      if(ed->iIsReferenceFrame && (iSadUV>600 || iCanRestore==0))return 7;
      if(iCanRestore && iCanFastSkip){
         if(ctx->iHasUVMode){
            iDif=ctx->iDCDifAbs;
         }
         else{
            if(iDif<0)iDif=mmabs(calcUVDC(pCur,pRef,stride));if(iDif<0)iDif=0;
            int t0=t[0];//ed->tab_y[128];
            if(ed->iIsReferenceFrame==0 && k && (iDif*6<=t0 || iDif<1) && (iSadUV<iSADUVSkip-100+iIsB*100)){
               setSSIM_STAT(ctx->i>>4,ctx->j>>4,k,ctx->w,-1);
               return 0;
            }
            if(k && iIsB && iDif*6<=t0+8){
               setSSIM_STAT(ctx->i>>4,ctx->j>>4,k,ctx->w,-2);
               return 0;
            }
            if(iDif*(3-iIsB)>t0*2 &&  iDif>2 && (!k || !iHasSad || iSadUV>iSADUVSkip*(2+iIsB))){
               iCanRestore=0;
            }
         }
      }
   }
 
   if(iCanRestore &&!iPic && !iDec){
      if(k && ctx->iHasUVMode){iStartPsnr=ctx->iUVPsnr;iSQErrStart=ctx->iUVSadSQ;}else 
      iStartPsnr=k?getBlockPSNR_UV_SQ(pCur,pRef,16,16,stride,3,iSQErrStart):getBlockPSNR_SQ(pCur,pRef,16,16,stride,3,iSQErrStart);
      //iStartPsnr+=250;//corect psnr sq dc add
      //iStartPsnr+=320;
      setSSIM_STAT(ctx->i>>4,ctx->j>>4,k,ctx->w,0);
      setPSNR_STAT(ctx->i>>4,ctx->j>>4,k,ctx->w,iStartPsnr,0);

      if(iIsB && ctx->mb->col[k].iPrevStartPsnr<=iStartPsnr){
         setSSIM_STAT(ctx->i>>4,ctx->j>>4,k,ctx->w,-3);
         return 0;
      }

      if(!iIsB && ctx->mb){
         
         ctx->mb->col[k].iStartPsnr=iStartPsnr;
         ctx->mb->col[k].iPrevStartPsnr=iStartPsnr;
         ctx->mb->col[k].iSkip=ctx->mb->eSkipPsnr;
      }

      if(!iIsB && k && iStartPsnr<3600 && (ctx->mb->col[0].iType==MB16_2::ePic4x4 || ctx->mb->col[k-1].iType==MB16_2::ePic4x4)){
         return 7;
      }
      if(iCanFastSkip && iStartPsnr>3600 && k && iIsB && iDif*3<((t[0]+10)>>1)){
         return 0;
      }
      if(iCanFastSkip && iStartPsnr>3900-iIsB*300 && iSadUV>=0 && iSadUV<iSADUVSkip*(1+iIsB)-ed->iIsReferenceFrame*(iSADUVSkip>>1) && iDif*3<((t[0]+8+iIsB*2)>>1)){
         ctx->mb->col[k].iSkip=MB16_2::eSkip1;
        // debugss("sk-uv",iStartPsnr,k);
         return 0;
      }


      
      if(iStartPsnr>iPsnrLim-iIsB*200+ ed->iIsReferenceFrame*400)
      {
       
         if(iCanFastSkip && iDif*4<=((t[0]*3+6)>>2)){
            ctx->mb->col[k].iSkip=MB16_2::eSkip1;
            return 0;
         }
         else{
            iDCSkip=1;
         }
      }
     
      if(1){//(iStartPsnr<3800 || ed->iIsReferenceFrame) && !iIsB ){
         if(((iStartPsnr<3800 && !ctx->iHasUVMode) || ed->iIsReferenceFrame) && !iIsB){
            if(iSad*3>iDev*2 && (iSad>iMinPosSad || iStartPsnr<3000))return 7;
            if(iSad*4>iDev && (iSad>iMinPosSad*2 || iStartPsnr<2200))return 7;
         }
         if(iCanFastSkip && iSad*4<iMinPosSad*(5+iIsB) && iSadUV<t[0]*64 && iVecLen<4)return 0;
      }

      if(0){//(iStartPsnr*7<iPsnrLim*8 || iStartPsnr>3800)){
         float ssim=get_ssim(pCur,pRef,stride,k);//+(k?0.2f:0.0f);
         iSSim=(int)(ssim*1000.f);
         setSSIM_STAT(ctx->i>>4,ctx->j>>4,k,ctx->w,iSSim);
//         ssim+=(float)(84-ed->iQVal)/(1000.f);
         if(!k || iSadUV<iSADUVSkip+100){
            if(iSSim>(960-iIsB*20) && iDif<3 ){
               ctx->mb->col[k].iSkip=MB16_2::eSkip2;
               return 0;
            }
            if(iSSim>(985-iIsB*30) && iDif<5 ){
               ctx->mb->col[k].iSkip=MB16_2::eSkip3;
               return 0;
            }
         }
         iDCSkip|=iSSim>(950-iIsB*30);
         if(iSSim<800)iDCSkip=0;

         if(iDCSkip && iDif==0 && (k || iIsB)){
            ctx->mb->col[k].iSkip=MB16_2::eSkip3;
            return 0;
         }

      }

   }
   

#define LOAD_TR(_OFS,_ID) {\
   if(iPic)loadBlockK(&dct[_ID][0],pCur+_OFS,pRef+_OFS,stride);\
   else loadBlockFast(&dct[_ID][0],NULL,pCur+_OFS,pRef+_OFS,stride,0,1);\
   dct_fnc(&dct[_ID][0]);}

   ed->iPrevCoefsCnt=0;
   //ed->iPredDC=0;
  // int iPrevDC=ed->iPredDC;
   int dc0=0;
   if(!iDec){
      LOAD_TR(0,0);
      LOAD_TR(24,1);
      LOAD_TR(stride*8,2);
      LOAD_TR(stride*8+24,3);

      r01=dct[0][0];
      r02=dct[1][0];
      r03=dct[2][0];
      r04=dct[3][0];

      dctDC[0] = (+ r01 + r02 + r03 + r04) ;
      dctDC[1] = (- r01 + r02 - r03 + r04) ;
      dctDC[2] = (- r01 - r02 + r03 + r04) ;
      dctDC[3] = (+ r01 - r02 - r03 + r04) ;

      if(iPic==0 && (iDCSkip  || (k && iStartPsnr>4200)) && !(dctDC[0]|dctDC[1]|dctDC[2]|dctDC[3])){
         ctx->mb->col[k].iSkip=MB16_2::eSkipQ;
         return 0;
      }
      //??????????????????? debugss("q",iDCQ,iStartPsnr);

      const int iDCQ2=iDCQ*2;
      const int iDCQAdd=iPic?(iDCQ2/3):(iDCQ>>1);//iPic?(iDCQ/3+1):(iDCQ-1);//2*10/25;
//      int tt=0;
      int iMaxDC=0;

      for(i=0;i<4;i++){
         if(iMaxDC<mmabs(dctDC[i]))iMaxDC=mmabs(dctDC[i]);
         if(dctDC[i]<0) dctDC[i]=-((iDCQAdd-dctDC[i])/iDCQ2);else dctDC[i]=(dctDC[i]+iDCQAdd)/iDCQ2;
      }
      
      if(iPic==0 && (iDCSkip || iIsB || (k && iStartPsnr>4300)) && (!(dctDC[0]|dctDC[1]|dctDC[2]|dctDC[3]) || iMaxDC<8+iIsB*8)){
         ctx->mb->col[k].iSkip=MB16_2::eSkipQ;
         return 0;
      }
      dc0=dctDC[0];


//      int iCoefsOut;
      //iSadSQ*(1+ed->iIsReferenceFrame)<ed->iSQQuantErrUV 
      int iMaxS=0;
      int iSkipAC=!ed->iIsKey && ((!iPic && ctx->iMeanUV==1) || (iPic&& ctx->iMeanUV==10) || (iPic==0 && ((iDCSkip==1 && (iStartPsnr>4100 || iSSim>960-iIsB*30+ed->iIsReferenceFrame*20)) || iStartPsnr>4200+ed->iIsReferenceFrame*300-iIsB*200)));
      for(i=0;i<4;i++){
       //  if(dctDC[i]<0) dctDC[i]=-((iDCQAdd-dctDC[i])/iDCQ2);else dctDC[i]=(dctDC[i]+iDCQAdd)/iDCQ2;
         const int val=iPic && i==0?(dctDC[i]-ed->iPredDC):dctDC[i];
         ed->vlc.toL_Val_S(val,k||i?2:4);
         //if(val)iEncBlocks+=10;
         dct[i][0]=0;
         


         if(iSkipAC)s=0;else
         {
               s=ed->QTestK<iPic>(&dct[i][0],t,iIsB);
               if(s)s=ed->Q_NEW<iPic>(&q_dct[i][0],&dct[i][0],t,k,iIsB);
         }

         
         

         if(s){//(iDCSkip && s>2) || (!iDCSkip && s>1) || (s && (iPic || q_dct[i][8] || q_dct[i][1]))){
            if(s>iMaxS)iMaxS=s;
            ed->vlc.addB(1);
            ed->enc7xNoDC(&q_dct[i][0],k);
            ed->deQ<iPic,0>(&q_dct[i][0],&dct[i][0],t);//,iCoefsOut);//,64,0);
            i_mCoefs[i]=64;
            iEncBlocks++;
         }
         else{
            i_mCoefs[i]=0;
            ed->vlc.addB(0);
            //memset(&dct[i][0],0,128);
         }
         dct[i][0]=(dctDC[i]*iDCQ+1)>>1;
      }
      int dcC=mmabs(dct[0][0])|mmabs(dct[1][0])|mmabs(dct[2][0])|mmabs(dct[3][0]);
      if(!iPic && iEncBlocks==0){
         int dc=((dcC+4)>>3);
         if(dcC<6+iIsB*4 || !dc || (((dctDC[0]|dctDC[2]|dctDC[1]|dctDC[3])))==0){
            ctx->mb->col[k].iSkip=MB16_2::eSkipQ;
            return 0;
         }

      }
      
      if(iBestBits>0 && iBestBits<ed->vlc.iBitPos-iBitPos)
         return 0;
      if(iPic)ed->iPredDC=dctDC[0];

      if(dcC>16 || (dcC>8+iIsB*8 && dcC*3>iDCQ*4))iStartPsnr=0;

      if(iStartPsnr){TDCTX::getBlock16(&saved[0],pCur,stride);iHasSaved=1;}
   }
   else{
      for(i=0;i<4;i++){
         dctDC[i]=ed->vlc.get_L_Val_S(k||i?2:4);
         if(iPic && i==0)dctDC[i]+=ed->iPredDC;
         if(ed->vlc.getB()){
            int iCoefs;
            if(ed->dec7xNoDC(&q_dct[i][0],k,iCoefs)<0)return -1;
            ed->deQ<iPic,0>(&q_dct[i][0],&dct[i][0],t);//,iCoefs,0);
            i_mCoefs[i]=64;
         }
         else{
            //memset(&dct[i][0],0,128);
            i_mCoefs[i]=0;
         }
         dct[i][0]=(dctDC[i]*iDCQ+1)>>1;
      }
      if(iPic)ed->iPredDC=dctDC[0];
   }
//debugss("pb",iPic+iDec*10,iIsB);debugss("qpb",t[0],t[64]);

   if(iDec && ed->iVisDecoder){
      short sb[64];
      if(iPic){
         int *pv=(int*)&sb[0];
         for(i=0;i<32;i+=2){pv[i]=0x00400000;pv[i+1]=0x00000000;}
      }
      else {
         for(i=0;i<64;i+=32)
         {
            memset(&sb[i],0,16);
            memset(&sb[i+8],64,16);
            memset(&sb[i+16],0,16);
            memset(&sb[i+24],0,16);
         }
      }
      int o=((ctx->h-ctx->j-16)-ctx->j)*stride;
      
      ofs=0;
      ed->a_dif(&sb[0],pCur+o+ofs,stride);
      ofs=24;
      ed->a_dif(&sb[0],pCur+o+ofs,stride);
      ofs=stride*8;
      ed->a_dif(&sb[0],pCur+o+ofs,stride);
      ofs=stride*8+24;
      ed->a_dif(&sb[0],pCur+o+ofs,stride);


      return 0;
   }


   r01=dct[0][0];
   r02=dct[1][0];
   r03=dct[2][0];
   r04=dct[3][0];

   dct[0][0] = (r01 - r02 - r03 + r04);//+1)>>1;
   dct[1][0] = (r01 + r02 - r03 - r04);//+1)>>1;
   dct[2][0] = (r01 - r02 + r03 - r04);//+1)>>1;
   dct[3][0] = (r01 + r02 + r03 + r04);//+1)>>1;


#define LOAD_ITR(_OFS,_ID) {\
   if(iPic){\
     if(i_mCoefs[_ID]==0)idct_fnc_dc_put(&dct[_ID][0],pCur+_OFS,stride);else {\
         idct_fnc_dc128(&dct[_ID][0],64);\
         ed->copy_16_8(&dct[_ID][0],pCur+_OFS,stride);}\
   }else   {if(i_mCoefs[_ID])t_idct_int32_s(&dct[_ID][0],pCur+_OFS,stride);else if(dct[_ID][0])idct_fnc_dc_add(&dct[_ID][0],pCur+_OFS,stride);}}



   if(1 || iDec){
      LOAD_ITR(0,0);
      LOAD_ITR(24,1);
      LOAD_ITR(stride*8,2);
      LOAD_ITR(stride*8+24,3);
   }

   if(!iPic && !iDec && iHasSaved){
      if(mmabs(dc0)>1 || mmabs(dctDC[1])>1 ||  mmabs(dctDC[2])>1 ||  mmabs(dctDC[3])>1)return 1;
      if((mmabs(dc0)+mmabs(dctDC[1])+mmabs(dctDC[2])+mmabs(dctDC[3]))>2)return 1;
      
      if(!iPic && !iDec && iStartPsnr && dc0 && ((mmabs(r01)>(t[0]>>1)+4) || mmabs(dc0)>1)){
      /*
      int iErrEnd;
      int psnr=k?
         getBlockPSNR_UV_SQ(pCur,pRef,16,16,stride,3,iErrEnd):
         getBlockPSNR_SQ(pCur,pRef,16,16,stride,3,iErrEnd);
         setPSNR_STAT(ctx->i>>4,ctx->j>>4,k,ctx->w,iStartPsnr,psnr);
      int d=psnr-iStartPsnr;
      ctx->mb->col[k].iPrevStartPsnr=psnr;
      
      if(d<300+iIsB*100 && mmabs(r01)<64+iIsB*16-ed->iIsReferenceFrame*32){
         if(d<80+iIsB*80+(k?200:0) || iErrEnd*7>iSQErrStart*4){
            ctx->mb->col[k].iSkip=MB16_2::eSkipLast;
            if(!iIsB)TDCTX::putBlock16(&saved[0],pCur,stride);
            return 0;
         }
      }
      */
      }
      else if(iStartPsnr){
         int iErrEnd;
         
         int psnr=k?
            getBlockPSNR_UV_SQ(pCur,pRef,16,16,stride,3,iErrEnd):
            getBlockPSNR_SQ(pCur,pRef,16,16,stride,3,iErrEnd);
         int d=psnr-iStartPsnr;
   //      int b=ed->vlc.iBitPos-iBitPos;
         setPSNR_STAT(ctx->i>>4,ctx->j>>4,k,ctx->w,iStartPsnr,psnr);
         do{
            /*
            if(d>100+iIsB*80 || iErrEnd*(3+iIsB)<iSQErrStart*2)break;
            
            if(d>80+iIsB*80+(k?150:0) || iErrEnd*(2+iIsB)<iSQErrStart)break;
            if(d>150+iIsB*50 && iStartPsnr<((iPsnrLim+3600)>>1)-300)break;
            if(d>100+iIsB*250 && !k &&  b*3<d && iStartPsnr<3500)break;
            if(d>200+iIsB*250 && !k &&  b*4<d)break;
            if(d>200+iIsB*250 && b*20<d)break;
            if(d>200 && !iIsB && ed->iIsReferenceFrame && b*8<d)break;
            */
            if(d<200+iIsB*150 || iErrEnd*5>iSQErrStart*2){
               ctx->mb->col[k].iSkip=MB16_2::eSkipLast;
               if(!iIsB)TDCTX::putBlock16(&saved[0],pCur,stride);
               return 0;
            }
         }while(0);
         ctx->mb->col[k].iPrevStartPsnr=psnr;
      }
   }
//ctx->mb->col[k].iSkip=MB16_2::eNotSkiped;
iIsBigCost=0;
if(!iPic && ed->vlc.iBitPos-iBitPos>120){iIsBigCost|=1;}
if(!iPic && k && ed->vlc.iBitPos-iBitPos>40){iIsBigCost|=1;}
if(iEncBlocks==0)iIsBigCost=0;

//if(iDec)debugss("bits-UY-8x8",ed->vlc.iBitPos-iBitPos,iPic);

   return 1;//ed->vlc.iBitPos-iBitPos+1;
}

static int iLastFramePsnr=0;
void setLastFramePsnr(int psnr){
   iLastFramePsnr=psnr;
}

static int getUVMode(ENC_BL_CTX *ctx, TDCTX *ed, unsigned char *pCur, unsigned char *pRef, const int stride,int k, const int iIsB){
   //ctx->iHasUVMode=0;return 2;
   //T_ALIGN_64(int,ref,64);
   //T_ALIGN_64(int,cur,64);
 //  if(!iIsB && !ed->iThisWasB)return 3;
//   return 1;

   if(ed->iIsKeyUV)return 3;
   const int iDefRet=0;
   const int iDefRetN=!iIsB && ctx->mb && (ctx->mb[0].col[0].iType==MB16_2::ePic4x4 || (k==2 && ctx->mb[1].col[0].iType==MB16_2::ePic4x4))?3:1;
   DCT_TYPE ref[64];
   DCT_TYPE co[64];
  // return ed->iIsB?1:3;
  // int cur[64];
//   T_ALIGN_64(int,dif,64);
   int iPrevIsPic=!iIsB && !(ctx->i==0 && ctx->j==0) && (ctx->mb && ctx->mb[-1].col[k].iType==MB16_2::ePic4x4);
   if(k==2 && ctx->mb){
      if(ctx->mb[0].col[1].iType==MB16_2::eDif4x4)return 1;
   }
   ctx->iUVSad=0;
   ctx->iUVSadSQ=0;
   ctx->iUVPsnr=0;
   ctx->iHasUVMode=1;
   ctx->iDCDifAbs=0;
   ctx->iMeanUV=5000;
   //if(!ed->iIsB && !ed->iThisWasB)return 3;
   //ctx->iHasUVMode=0;return 1;

   //if((iIsB|ed->iThisWasB)){ctx->iDCDifAbs=10;ctx->iUVSadSQ=10*10*256;ctx->iUVSad=10*256;ctx->iUVPsnr=2500;return 2;}




   //--if(!iIsB && iSadUV>3500)return 3;
   int i,j,pos=0;
   int iSad=0;
   int iSadSQ=0;
   int iDC=0;
   int iDCCur=0;
   //int iSend=0;
   //int iMaxSqErr=(ed->tab_uv[128]*ed->tab_uv[128])>>8;
  // unsigned char *pabs=&ed->t_d1[0];
  // int iIsSkin=0,iSkMi,iSkMa;
  // if(k==1){iSkMa=115;iSkMi=99;}else {iSkMi=145;iSkMa=165;}
//#define _ABS(_A) mmabs(_A)
   //#define _ABS(_A) pabs[_A]
   #define _ABS(_A) abs(_A)
   for(j=0;j<16;j+=2){
      for(i=0;i<48;i+=6){
         const int cu=(pCur[i]+pCur[i+3]+pCur[i+stride]+pCur[i+stride+3])>>2;
         const int re=(pRef[i]+pRef[i+3]+pRef[i+stride]+pRef[i+stride+3])>>2;
         const int d=cu-re;
         const int sq=d*d;
         iSadSQ+=sq;
         iDC+=re;
         iDCCur+=cu;
         iSad+=_ABS(d);
    ///     iIsSkin+=re<iSkMa && re>iSkMa;
         ref[pos]=re;
         co[pos]=d;
    //     if(sq>iMaxSqErr)iSend=1;

//         cur[pos]=cu;
         pos++;
      }
      pRef+=stride*2;
      pCur+=stride*2;
    }
  // if(!iSend)return 0;
   pCur-=stride*16;pRef-=stride*16;

   int iB=iIsB|ed->iThisWasB;iB=!!iB;
   static int iDevCheck=8;
   if(k==1 && !(ctx->i|ctx->j) && !iB && !ed->iThisWasBX)iDevCheck--;
   if(iDevCheck<0)iDevCheck=8;
   if(ed->iIsReferenceFrame)iDevCheck=1;

   ctx->iUVSad=iSad;
   ctx->iUVSadSQ=iSadSQ;
   ctx->iDCDif=iDC-iDCCur;
   int iDCDif=mmabs(iDC-iDCCur);
   ctx->iDCDifAbs=(iDCDif+32)>>6;

   //return tryEncDCOnly(iDC-iDCCur,ctx,ed,pCur,pRef,stride,k,iIsB);

   int iDCQ=getDCQuant4x4<0>(ed, k,  iIsB);
   int iFastSkip=1;//ctx->mb->col[0].iType!=ctx->mb->ePic4x4;//!iIsSkin;

   if(iSad*16<iDCQ)return 0;

   int iAbsLim=iDCQ>>8;//(ed->tab_y[128]>>5)+iB;
   if(!iIsB && (ctx->iDCDifAbs>iAbsLim+5+iB || ctx->iDCDifAbs>8))
      return 3;
   if(!iIsB && ctx->iDCDifAbs>2+iB+(iDCQ>>8) && (iDCDif>iDCQ*2))
      return 3;
   //--if(!iIsB &&ed->iIsReferenceFrame && ctx->iDCDifAbs>(iDCQ>>7))return 3;
   //if(!iB &&  (iSad>(iDCQ>>3)+32) && iSadSQ>iSad*8+32+(iDCQ>>3))return 3;


   if(!iB && !ed->iThisWasBX && iDevCheck==1 && iSad>(iDCQ>>4)+72 && iSadSQ+32>iSad*4)// && variance>20 && ctx->iDCDifAbs>2+iB)
   {
      if(ctx->mb){
         if(ctx->mb[0].col[0].iType==MB16_2::ePic4x4)return 3;
         if(k==2 &&  ctx->mb[0].col[1].iType==MB16_2::ePic4x4)return 3;
      }

      int iMean=1;
      const int iDCsh6=(iDC+32)>>6;
      for(i=0;i<64;i++){
         const int dif=ref[i]-iDCsh6;
         if((unsigned)(dif+1)>2)
            iMean+=_ABS(dif);
      }
      if(iMean+64<iSad){
         if(iMean<15)iMean=10;
         ctx->iMeanUV=iMean;
         return 3;
      }
   }   
//if(ed->iIsReferenceFrame && ctx->iDCDifAbs>(iDCQ>>8)+3)return 3;      
   if(iSadSQ<ed->iSQQuantErr4x4Y && ctx->iDCDifAbs<=(iDCQ>>6))return iDefRet;
   if(iSadSQ<ed->iSQQuantErr4x4Y+50)return tryEncDCOnly(iDC-iDCCur,ctx,ed,pCur,pRef,stride,k,iIsB);

   if(iFastSkip  && (!ed->iIsReferenceFrame || iSadSQ<ed->iSQQuantErr4x4Y)){
      if(iSad*3<iDCQ && ctx->iDCDifAbs<=iIsB+1)return iDefRet;
      if(iSad<32+(iB)*64)return iDefRet;
   }
   
   if(k==2 && ctx->mb && ctx->mb[0].col[1].iType==MB16_2::ePic4x4)return 3;
//return 1;
   int variance=500;

#if 0

   if(iSad>80 && (iSad>(iDCQ>>1) ||ed->iIsReferenceFrame) && !iIsB)
   {
      //int mean_v = iSad >>8;
      //double variance = (iSadSQ >>8) - mean_v * mean_v;
      //if(!iB && variance>(400+iAbsLim*40))return 3;   
      int mean_v = iSad >>7;
      variance = (iSadSQ >>7) - mean_v * mean_v;

      if(ed->iIsReferenceFrame && variance>40)
         return 3;
      if(variance>(120+iAbsLim*8))
         return 3;   
      if((iPrevIsPic || ctx->mb[0].col[0].iType==MB16_2::ePic4x4)&& ctx->iPrevDCCnt<=1 && variance*2>iSad)return 3;

      

      
      if(variance<4+iB*2 && ctx->iDCDifAbs>=(iDCQ>>7))return tryEncDCOnly(iDC-iDCCur,ctx,ed,pCur,pRef,stride,k,iIsB);

   }

   //int iSQ=iSadSQ;
   int difDC=(iDC>>1)-(iDCCur>>1);
   //iSadSQ+=(difDC*difDC);
   ctx->iUVSadSQ=iSadSQ+(difDC*difDC);

#endif

   int getPSNRFromSQ(int iSq, int cnt);
   ctx->iUVPsnr=getPSNRFromSQ(ctx->iUVSadSQ,68);
//return 1;
   if(iSadSQ>ed->iSQQuantErr4x4Y*5 && ctx->iDCDifAbs>4)return iIsB?iDefRetN:((ed->iIsReferenceFrame||iSadSQ>iSad*4)?3:iDefRetN);
   int iPsnrL=iLastFramePsnr?(((iLastFramePsnr)+4800*3)>>2):4800;
   if(!ed->iIsReferenceFrame && ctx->iDCDifAbs<=iB &&  ctx->iUVPsnr>iPsnrL-(iB)*300 )return 0;
   if(!iB && ctx->iUVPsnr*2<iLastFramePsnr){
      return 3;
   }
   if(ed->iIsReferenceFrame)return 1;

//   if(ctx->iDCDifAbs>(ed->tab_uv[0]>>3)+3 && ctx->iDCDifAbs>(iAbsLim)*2+1+iB)      goto checkM;

   ::dct_fnc(&co[0]);
//int t0=(ed->tab_y[128]>>2)+6;
   //128/16
int t0=(iDCQ+16)>>5;
if(t0<8){t0+=8;t0>>=1;}
if(iB)t0+=6;
//t0=8;
//t0=(iDCQ+32)>>3;
   if(ctx->mb && ctx->mb->col[0].iType==MB16_2::eSkiped){t0+=4;}
   unsigned int t0m2=t0<<1;
   //int coC=co[0];co[0]=0;
   for(j=1;j<64;j++)//if(co[j]>t0 || co[j]<-t0)break;
      if((unsigned)((int)co[j]+t0)>t0m2){
         //goto checkM2;
         //if(ti15[j]&& !iB && abs(co[j])>t0*4+16)return 3;
         return 1;
      }
   if(j==64){
      if(co[0]<(3+iB)*2 && co[0]>(3+iB)*2)return 0;
      if(ctx->iDCDifAbs<=iB+(iDCQ>>7))return 0;

      return tryEncDCOnly(iDC-iDCCur,ctx,ed,pCur,pRef,stride,k,iIsB);

      if(ctx->iDCDifAbs && 
         (//ctx->iDCDifAbs>((ed->tab_uv[0]+4)>>3) || 
          ctx->iDCDifAbs>((iDCQ+64)>>7)
          )){return  tryEncDCOnly(iDC-iDCCur,ctx,ed,pCur,pRef,stride,k,iIsB);}

      if(ctx->iDCDifAbs<iAbsLim)return 0;
     
      ctx->iMeanUV=1;
      return 1;
   }
   /*
checkM2:
   
   if(!iB && ti21[j]){
      ::dct_fnc(&ref[0]);
      int iSR=1,iSD=0;
      for(j=0;j<64;j++){
         if((unsigned)((int)ref[j]+4)>8)iSR+=(abs(ref[j])*17)>>4;
         if((unsigned)((int)co[j]+4)>8)iSD+=abs(co[j]);
      }
   return iSR<iSD?3:1;
   }else return 1;
   */
   

   //return (iMean+32<iSad || iMean<15) && !iIsB?3:1;
checkM:
   if(!iIsB){
      //if(iPrevIsPic && ctx->iPrevDCCnt==1)
      int mean_v = iSad >>7;
      variance = (iSadSQ >>7) - mean_v * mean_v;
      if(ed->iIsReferenceFrame && variance>20){ctx->iMeanUV=5000;return 3;}
      if(variance>80 && ctx->iDCDifAbs>1)
         {ctx->iMeanUV=5000;return 3;}
   }
   if(variance<10)ctx->iMeanUV=1;
return 1;
   if(iIsB)return 1;

   int iMean=10;
   int iDCSub=(iDC)>>6;
   if((iSad>128 || ctx->iDCDifAbs>1 || ed->iIsReferenceFrame) && (iSad>ed->tab_uv[0]*3+32 || iSad>256)){//
      int d1=ed->tab_y[128]>>2;//(ed->tab_uv[0]+7)>>3;
      if(d1<1)d1=1;
      if(d1>3)d1=3;
      const unsigned int d2=d1*2;
      
      for(i=0;i<64;i++){
         int dif=ref[i]-iDCSub;
         if((unsigned)(dif+d1)>d2)
            iMean+=_ABS(dif);
         //iMean+=_ABS(ref[i]-iDCSub);
      }
int iDCQ_8x8=(ed->tab_uv[0]+ed->tab_uv[2])>>3;
iDCQ_8x8+=8;iDCQ_8x8>>=1;
      if(!iIsB && (iMean==10 || iMean>iSad+150|| (ctx->iDCDifAbs>iAbsLim+2 && iMean>iSad)||
         (k==2 && ctx->mb->col[1].iType==ctx->mb->ePic4x4) || ctx->mb->col[0].iType==ctx->mb->ePic4x4 || iPrevIsPic 
         || ed->iIsReferenceFrame) && iMean<iSad &&  (ctx->iDCDifAbs>(((iDCQ_8x8>>3)+(ed->tab_uv[128]>>4)+1)>>1) || iMean==10)){
         ctx->iMeanUV=iMean;
         return 3;
      }

   }
   else{
      iMean=iSad*2+30;
   }
   int m=iMean;
   
   if((k==2 && ctx->mb->col[1].iType==ctx->mb->ePic4x4) || ctx->mb->col[0].iType==ctx->mb->ePic4x4 || iPrevIsPic)iMean-=32;

   if((iMean+32<iSad || iMean<15) && !iIsB){
      ctx->iMeanUV=m;
      return 3;
   }
   if(ctx->iMeanUV!=1)ctx->iMeanUV=m;
   return 1;
   
}

#if 0
static int getUVMode_zz(ENC_BL_CTX *ctx, TDCTX *ed, unsigned char *pCur, unsigned char *pRef, const int stride,int k, const int iIsB){
   //ctx->iHasUVMode=0;return 2;
   //T_ALIGN_64(int,ref,64);
   //T_ALIGN_64(int,cur,64);
 //  if(!iIsB && !ed->iThisWasB)return 3;
//   return 1;
   int ref[64];
   DCT_TYPE co[64];
  // return ed->iIsB?1:3;
  // int cur[64];
//   T_ALIGN_64(int,dif,64);
   int iPrevIsPic=!iIsB && !(ctx->i==0 && ctx->j==0) && (ctx->mb && ctx->mb[-1].col[k].iType==MB16_2::ePic4x4);
   ctx->iUVSad=0;
   ctx->iUVSadSQ=0;
   ctx->iUVPsnr=0;
   ctx->iHasUVMode=1;
   ctx->iDCDifAbs=0;
   ctx->iMeanUV=5000;
   //if(!ed->iIsB && !ed->iThisWasB)return 3;
   //ctx->iHasUVMode=0;return 1;

   //if((iIsB|ed->iThisWasB)){ctx->iDCDifAbs=10;ctx->iUVSadSQ=10*10*256;ctx->iUVSad=10*256;ctx->iUVPsnr=2500;return 2;}

   int iSadUV=3000;
   const int ret=0;//ed->iIsReferenceFrame?1:0;
   //---------------------------------------------todo dec2x2 full pic line by line
   if(iIsB)iSadUV=300;
   else getMBParamUV(ctx->i>>3, (ctx->j)>>3, k, ctx->w,iSadUV);
   //if(ed->iIsReferenceFrame && iSadUV>=0 && iSadUV<32)return 0;



   //--if(!iIsB && iSadUV>3500)return 3;
   int iTryDCOnly=0;//TODO test bi mode
   if(!ed->iIsReferenceFrame && iSadUV>=0 && iSadUV<30+iIsB*80)iTryDCOnly=1;
   else if(ed->iIsReferenceFrame && iSadUV>=0 && iSadUV<20)iTryDCOnly=1;//return 0;
   int i,j,pos=0;
   int iSad=0;
   int iSadSQ=0;
   int iDC=0;
   int iDCCur=0;
   //int iSend=0;
   //int iMaxSqErr=(ed->tab_uv[128]*ed->tab_uv[128])>>8;
//   unsigned char *pabs=&ed->t_d1[0];
  // int iIsSkin=0,iSkMi,iSkMa;
  // if(k==1){iSkMa=115;iSkMi=99;}else {iSkMi=145;iSkMa=165;}
//#define _ABS(_A) mmabs(_A)
//   #define _ABS(_A) abs[_A]
   for(j=0;j<16;j+=2){
      for(i=0;i<48;i+=6){
         const int cu=(pCur[i]+pCur[i+3]+pCur[i+stride]+pCur[i+stride+3])>>2;
         const int re=(pRef[i]+pRef[i+3]+pRef[i+stride]+pRef[i+stride+3])>>2;
         const int d=cu-re;
         const int sq=d*d;
         iSadSQ+=sq;
         iDC+=re;
         iDCCur+=cu;
         iSad+=_ABS(d);
    ///     iIsSkin+=re<iSkMa && re>iSkMa;
         ref[pos]=re;
         co[pos]=d;
    //     if(sq>iMaxSqErr)iSend=1;

//         cur[pos]=cu;
         pos++;
      }
      pRef+=stride*2;
      pCur+=stride*2;
    }
  // if(!iSend)return 0;
   pCur-=stride*16;pRef-=stride*16;

   ctx->iUVSad=iSad;
   ctx->iUVSadSQ=iSadSQ;
   ctx->iDCDif=iDC-iDCCur;
   int iDCDif=mmabs(iDC-iDCCur);
   ctx->iDCDifAbs=(iDCDif+32)>>6;

//if(iIsB)return tryEncDCOnly(iDC-iDCCur,ctx,ed,pCur,pRef,stride,k,iIsB);

   int iDCQ=getDCQuant4x4<0>(ed, k,  iIsB);
int iFastSkip=1;//ctx->mb->col[0].iType!=ctx->mb->ePic4x4;//!iIsSkin;
int iB=iIsB|ed->iThisWasB;
int iAbsLim=iDCQ>>7;//(ed->tab_y[128]>>5)+iB;
if(!iIsB && (ctx->iDCDifAbs>iAbsLim+3 ||ctx->iDCDifAbs>6 || (ctx->iDCDifAbs)>(iDCQ>>6)+2)){return 3;}
if(ed->iIsReferenceFrame && ctx->iDCDifAbs>(iDCQ>>8)+2)return 3;

   if(iFastSkip  && (!ed->iIsReferenceFrame || iSadSQ<ed->iSQQuantErrUV)){
      if(iSad*2<iDCQ)return 0;
      if((iB)&& ctx->iDCDifAbs<iAbsLim && ctx->mb && ctx->mb->col[0].iSkip!=MB16_2::eNotSkiped)return 0;
      if(iSad<32+(iB)*64)return 0;
      //if(iSad*9>iSadSQ*8 && ctx->iDCDifAbs>(iSad+30)/60 && ctx->iDCDifAbs<8)return tryEncDCOnly(iDC-iDCCur,ctx,ed,pCur,pRef,stride,k,iIsB);

      if((iB)&& iSad<iAbsLim*64)return tryEncDCOnly(iDC-iDCCur,ctx,ed,pCur,pRef,stride,k,iIsB);//return 1;
      //if(iSadSQ<ed->iSQQuantErrUV){
         if((iTryDCOnly && iSadSQ+iSad<ed->iSQQuantErrUV*2)  || 
            iSadSQ-64<ed->iSQQuantErrUV || iSadSQ<ed->iSQQuantErr4x4Y)return tryEncDCOnly(iDC-iDCCur,ctx,ed,pCur,pRef,stride,k,iIsB);
     // }
     
   }

   
   

   //int iSQ=iSadSQ;
   int difDC=(iDC>>1)-(iDCCur>>1);
   //iSadSQ+=(difDC*difDC);
   ctx->iUVSadSQ=iSadSQ+(difDC*difDC);


   int getPSNRFromSQ(int iSq, int cnt);
   ctx->iUVPsnr=getPSNRFromSQ(ctx->iUVSadSQ,68);
   /*
   if(iLastFramePsnr && iLastFramePsnr>ctx->iUVPsnr+iB*300)goto checkM;
   if(ctx->iDCDifAbs>iB+((iDCQ+80)>>7))goto checkM;
*/
//goto checkM
   if(!iFastSkip||ed->iIsReferenceFrame)goto checkM;

   if(ctx->iDCDifAbs>(ed->tab_uv[0]>>3)+3 && ctx->iDCDifAbs>iAbsLim*2+1){
      goto checkM;
   }
   int iPsnrL=iLastFramePsnr?(((400+iLastFramePsnr)*3+4000)>>2):4200;
   if(ctx->iDCDifAbs<=iB &&  ctx->iUVPsnr>iPsnrL-iB*300 )return 0;

   if(ctx->iUVPsnr>iPsnrL-iB*200)return tryEncDCOnly(iDC-iDCCur,ctx,ed,pCur,pRef,stride,k,iIsB);


   ::dct_fnc(&co[0]);
   /*
   int t0=//(104-ed->iQVal)>>2;//
          (ed->tab_y[128]>>1)+3;
   //int t0=((ed->tab_y[128]+ed->tab_y[0])>>1);
   if(t0>24){t0+=24;t0>>=1;if(t0>32){t0+=96;t0>>=2;}}
   if(t0<3)t0=3;
   if(iB)t0+=8;
   */
   //t0+=(ctx->mb && ctx->mb->col[0].iSkip!=MB16_2::eNotSkiped)*3;
//int t0=(ed->tab_uv[129]>>3)+6;//313 40
int t0=(ed->tab_y[128]>>2)+8;
t0+=(iDCQ>>4);t0>>=1;
if(t0<12){t0+=12;t0>>=1;}
   if(ctx->mb && ctx->mb->col[0].iSkip!=MB16_2::eNotSkiped){t0+=3;}
   unsigned int t0m2=t0<<1;
   //int coC=co[0];co[0]=0;
   for(j=1;j<64;j++)//if(co[j]>t0 || co[j]<-t0)break;
      if((unsigned)((int)co[j]+t0)>t0m2)break;
   if(j==64){
      if(co[0]<7 && co[0]>-7)return 0;
      if(ctx->iDCDifAbs<=iB+(iDCQ>>8))return 0;
      /*
      if(iLastFramePsnr && ctx->iUVPsnr+iB*300<iLastFramePsnr && ctx->iUVPsnr<3700-iB*200)
      {
         ctx->iMeanUV=1;
         return 1;
      }

      if(ctx->iDCDifAbs && 
         (ctx->iDCDifAbs>((ed->tab_uv[0]+4)>>3) || 
          ctx->iDCDifAbs>=((iDCQ+64)>>7)
          )){return  tryEncDCOnly(iDC-iDCCur,ctx,ed,pCur,pRef,stride,k,iIsB);}

      if(ctx->iDCDifAbs<iAbsLim)return 0;
     
      ctx->iMeanUV=1;
      */
      return  tryEncDCOnly(iDC-iDCCur,ctx,ed,pCur,pRef,stride,k,iIsB);
         
   }
   //return (iMean+32<iSad || iMean<15) && !iIsB?3:1;
checkM:
   if(iIsB)return 1;

   int iMean=10;
   int iDCSub=(iDC)>>6;
   if((iSad>128 || ctx->iDCDifAbs>1 || ed->iIsReferenceFrame) && (iSad>ed->tab_uv[0]*3+32 || iSad>256)){//
      int d1=ed->tab_y[128]>>2;//(ed->tab_uv[0]+7)>>3;
      if(d1<1)d1=1;
      if(d1>3)d1=3;
      const unsigned int d2=d1*2;
      
      for(i=0;i<64;i++){
         int dif=ref[i]-iDCSub;
         if((unsigned)(dif+d1)>d2)
            iMean+=_ABS(dif);
         //iMean+=_ABS(ref[i]-iDCSub);
      }
      int iDCQ_8x8=(ed->tab_uv[0]+ed->tab_uv[2])>>3;
      iDCQ_8x8+=8;iDCQ_8x8>>=1;
      if(!iIsB && (iMean==10 || iMean>iSad+150|| (ctx->iDCDifAbs>iAbsLim+2 && iMean>iSad)||
         (k==2 && ctx->mb->col[1].iType==ctx->mb->ePic4x4) || ctx->mb->col[0].iType==ctx->mb->ePic4x4 || iPrevIsPic 
         || ed->iIsReferenceFrame) && iMean<iSad &&  (ctx->iDCDifAbs>(((iDCQ_8x8>>3)+(ed->tab_uv[128]>>4)+1)>>1) || iMean==10)){
         ctx->iMeanUV=iMean;
         return 3;
      }

   }
   else{
      iMean=iSad*2+30;
   }
   int m=iMean;
   
   if((k==2 && ctx->mb->col[1].iType==ctx->mb->ePic4x4) || ctx->mb->col[0].iType==ctx->mb->ePic4x4 || iPrevIsPic)iMean-=32;

   if((iMean+32<iSad || iMean<15) && !iIsB){
      ctx->iMeanUV=m;
      return 3;
   }
   if(ctx->iMeanUV!=1)ctx->iMeanUV=m;
   return 1;
   
}
static int getUVMode_d4(ENC_BL_CTX *ctx, TDCTX *ed, unsigned char *pCur, unsigned char *pRef, int stride,int k, int iIsB){
   int ref[16];
   DCT_TYPE co[16];
  // return ed->iIsB?1:3;
  // int cur[64];
//   T_ALIGN_64(int,dif,64);
   int iPrevIsPic=!iIsB || (ctx->i==0 && ctx->j==0) || (ctx->mb && ctx->mb[-1].col[k].iType==MB16_2::ePic4x4);
   ctx->iUVSad=0;
   ctx->iUVSadSQ=0;
   ctx->iUVPsnr=0;
   ctx->iHasUVMode=1;
   ctx->iDCDifAbs=0;
   ctx->iMeanUV=5000;
   int iSadUV=3000;
   const int ret=0;//ed->iIsReferenceFrame?1:0;
   //---------------------------------------------todo dec2x2 full pic line by line
   if(iIsB)iSadUV=300;
   else getMBParamUV(ctx->i>>3, (ctx->j)>>3, k, ctx->w,iSadUV);

   

   int iDCQ_8x8=(ed->tab_uv[0]+ed->tab_uv[2])>>3;
   iDCQ_8x8+=8;iDCQ_8x8>>=1;

   //--if(!iIsB && iSadUV>3500)return 3;
   int iTryDCOnly=0;//TODO test bi mode
   if(!ed->iIsReferenceFrame && iSadUV>=0 && iSadUV<90+iIsB*100)iTryDCOnly=1;
   else if(ed->iIsReferenceFrame && iSadUV>=0 && iSadUV<30)iTryDCOnly=1;//return 0;
   int i,j,pos=0;
   int iSad=0;
   int iSadSQ=0;
   int iDC=0;
   int iDCCur=0;
   unsigned char *pabs=&ed->t_d1[0];

   for(j=0;j<16;j+=4){
      for(i=0;i<48;i+=12){
         int cu=0;
         int re=0;
         for(int z=0;z<4;z++){
            unsigned char *c=pCur+i+z*stride;
            unsigned char *o=pRef+i+z*stride;
            cu+=c[0]+c[3]+c[6]+c[9];
            re+=o[0]+o[3]+o[6]+o[9];
         }
         cu>>=2;re>>=2;

         
         const int d=cu-re;
         iSadSQ+=d*d;
         iDC+=re;
         iDCCur+=cu;
         iSad+=_ABS(d);
         re>>=2;cu>>=2;
         ref[pos]=re;//2x
         co[pos]=cu-re;
         pos++;
      }
      pRef+=stride*4;
      pCur+=stride*4;
    }
   pCur-=stride*16;pRef-=stride*16;
   /*
   if(k==2){// && ctx->i==15*16 && ctx->j==9*16){
      void drawBlock(int *p, int w, int a, int b);
      drawBlock(ref,8,ctx->i>>1,ctx->h+((ctx->h-ctx->j)>>1));
      drawBlock(cur,8,ctx->i>>1,ctx->h+((ctx->h*2-ctx->j)>>1));
   }
   */
   ctx->iUVSad=iSad;
   ctx->iUVSadSQ=iSadSQ;
   ctx->iDCDif=iDC-iDCCur;
   int iDCDif=mmabs(iDC-iDCCur);
   ctx->iDCDifAbs=iDCDif>>6;
   int iDCQ=getDCQuant4x4<0>(ed, k,  iIsB);
//return 2;
   
//return 3;
   if(iSad*2<iDCQ)return 0;
   if((iIsB ||ed->iThisWasB)&& ctx->iDCDifAbs<2)return 0;
   if(iSad<32+iIsB*64)return 0;
   if((iIsB ||ed->iThisWasB)&& iSad<ed->tab_uv[0]*8)return tryEncDCOnly(iDC-iDCCur,ctx,ed,pCur,pRef,stride,k,iIsB);//return 1;
   //if(iSad<ed->tab_uv[0]*6+64)return 1;
  // return tryEncDCOnly(iDC-iDCCur,ctx,ed,pCur,pRef,stride,k,iIsB);//return 1;

   


   if(!ed->iIsReferenceFrame || ctx->iDCDifAbs<(ed->tab_uv[0]>>3)+1){
      if(iTryDCOnly  || iSadSQ<ed->iSQQuantErrUV)return tryEncDCOnly(iDC-iDCCur,ctx,ed,pCur,pRef,stride,k,iIsB);
   }

 //  if(iIsB)return tryEncDCOnly(iDC-iDCCur,ctx,ed,pCur,pRef,stride,k,iIsB);return 3;
   int iMean;
   int iDCSub=(iDC+32)>>6;
   
   
   if(iSad>ed->tab_uv[0]*6){
      const int d1=(ed->tab_uv[0]+8)>>3;
      const unsigned int d2=d1*2;
      iMean=0;

      
      for(i=0;i<16;i++){
         int dif=ref[i]-iDCSub;
         if((unsigned)(dif+d1)>d2)iMean+=_ABS(dif);
         //iMean+=_ABS(ref[i]-iDCSub);
      }

      if(!iIsB && ((k==2 && ctx->mb->col[1].iType==ctx->mb->ePic4x4) || ctx->mb->col[0].iType==ctx->mb->ePic4x4 || iPrevIsPic || ed->iIsReferenceFrame) && iMean<iSad &&  ctx->iDCDifAbs>(((iDCQ_8x8>>4)+(ed->tab_uv[0]>>4)+1)>>1)){
         ctx->iMeanUV=10;
         return 3;
      }
      iMean*=6;iMean+=10;
   }
   else{
      iMean=iSad*2+10;
   }
   ctx->iMeanUV=iMean;
   if(ctx->mb->col[0].iType==ctx->mb->ePic4x4 || iPrevIsPic){iMean-=ed->tab_uv[0]*3;if(iMean<10)iMean=10;}
   if(!iIsB && iMean==10 && ctx->iDCDifAbs>(ed->tab_uv[0]>>3))return 3;
   
   if(ed->iIsReferenceFrame && !iIsB && iMean==10)return 3;

   
//void trHada(unsigned char *src,unsigned char *src2, int stride, int *d);   
  // iMean+=20;

   if(!iIsB && iMean+ed->tab_uv[0]*(16-ed->iIsReferenceFrame*12)<iSad)return 3;
   if(iMean<ed->tab_uv[0]*8+120 && !iIsB && iMean<iSad && ctx->iDCDifAbs>=((ed->tab_uv[0]+5)>>3))return 3;

   //if(iSad<iMean && iSad*3>iSadSQ*2)return tryEncDCOnly(iDC-iDCCur,ctx,ed,pCur,pRef,stride,k,iIsB);

  // int iSQ=iSadSQ;
   int difDC=(iDC>>1)-(iDCCur>>1);
   //iSadSQ+=(difDC*difDC);
   ctx->iUVSadSQ=iSadSQ+(difDC*difDC);


   int getPSNRFromSQ(int iSq, int cnt);
   ctx->iUVPsnr=getPSNRFromSQ(ctx->iUVSadSQ,65);
//return 2;
   if(ed->iIsReferenceFrame){
      if(iMean<iSad || iSadSQ>ed->iSQQuantErrUV || ctx->iUVPsnr<iLastFramePsnr-600)return 3;
      return 1;
   }
   if(iSad<iMean && iSadUV>1100)return 1;

   if(iIsB && iMean+((ed->tab_uv[0]>>3)+2)*64<iSad && ctx->iDCDifAbs>(ed->tab_uv[0]>>3)+1)return 1;//iDCQ<ed->tab_uv[0]*16 ?3:2;
//return 2;

   if(iMean>iSad && !ed->iIsReferenceFrame && iLastFramePsnr>2600 && ctx->iUVPsnr>iLastFramePsnr+400-iIsB*200)
      return tryEncDCOnly(iDC-iDCCur,ctx,ed,pCur,pRef,stride,k,iIsB);
   if(1){//(!iIsB && iMean+32<iSad) || ctx->iDCDifAbs<=(iDCQ>>6)|| ctx->iDCDifAbs<(ed->tab_uv[128]>>3)+1 || (ctx->iDCDifAbs<(ed->tab_uv[129]>>4)+2) || (iLastFramePsnr && ctx->iUVPsnr>iLastFramePsnr+100-iIsB*200)){
      void trHadaBL(short *bl, int stride, int *d);
      
      int iSk=1;
      int hac[16];
      int t0=ed->tab_uv[0]*2;//(ed->tab_uv[0]*4+ed->tab_uv[128]>>4)>>1;
      if(t0<16+iIsB*16)t0=16+iIsB*16;
      if(t0<((iDCQ*16+64)>>7))t0=((iDCQ*16+64)>>7);
      //if(t0>ed->tab_uv[128]+12)t0=ed->tab_uv[128]+12;

      int iDCOnly=0;
//      int iHaDC=0;

         trHadaBL(&co[0],4,&hac[0]);
         //iHaDC+=hac[0];
         for(i=0;i<16;i++){
            int v=hac[i];
            if(v<0)v=-v;
            //--if(i==0 &&  iMean+32<iSad && v>t0){iSk=0;break;}
            if(i){
               if(v*3>ed->tab_y[128+i]*4){iSk=0;iDCOnly=0;break;}
            }
            else{
               if(v>t0){if(iMean+32<iSad){iSk=0;iDCOnly=0;break;}iDCOnly=1;}
            }
            
            //if(v>ed->tab_uv[128]){iSk=0;break;}
            if(iIsB)break;
         }
      

      if((!iSk ||iDCOnly) && !iIsB &&  (ctx->iMeanUV==10 || iMean+ed->tab_uv[0]*3+32<iSad))return 3;
      if(iDCOnly)ctx->iMeanUV=1;
      if(iSk && iDCOnly){return 1;}
      if(iSk) return ctx->iDCDifAbs<(ed->tab_uv[128]>>7)+1 && ctx->iDCDifAbs<(ed->tab_uv[0]>>3)+3 && ctx->iDCDifAbs<4+iIsB?0:tryEncDCOnly(iDC-iDCCur,ctx,ed,pCur,pRef,stride,k,iIsB);
      return iSad*4>iSadSQ?2:1;
      return 1;
   }

   return iMean<64*6 && iSad*3>iSadSQ?2:1;
}
#endif



typedef struct{
   int iSkip1[3];
   int iSkip2[3];
   int iSkip3[3];
   int iSkipQ[3];
   int iSkipLast[3];
   int iSkipPsnr[3];
   int iBlocksDifSent[3];
   int iBlocksPicSent[3];
   int iAvgSize[3];
   int iMaxQ1[3][2];
   int iMaxQE[3][2];
   int iMaxZ[3][2];
   int iOnes[3][2];
}ENC_STAT;

static ENC_STAT encStat;
ENC_STAT *pEncStat=&encStat;

void debugT(ENC_STAT *e, int k){
   return;
   void debugsi(char *c, int a);
#define DBG(_E)if(_E)debugsi((char*)#_E,_E);_E=0;
#define DBGX(_E)if(_E)debugsi((char*)#_E,_E);_E=0;
   debugsi("***k***",k);
//if(k)
   /*
DBGX(e->iMaxZ[k][0])
DBGX(e->iMaxQ1[k][0])
DBGX(e->iMaxQE[k][0])
DBGX(e->iMaxZ[k][1])
DBGX(e->iMaxQ1[k][1])
DBGX(e->iMaxQE[k][1])
DBGX(e->iOnes[k][1])
//return;
*/

   debugss("-------------",k,k);
   DBG(e->iSkip1[k])
   DBG(e->iSkip2[k])
   DBG(e->iSkip3[k])
   DBG(e->iSkipQ[k])
   DBG(e->iSkipLast[k])
   DBG(e->iSkipPsnr[k])
   if(e->iBlocksPicSent[k]|e->iBlocksDifSent[k]){
      int iAvgBits=e->iAvgSize[k]/(e->iBlocksPicSent[k]+e->iBlocksDifSent[k]);
      DBG(iAvgBits)
   }
   e->iAvgSize[k]=0;
   //DBG(e->iAvgSize[k])
   DBG(e->iBlocksDifSent[k])
   DBG(e->iBlocksPicSent[k])
}
static void putBl_4x4(short *bl,unsigned char *pCur, int stride){
   int  i;
   for(i=0;i<4;i++,pCur+=stride){
      pCur[0]=bl[0];bl++;
      pCur[3]=bl[0];bl++;
      pCur[6]=bl[0];bl++;
      pCur[9]=bl[0];bl++;
   }
}

void dbg_pic(TDCTX *ed, unsigned char *pCur, short *bl, int stride, int f, int k, int  iPic){
   //ed->copy_16_8(&sb[0],pCur+o+ofs+,stride);
   
   if(f){
      pCur+=(k?(-k+2):1);
      //ed->copy_16_8(bl,pCur+(k?(-k+2):1),stride);
      if(f&4)putBl_4x4(bl,pCur,stride);
      if(f&8)putBl_4x4(bl,pCur+12,stride);
      if(f&1)putBl_4x4(bl,pCur+4*stride,stride);
      if(f&2)putBl_4x4(bl,pCur+4*stride+12,stride);
   }
}

static int iResetCnt=1;
template  <int iDec, int iPic>
int encMB16_NonDif(ENC_BL_CTX *ctx, TDCTX *ed, unsigned char *pCur, unsigned char *pRef, int stride,int k,int  iIsB, int i_CanRestore, int &iIsBigCost, int iBestBits=0)
{
   //const int iPic=0;
   void t_idct8_s(DCT_TYPE *t, unsigned char *dst, int stride, int iX);
   void t_fdct8_s(unsigned char *src, int stride, DCT_TYPE *d );
   void t_fdct8_s_d(unsigned char *src,unsigned char *src2, int stride, DCT_TYPE *d );;
   void t_idct8_s_put(DCT_TYPE *t, unsigned char *dst, int stride);
   void fdct4x4dc_s( int *d);
   void idct4x4dc_s( int *d);

   int r01,r02,r03,r04;
   
   DCT_TYPE dct[4][64];
   DCT_TYPE q_dct[4][64];
   const int *t=k?&ed->tab_uv[128]:&ed->tab_y[128];
   int i;//,iDCQ;
   //int iHasDCs=0;
   //int dctDC[16];
   int t0=(t[0]>>2)*4;
   int t0Dec=t[0]>>2;
   int iDecFlags[4]={0xff,0xff,0xff,0xff};
/*
   iDCQ=(t[0]+ed->iDCQuant*5 +(t[1]>>3))>>3;
   if(iDCQ<4)iDCQ=4;else if(iDCQ>512)iDCQ=(iDCQ+512)>>1;

   const int t_dc[]={0,2,8,10};
   */
   const int t_ofs[]={0,24,stride*8,24+stride*8};

   const int  t_flag[]={0,0,0,0,ctx->j && ctx->i+16<ctx->w?MB_TOPRIGHT:0                     , ctx->j?MB_TOPLEFT:0,
                        ctx->i?(MB_TOPLEFT|MB_TOPRIGHT):MB_TOPRIGHT                    , MB_TOPLEFT};
   
   int iPredDC=0;
   int iFlag=0;
   int iPredValPrev=10;
   if(ctx->i+16<ctx->w && ctx->j)iFlag|=MB_TOPRIGHT;
   if(ctx->i && ctx->j)iFlag|=MB_TOPLEFT;
   int dctDC[4];
   
   if(iDec){
      for(i=0;i<4;i++){
         dctDC[3]=dctDC[2]=dctDC[1]=dctDC[0]=0;
         iPredValPrev=ed->vlc.getDC()+iPredValPrev;
         if(iPredValPrev>11 || iPredValPrev<0){debugss("err pred",i,iPredValPrev);return -5;}
         fncPred[iPredValPrev](pCur+t_ofs[i],stride,iFlag|t_flag[i]);

            int dcs=ed->vlc.getVlc();
            int dcso=dcs;
            for(int z=0;z<4 && dcs>0;z++){dctDC[z]=ed->vlc.getDC()*t0Dec;if(dctDC[z])dcs--;}

         if(ed->vlc.getB()){
            ed->dec4x_15<2>(&dct[i][0],k,t);
            //dct[i][0]=dct[i][16]=dct[i][32]=dct[i][48]=0;
            iDecFlags[i]=ed->iDecDct4x4;
           // ed->deQ4x4_Flag<1>(&q_dct[i][0],&dct[i][0],t,iDecFlags[i]);
          //  fncPred[iPredValPrev](pCur+t_ofs[i],stride,iFlag);
            //iDecFlags[i]=0;
         }
         else {iDecFlags[i]=0;iPredDC=0;}

         if(!ed->iVisDecoder && (iDecFlags[i] || dcso)){
            r01=dctDC[0];
            r02=dctDC[1];
            r03=dctDC[2];
            r04=dctDC[3];

            dct[i][0] = (r01 - r02 - r03 + r04);
            dct[i][16] = (r01 + r02 - r03 - r04);
            dct[i][32] = (r01 - r02 + r03 - r04);
            dct[i][48] = (r01 + r02 + r03 + r04);
            t_idct8_s(&dct[i][0],pCur+t_ofs[i],stride,iDecFlags[i]);
         }


      }
      if(ed->iVisDecoder){
         int o=((ctx->h-ctx->j-16)-ctx->j)*stride;
         
         int c=iPic?235:40;
         if(k==0)o++;
         for(i=0;i<16;i++){
            pCur[o+i*3+stride*k]=c;
            pCur[o+i*3+stride*15-stride*k]=c;
            pCur[o+i*stride+k*3]=c;
            pCur[o+15*3+i*stride-k*3]=c;
         }         
         return 0;
      }
   }
//repBestB:
   if(!iDec){
      dctDC[3]=dctDC[2]=dctDC[1]=dctDC[0]=0;
      
      T_ALIGN_64(unsigned char,saved,256);
      if(iBestBits)TDCTX::getBlock16(&saved[0],pCur,stride);
      
      int iBits=ed->vlc.iBitPos;
      int iPredVal,iSadPred,s;
      for(i=0;i<4;i++){
/*
         iPredVal=ed->findSetBestPred(NULL,pCur+t_ofs[i], pRef+t_ofs[i],stride, iFlag|t_flag[i]  ,iSadPred,iPredValPrev);
         ed->vlc.toDC(iPredVal-iPredValPrev);iPredValPrev=iPredVal;

         t_fdct8_s_d(pRef+t_ofs[i],pCur+t_ofs[i],stride,&dct[i][0]);


         s=ed->QTest<1>(&dct[i][0],t,0,k);
         if(s)s=ed->QFast<1>(&q_dct[i][0],&dct[i][0],t,64,0,k,0);
         */
         int iMinS=10000;
         int iBestPred=iPredValPrev;;
         int iMinPred=(iFlag|t_flag[i])?0:11;

         for(int z=0;z<24;z++){
            

             iPredVal=iPredValPrev+z;
             if(iPredVal>=iMinPred && iPredVal<=11){

                fncPred[iPredVal](pCur+t_ofs[i],stride,iFlag|t_flag[i]);
                s=sadF4x4_sq(pCur+t_ofs[i],pRef+t_ofs[i],stride,iMinS);
                if(s<iMinS)s+=sadF4x4_sq(pCur+t_ofs[i]+12,pRef+t_ofs[i]+12,stride,iMinS);
                if(s<iMinS)s+=sadF4x4_sq(pCur+t_ofs[i]+stride*4,pRef+t_ofs[i]+stride*4,stride,iMinS);
                if(s<iMinS)s+=sadF4x4_sq(pCur+t_ofs[i]+stride*4+12,pRef+t_ofs[i]+stride*4+12,stride,iMinS);
//                t_fdct8_s_d(pRef+t_ofs[i],pCur+t_ofs[i],stride,&dct[i][0]);
                //s=ed->QTest<0>(&dct[i][0],t,0,k);if(s)
  //                 s=ed->QFast<1>(&q_dct[i][0],&dct[i][0],t,64,0,k,0);
                if(s<iMinS){iBestPred=iPredVal;iMinS=s;if(!s)break;}
             }
             if(!z)continue;
             iPredVal=iPredValPrev-z;
             if(iPredVal>=iMinPred && iPredVal<=11){

                fncPred[iPredVal](pCur+t_ofs[i],stride,iFlag|t_flag[i]);
//                t_fdct8_s_d(pRef+t_ofs[i],pCur+t_ofs[i],stride,&dct[i][0]);
                //s=ed->QTest<0>(&dct[i][0],t,0,k);
                //if(s)
  //                 s=ed->QFast<1>(&q_dct[i][0],&dct[i][0],t,64,0,k,0);
                s=sadF4x4_sq(pCur+t_ofs[i],pRef+t_ofs[i],stride,iMinS);
                if(s<iMinS)s+=sadF4x4_sq(pCur+t_ofs[i]+12,pRef+t_ofs[i]+12,stride,iMinS);
                if(s<iMinS)s+=sadF4x4_sq(pCur+t_ofs[i]+stride*4,pRef+t_ofs[i]+stride*4,stride,iMinS);
                if(s<iMinS)s+=sadF4x4_sq(pCur+t_ofs[i]+stride*4+12,pRef+t_ofs[i]+stride*4+12,stride,iMinS);

                if(s<iMinS){iBestPred=iPredVal;iMinS=s;if(!s)break;}
             }
         }

         
         ed->vlc.toDC(iBestPred-iPredValPrev);iPredValPrev=iBestPred;
         fncPred[iBestPred](pCur+t_ofs[i],stride,iFlag|t_flag[i]);
         if(iMinS){
            t_fdct8_s_d(pRef+t_ofs[i],pCur+t_ofs[i],stride,&dct[i][0]);

      r01=dct[i][0];dct[i][0]=0;
      r02=dct[i][16];dct[i][16]=0;
      r03=dct[i][32];dct[i][32]=0;
      r04=dct[i][48];dct[i][48]=0;

      dctDC[0] = (+ r01 + r02 + r03 + r04) ;
      dctDC[1] = (- r01 + r02 - r03 + r04) ;
      dctDC[2] = (- r01 - r02 + r03 + r04) ;
      dctDC[3] = (+ r01 - r02 - r03 + r04) ;

            s=ed->QFast<1>(&q_dct[i][0],&dct[i][0],t,64,0,k,0);
         }
         else s=0;

         
         int dcs=0;
         for(int z=0;z<4;z++){
            if(dctDC[z]<0){dctDC[z]=-((-dctDC[z]+(t0>>1))/t0);}
            else if(dctDC[z]>0){dctDC[z]=(dctDC[z]+(t0>>1))/t0;}
            else continue;
            if(dctDC[z])dcs++;
         }

         int dcso=dcs;
         ed->vlc.toVLC(dcs);
         for(int z=0;z<4 && dcs>0;z++){ed->vlc.toDC(dctDC[z]);if(dctDC[z])dcs--;}


         if(s){
            ed->vlc.addB(1);
            ed->enc4x_15(&q_dct[i][0],0,k,iPic==0);
            iDecFlags[i]=ed->iDecDct4x4;
            q_dct[i][0]=q_dct[i][16]=q_dct[i][32]=q_dct[i][48]=0;
            ed->deQ4x4_Flag<1>(&q_dct[i][0],&dct[i][0],t,iDecFlags[i]);

          //  fncPred[iPredValPrev](pCur+t_ofs[i],stride,iFlag);
            //iDecFlags[i]=0;
         }
         else {ed->vlc.addB(0);iDecFlags[i]=0;iPredDC=0;}

         if(s || dcso){
            r01=dctDC[0]*t0Dec;
            r02=dctDC[1]*t0Dec;
            r03=dctDC[2]*t0Dec;
            r04=dctDC[3]*t0Dec;

            dct[i][0] = (r01 - r02 - r03 + r04);
            dct[i][16] = (r01 + r02 - r03 - r04);
            dct[i][32] = (r01 - r02 + r03 - r04);
            dct[i][48] = (r01 + r02 + r03 + r04);
            t_idct8_s(&dct[i][0],pCur+t_ofs[i],stride,iDecFlags[i]);
         }

         if(iBestBits && 15*(ed->vlc.iBitPos-iBits)>16*iBestBits+8){
            TDCTX::putBlock16(&saved[0],pCur,stride);
            return 0;
         }

//         dct[i][48]=dct[i][32]=dct[i][16]=dct[i][0]=0;


      }
      if(iBestBits){debugss("bbx",iBestBits,ed->vlc.iBitPos-iBits);}

   }
   if(1){
      int iFC=t[0]/5+2;
      //if(!(ctx->j|ctx->i))debugss("fc",t[0],t[1]);
      if(!(iDecFlags[0]|iDecFlags[1]|iDecFlags[2]|iDecFlags[3]) ){
         //void incBlock4x(unsigned char *pCur, int stride);
         //incBlock4x(pCur,stride);
          void filter_4x4_16_dc(unsigned char *p, int stride, int dc);
          filter_4x4_16_dc(pCur,  stride, iFC);//(iFC>>1)+1);

      }
      else{
         void filter_4x4_16_a(unsigned char *p, int stride, int a);
         if((iDecFlags[0]|iDecFlags[1]|iDecFlags[2]|iDecFlags[3])) filter_4x4_16_a(pCur,  stride, iFC);//t[1]>>4);//((iDCQ-12)>>3)
      }
      if(ed->iIsKey){
         void filter_16_top(unsigned char *p, int stride, int a);
         void filter_16_left(unsigned char *p, int stride, int a);
            if(ctx->j)filter_16_top(pCur,  stride, iFC);
            if(ctx->i)filter_16_left(pCur,  stride,iFC);
      }
   }

/*
   if(iHasDCs){
      for(i=0;i<16;i++)dctDC[i]=dctDC[i]*iDCQ;
      idct4x4dc_s(&dctDC[0]);

   }
   for(i=0;i<4;i++){
      dct[i][0]=dctDC[t_dc[i]+0];
      dct[i][16]=dctDC[t_dc[i]+1];
      dct[i][32]=dctDC[t_dc[i]+4];
      dct[i][48]=dctDC[t_dc[i]+5];

     t_idct8_s(&dct[i][0],pCur+t_ofs[i],stride,iDecFlags[i]);
   }
   
  */

   
   return 1;
}
#include "pred4.cpp"
#define T_4BB (ctx->j+16<ctx->h?T_4FB:0)
#define T_4RR (ctx->i+16<ctx->w?T_4FR:0)

int devPicPred(unsigned char *pCur, int x, int y, int w, int h, int stride, int *sadTab, int iLim){

   return 100000;
   typedef struct{
      int i;
      int j;
      int w;
      int h;
   }_XS;
   _XS xctx;
   xctx.i=x;
   xctx.j=y;
   _XS *ctx=&xctx;

   const int t_ofs4x4[]={
      0,12,24,36,
      0+stride*4,12+stride*4,24+stride*4,36+stride*4,
      0+stride*2*4,12+stride*2*4,24+stride*2*4,36+stride*2*4,
      0+stride*3*4,12+stride*3*4,24+stride*3*4,36+stride*3*4,
                        };
   const int str16=16;
   const int t_ofs4x4_2[]={
      0,4,8,12,
      0+str16*4,4+str16*4,8+str16*4,12+str16*4,
      0+str16*2*4,4+str16*2*4,8+str16*2*4,12+str16*2*4,
      0+str16*3*4,4+str16*3*4,8+str16*3*4,12+str16*3*4,
                        };
   int i;
   T_ALIGN_64(unsigned char,saved,256);
   TDCTX::getBlock16(&saved[0],pCur,stride);

   int iSad=200;
   int flags[16];
   int iFlag=0;
   if(ctx->i)iFlag|=T_4FL;
   if(ctx->j)iFlag|=T_4FT;
   for(i=0;i<16;i++){

      int iMinS=256*256*256;
      int iBestPred=_T_DC_128;;
      int ii=i;//s4x4[i];
      int f=iFlag;
      if(i>3)f|=T_4FT;
      if(i&3)f|=T_4FL;
      if(/*i<4 && */(T_4RR))f|=T_4FR;;
      if((i&3)<3)f|=T_4FR;
      if(((i&3)==0 && i<12))f|=T_4FB;
      if(i>11)f&=~T_4FB;
      if(i>4 && (i&3)==3)f&=~T_4FR;
      flags[i]=f;
      int ofs=t_ofs4x4[ii];

      for(int z=0;z<(f?(_T_DC_128-1):_T_DC_128) && iMinS;z++){
//19500 82k bus qcif
         if(fncPred4x4[z](pCur+ofs,stride,f)){
             int s=sadIntT(pCur+ofs,&saved[t_ofs4x4_2[ii]],stride,str16,sadTab);//;+(iPred==z?0:(t[0]>>1)));
             if(s<iMinS){iBestPred=z;iMinS=s;if(!s)break;}
         }
      }
      for(int z=0;z<4;z++){
         pCur[ofs+0+z*stride]=saved[t_ofs4x4_2[ii]+0+z*16];
         pCur[ofs+3+z*stride]=saved[t_ofs4x4_2[ii]+1+z*16];
         pCur[ofs+6+z*stride]=saved[t_ofs4x4_2[ii]+2+z*16];
         pCur[ofs+9+z*stride]=saved[t_ofs4x4_2[ii]+3+z*16];
      }
      iSad+=iMinS;
      if(iSad>iLim){iSad+=1000;break;}

   }

   ///TDCTX::putBlock16(&saved[0],pCur,stride);

   return iSad;
}
#if 1
template  <int iDec>
int encMB16_NonDif4x4(ENC_BL_CTX *ctx, TDCTX *ed, unsigned char *pCur, unsigned char *pRef, int stride,int k,int  iIsB, int i_CanRestore, int &iIsBigCost, int iBestBits=0, int iCalcOnly=0)
{
   //const int iPic=0;
   void t_fdct4_s_d(unsigned char *src,unsigned char *src2, int stride, DCT_TYPE *d );
   void t_idct4_s(DCT_TYPE *t, unsigned char *dst, int stride, int iX);
   
   DCT_TYPE dct[16][16];
   DCT_TYPE q_dct[16][16];
   const int *t=k?&ed->tab_uv[128]:&ed->tab_y[128];
   int i;//,iDCQ;


   const int t_ofs4x4[]={
      0,12,24,36,
      0+stride*4,12+stride*4,24+stride*4,36+stride*4,
      0+stride*2*4,12+stride*2*4,24+stride*2*4,36+stride*2*4,
      0+stride*3*4,12+stride*3*4,24+stride*3*4,36+stride*3*4,
                        };
                        
//if(ctx->i || ctx->j)return 0;   
   int iFlag=0;
   //if(ed->iIsKey)
   {
   if(ctx->i)iFlag|=T_4FL;
//   if(ctx->i+16<ctx->w)iFlag|=T_4FR;
   if(ctx->j)iFlag|=T_4FT;
   }
  // if(ctx->j+16<ctx->h)iFlag|=T_4FB;
   
   int iPredZ[]={
      0,0,0,0,
      0,0,0,0,
      0,0,0,0,
      0,0,0,0,
   };
   int iPredZB[]={
      0,0,0,0,
      0,0,0,0,
      0,0,0,0,
      0,0,0,0,
   };
   int iBlocks=0;
   //t[0]>32?2:
   const int iShDC=((t[0]>12?2:1));
   const int iShDCA=((t[0]>12?2:1));
#define T_DEF_PRED4x4 0 
   if(iDec){
      int iReadCoefs=ed->vlc.getB();
      int iPredAreZeros=0;
      int dcC[4];

      /*
      int r01=ed->vlc.getDC();;
      int r02=ed->vlc.getDC();;
      int r03=ed->vlc.getDC();;
      int r04=ed->vlc.getDC();;

      dcC[0] = (r01 - r02 - r03 + r04+1)>>1;
      dcC[1] = (r01 + r02 - r03 - r04+1)>>1;
      dcC[2] = (r01 - r02 + r03 - r04+1)>>1;
      dcC[3] = (r01 + r02 + r03 + r04+1)>>1;
*/
      for(i=0;i<4;i++){dcC[i]=ed->vlc.getAC();}
      if(!iReadCoefs){
         iPredAreZeros=ed->vlc.getB();
      }
 //     int iPredScMax=0;   int scR[16];
      for(i=0;i<16;i++){

         int ii=i;
         int iBestPred=_T_DC_128;;
         int f=iFlag;
         if(i>3)f|=T_4FT;
         if(i&3)f|=T_4FL;
         if(/*i<4 && */(T_4RR))f|=T_4FR;;
         if((i&3)<3)f|=T_4FR;
         if(((i&3)==0 && i<12))f|=T_4FB;
         if(i>11)f&=~T_4FB;
         if(i>4 && (i&3)==3)f&=~T_4FR;
//         if(i>3 && iPredZB[i-4])f|=T_TBIT;if((i&3)&& iPredZB[i-1])f|=T_LBIT;
            //t_flag[ii]|t_flag_b[ii]|t_flag_r[ii];
         int ofs=t_ofs4x4[ii];
         int iIsDC=(i==0 || i==10 || i==2 || i==8);

      
         int iPred=get4x4PicPred(f,i,&iPredZ[0]);
         if(iPredAreZeros)iBestPred=iPred;
         else{
            int bpp=ed->vlc.iBitPos;

            iBestPred=iPred?(ed->vlc.getAC()+iPred):ed->vlc.getVlc();
            /*
            iBitGainX1sc+=(ed->vlc.iBitPos-bpp);

            int findScoreFlagPredX4(int val, int tid);
            int sc=findScoreFlagPredX4(iBestPred,((i>3)?(iPredZ[i-4]+1):0)+((i&3)?(iPredZ[i-1]+1):0)*16);
            if(sc>iPredScMax)iPredScMax=sc;
            scR[i]=sc;
*/
         }
         iPredZ[i]=iBestPred;
         if(iBestPred>_T_DC_128 || iBestPred<0)return -1;
         //if(iBestPred==8 && (f&T_4FX) && !ed->iIsKey){}else
         if(!ed->iSkipPutBlocks)fncPred4x4[iBestPred](pCur+ofs,stride,f);
         q_dct[i][0]=0;
         //ed->vlc.toVLC(iBestPred);
int s=0;
         if(iReadCoefs)s=ed->dec4x1_deq<0>(&q_dct[i][iIsDC],0,k,16-iIsDC);;
         if(i==0)q_dct[i][0]=dcC[0];
         if(i==2)q_dct[i][0]=dcC[1];
         if(i==8)q_dct[i][0]=dcC[2];
         if(i==10)q_dct[i][0]=dcC[3];

         if(!s){
            if(q_dct[i][0]){s++;memset(&q_dct[i][1],0,15*2);}
         }
         if(!iReadCoefs && !s)continue;

         if(s){
            iPredZB[i]=1;
            iBlocks++;
            if(!ed->iSkipPutBlocks){
               ed->deQN<1>(&q_dct[i][0],&dct[i][0],t,iReadCoefs?16:1);
               if(dct[i][0] && (i==0 || i==10 || i==2 || i==8)){dct[i][0]+=(iShDCA);dct[i][0]>>=(iShDC);}
               t_idct4_s(&dct[i][0],pCur+ofs,stride,iReadCoefs);
            }
         }
      }
      if(ed->iVisDecoder){
         int o=((ctx->h-ctx->j-16)-ctx->j)*stride;
         
         int c=235;
         if(k==0)o++;
         for(i=0;i<16;i++){
            pCur[o+i*3+stride*k]=c;
            pCur[o+i*3+stride*15-stride*k]=c;
            pCur[o+i*stride+k*3]=c;
            pCur[o+15*3+i*stride-k*3]=c;
         }         
         return 0;
      }
      /*
      if(iPredScMax==0 || iBitGainX1sc==1){
         iBitGainX1sc-=16;
      }
      else if(iPredScMax==2){
         for(i=0;i<16;i++)iBitGainX1sc-=(scR[i]==0)?1:2;
      }
      else{
         for(i=0;i<16;i++)iBitGainX1sc-=ed->vlc.bitsLen[scR[i]];
      }
      */
   }
   
//repBestB:
   if(!iDec){
if(iBestBits && iBestBits<15)return 0;      
      T_ALIGN_64(unsigned char,saved,256);
      if(iBestBits)TDCTX::getBlock16(&saved[0],pCur,stride);
      int dcC[4]={0,0,0,0};
      int flags[16];

      
      int iBits=ed->vlc.iBitPos;
      ed->vlc.addB(1);//
      int iPredVal=0,iSadPred,s;
      int sums[16];
      for(i=0;i<16;i++){

         int iMinS=256*256*256;
         int iBestPred=_T_DC_128;;
         int ii=i;//s4x4[i];
         int f=iFlag;
         if(i>3)f|=T_4FT;
         if(i&3)f|=T_4FL;
         if(/*i<4 && */(T_4RR))f|=T_4FR;;
         if((i&3)<3)f|=T_4FR;
         if(((i&3)==0 && i<12))f|=T_4FB;
         if(i>11)f&=~T_4FB;
         if(i>4 && (i&3)==3)f&=~T_4FR;
         flags[i]=f;
            //t_flag[ii]|t_flag_b[ii]|t_flag_r[ii];
         int ofs=t_ofs4x4[ii];
         //if(i>3 && iPredZB[i-4])f|=T_TBIT;if((i&3)&& iPredZB[i-1])f|=T_LBIT;

         int iPred=get4x4PicPred(f,i,&iPredZ[0]);

         int iIsDC=(i==0 || i==10 || i==2 || i==8);
         
         if(0&&!ed->iIsKey && (f&T_4FX) && iBestBits<=0){
            t_fdct4_s_d(pRef+ofs,pCur+ofs,stride,&dct[i][0]);
            s=ed->QFast<2>(&q_dct[i][0],&dct[i][0],t,16,0,k,0);
            if(!s){iBestPred=8;iMinS=s;}

         }
         //int to=f?_T_DC_128:(1);
        // int iEmptyPred=0;
         int iBestLastQV=5;
         for(int z=-1;z<(f?(_T_DC_128-1):_T_DC_128) && iMinS;z++){
            if(z==iPred)continue;
            int iPrevZ=z;
            if(z==-1){z=iPred;}
//19500 82k bus qcif
            if(fncPred4x4[z](pCur+ofs,stride,f)){
               int iLastQV=1;
               /*
               if(z==iPred){
                  t_fdct4_s_d(pRef+ofs,pCur+ofs,stride,&dct[i][0]);
                  if(iIsDC)dct[i][0]<<=iShDC;
                  s=ed->QFast<1>(&q_dct[i][0],&dct[i][0],t,16,0,k,0);
                  if(!s){iBestPred=z;iMinS=s;break;}
               }
               */
               if(1){
                  int bpx=ed->vlc.iBitPos;
                  t_fdct4_s_d(pRef+ofs,pCur+ofs,stride,&dct[i][0]);
                  //dct[i][0]<<=1;
                 if(iIsDC)dct[i][0]<<=(iShDC);
                 //dct[i][0]<<=2;
                  s=ed->QFast<1>(&q_dct[i][0],&dct[i][0],t,16,0,k,0);
                 // dct[i][0]>>=2;
                  //int iPredtmp=get4x4PicPred(flags[i],i,&iPredZ[0]);
                  int v=z-iPred;
                  ed->vlc.iCalcBitsOnly=1;
                  /*
                  if(iIsDC){
                     ed->vlc.toDC(q_dct[i][0]);q_dct[i][0]=0;
                     if(s)s=notZerosF(&q_dct[i][0],1,16);
                  }
                  */
                  if(0&&v && s  && i>4  && i!=8 && i!=12){
                     ed->vlc.iBitPos+=400;
                     iLastQV=s;
                  }
                  else{
                     
                     if(iPred)ed->vlc.toAC(v);else ed->vlc.toVLC(v);
                     if(s){
                       // if(iIsDC)ed->vlc.iBitPos--;
//if(iIsDC)ed->vlc.toDC(q_dct[i][0]);
            
                        ed->enc1x_15_dif_dc<0,short>(ed->vlc,&q_dct[i][0],0,1);
                        //ed->enc4x1(ed->vlc,&q_dct[i][0],0,k,16);
                     }
                     else ed->vlc.iBitPos++;
                     iLastQV=s;
                  }
                  
                  ed->vlc.iCalcBitsOnly=0;
                  s=ed->vlc.iBitPos-bpx;
                  ed->vlc.iBitPos=bpx;
                  
                  s*=80;
                  if(s<iMinS+2000){
                     
                     int ii;
                     int dcS=0;
                     dcS=abs(dct[i][0]);
                     
                     static const int q_tx[]={
                        4,5,4,5,
                        5,6,5,6,
                        4,5,4,5,
                        5,6,5,6,
                        0,1,0,1,
                        1,2,1,2,
                        0,1,0,1,
                        1,2,1,2,
                     };
                     for(ii=1;ii<16;ii++){dcS+=(abs(dct[i][ii])>>q_tx[ii]);}
                     //s+=sadF4x4_sq(pCur+ofs,pRef+ofs,stride,iMinS+50);
                     s+=(dcS>>2);

                     
                     //s+=calcPicDev4(pCur+ofs,pRef+ofs,stride);
                     s+=abs(v);
                  }
                  
               }else{
                  iLastQV=1;
               
               
                   //s=sadF4x4_sq(pCur+ofs,pRef+ofs,stride,iMinS);//;+(iPred==z?0:(t[0]>>1)));
                   s=calcPicDev4(pCur+ofs,pRef+ofs,stride);//;+(iPred==z?0:(t[0]>>1)));

                   if(iPred!=z && s){
                      if(z && z!=3 && z!=5){s*=33;s>>=5;s+=12;}
                      else {s*=65;s>>=6;s+=4;}
                      if(_T_DC_128==4 && z)s+=60;
                      /*
                      if((i==1 || i==3 || i==9 ||i==11) && (z==4  || z==0))s+=((t[0]>>2)+4);
                      else if((i==4 || i==6 || i==12 ||i==14)&& (z==2  || z==0))s+=((t[0]>>2)+8);
                      else s+=(t[0]>>1);//s*=65;s>>=6;s+=3;
                      */
                   //if(z==0 || z>5){s*=65;s>>=6;}
                   }
                 }
               //if(z==9)s=0;
               if(s>=iMinS && (iLastQV==0 && iBestLastQV))s=iMinS-1;
                if(s<iMinS){iBestLastQV=iLastQV;iBestPred=z;iMinS=s;if(!s)break;}
            }
            z=iPrevZ;
         }
         //iMinS+=1;
         //iBestPred=8;
         if(0&&iBestPred==9 && (f&T_4FX) && !ed->iIsKey){}else
         fncPred4x4[iBestPred](pCur+ofs,stride,f);
         //for(int z=0;z<3;z++){ed->vlc.addB(iBestPred&(1<<z));}
        // ed->vlc.toAC(iBestPred-iPred);
         iPredZ[i]=iBestPred;
         if(iBestLastQV){
            
            t_fdct4_s_d(pRef+ofs,pCur+ofs,stride,&dct[i][0]);
            if(iIsDC)dct[i][0]<<=(iShDC);
            s=ed->QFast<1>(&q_dct[i][0],&dct[i][0],t,16,0,k,0);
         }
         else{ s=0;memset(&q_dct[i][0],0,2*16);}

         if(i==0)dcC[0]=q_dct[i][0];
         if(i==2)dcC[1]=q_dct[i][0];
         if(i==8)dcC[2]=q_dct[i][0];
         if(i==10)dcC[3]=q_dct[i][0];

         sums[i]=s;

         if(s){
            iBlocks++;
            iPredZB[i]=1; 

            ed->deQN<1>(&q_dct[i][0],&dct[i][0],t,16);
            if(iIsDC && dct[i][0]){q_dct[i][0]=0;
            dct[i][0]+=(iShDC);dct[i][0]>>=(iShDC);
            sums[i]=notZerosF(&q_dct[i][0],0,16);if(!sums[i])iBlocks--;iPredZB[i]=0;}
//            if(sums[i])t_idct4_s(&dct[i][0],pCur+ofs,stride,sums[i]>1?1:!q_dct[i][0]);
            t_idct4_s(&dct[i][0],pCur+ofs,stride,!!sums[i]);
         }
      //   else {ed->vlc.addB(1);}
/*
         if(iBestBits && ((ed->vlc.iBitPos-iBits)+(16-i))*15>16*iBestBits){
            TDCTX::putBlock16(&saved[0],pCur,stride);
            return 0;
         }
*/
//         dct[i][48]=dct[i][32]=dct[i][16]=dct[i][0]=0;


      }
      /*
      int dctDC[4];
      int r01=dcC[0];
      int r02=dcC[1];
      int r03=dcC[2];
      int r04=dcC[3];

      dctDC[0] = (+ r01 + r02 + r03 + r04+1)>>1 ;
      dctDC[1] = (- r01 + r02 - r03 + r04+1)>>1 ;
      dctDC[2] = (- r01 - r02 + r03 + r04+1)>>1 ;
      dctDC[3] = (+ r01 - r02 - r03 + r04+1)>>1 ;
*/
      if(iBlocks==0){
         ed->vlc.iBitPos=iBits;
         ed->vlc.addB(0);
         for(i=0;i<4;i++){
            ed->vlc.toAC(dcC[i]);
         }
         int bp=ed->vlc.iBitPos;
         ed->vlc.addB(0);
         int iPredAreZeros=1;

         for(i=0;i<16;i++){
            int iPred=get4x4PicPred(flags[i],i,&iPredZ[0]);
            int v=iPredZ[i]-iPred;
            if(iPred==0)ed->vlc.toVLC(v);else ed->vlc.toAC(v);
            if(v)iPredAreZeros=0;

         }
         if(iPredAreZeros){ed->vlc.iBitPos=bp;ed->vlc.addB(1);}
      }
      else{

         for(i=0;i<4;i++){
            ed->vlc.toAC(dcC[i]);
         }
         for(i=0;i<16;i++){
            int iIsDC=(i==0 || i==10 || i==2 || i==8);
            int iPred=get4x4PicPred(flags[i],i,&iPredZ[0]);
            int v=iPredZ[i]-iPred;
            if(iPred==0)ed->vlc.toVLC(v);else ed->vlc.toAC(v);
            if(sums[i]){
    
               ed->enc4x1(ed->vlc,&q_dct[i][iIsDC],0,k,16-iIsDC);

               //ed->vlcTest.iBitPos=0;
               //ed->enc1x_15_dif_dc<0,short>(ed->vlcTest,&q_dct[i][0],0,!iIsDC);
               //int nl=ed->vlcTest.iBitPos;iBitGainX1sc-=nl;iBitGainX1sc+=(ed->vlc.iBitPos-bpn);
            }
            else ed->vlc.addB(1);
         }

      }
      if(iBestBits 
         //&& ((ed->vlc.iBitPos-iBits))>iBestBits){
         && ((ed->vlc.iBitPos-iBits))*15>iBestBits*16){
         TDCTX::putBlock16(&saved[0],pCur,stride);
         return 0;
      }
      if(iBestBits || !ed->iIsKey){debugss("bbx",iBestBits,ed->vlc.iBitPos-iBits);}

   }
if(((!iDec  && !g_iSkipLoop)  || ed->iFilter) && t[0]>19  &&(iDec || !iIsB )){
      void filter_4x4_16_f(unsigned char *p, int stride, int a, int *f);
      void filter_4x4_16_dc(unsigned char *p, int stride, int dc);
      void filter_4x4_16_a(unsigned char *p, int stride, int a);
      void filter_16_top(unsigned char *p, int stride, int a);
      void filter_16_left(unsigned char *p, int stride, int a);
      void filter_4x4_16_a_dcf(unsigned char *p, int stride, int a, int *f, int *dc);
      //if(iFXTest)
      {//iFAll|iIsB|ed->iThisWasB){
        
         //--int iFC=(t[1]>>4)+(iDCQ>>5);
         //--
         //--
         int fs;
//         int iFC=_GET_FC(fs, t[1],(iDCQ>>iPic));//((iDCQ+20)>>5);+Pic jo bias lielaaks
   fs=setFTabA(t[0],1);//+(!!iPic)*(t[0]>>2));
         
         if(fs){
//                  iFC=((iDCQ<<(iPic && !ed->iIsKey))+t[1]+48)>>4;
                 // iFC=((iDCQ<<(!iPic))+t[1]+48)>>4;
           //321 int iFC=(t[0]*2+iDCQ*(1+(!iPic))+32+t[1]*2)>>5;//6+4+9
//            int iFC=(t[1]+t[0]+iDCQ*(1+(!iPic))+32)>>4;//6+4+9
            int iFC=((t[1]+t[0]*3+64)>>4);//6+4+9
            //if(!iDec && !(ctx->i && ctx->j) && !k && iHasDCs>1){debugsi("fs",fs);debugsi("a",iFC);}
                  //iFC=((iDCQ<<(!!iPic ))+t[1]+48)>>4;

         if(iFC>200)iFC=200;

           filter_4x4_16_a_dcf(pCur,  stride, iFC,NULL,NULL);
            
        //   fxMB(pCur,iFC>>1,stride);

         }
            
      }
   }


      if(!k){
         char *getDeblFlags(int iDecz, int w, int h);
         char *dbl=getDeblFlags(iDec,ctx->w,ctx->h);
         if(dbl){
            int xc=ctx->w>>4;
            int iPos2=(ctx->i>>4)+(ctx->j>>4)*xc;

            dbl[iPos2]&=~(32|16);

            dbl[iPos2]|=4|8;
            if(ctx->i+16<ctx->w)dbl[iPos2+1]|=8;
            dbl[iPos2+xc]|=4;
            
         }
      }
   
   return 1;
}
#endif


#if 0
#include "predL.cpp"

template  <int iDec, int iPic>
int encMB16_NonDifT3(ENC_BL_CTX *ctx, TDCTX *ed, unsigned char *pCur, unsigned char *pRef, int stride,int k,int  iIsB, int i_CanRestore, int &iIsBigCost, int iBestBits=0)
{
   //const int iPic=0;
   void t_idct8_s(DCT_TYPE *t, unsigned char *dst, int stride, int iX);
   void t_fdct8_s(unsigned char *src, int stride, DCT_TYPE *d );
   void t_fdct8_s_d(unsigned char *src,unsigned char *src2, int stride, DCT_TYPE *d );;
   void t_idct8_s_put(DCT_TYPE *t, unsigned char *dst, int stride);

   const int t_ofs_16[]={0,12,24,36,
                         stride*4,12+stride*4,24+stride*4,36+stride*4,
                         stride*8,12+stride*8,24+stride*8,36+stride*8,
                         stride*12,12+stride*12,24+stride*12,36+stride*12,
   };
   
   DCT_TYPE dct[16];
   DCT_TYPE q_dct[16];
   const int *t=k?&ed->tab_uv[128]:&ed->tab_y[128];
   int i,j;//,iDCQ;
   //int iHasDCs=0;
   //int dctDC[16];
   //int iDecFlags[4]={0xff,0xff,0xff,0xff};
   int iDecFlags=0;
   
   int iPredDC=0;
   int iFlag=0;
   int iPredValPrev=8;
   int iBlocksEnc16=0;
//   if(ed->iVisDecoder)pCur+=2;
   int iTL=0;
   if(iDec){

      for(i=0;i<16;i++){
         int o=t_ofs_16[i];
         int resH[]={0,0,0,0},resV[]={0,0,0,0,};
         int f=ctx->j|(i>3)?TOP_PX:0;
         if(ctx->i || (i&3)!=0)f|=LEFT_PX;
         
         if(!f ){
            iTL=TOP_PX;
            memset(pCur+o,128,4*3);
            memset(pCur+o,128,4*3);
            memset(pCur+o,128,4*3);
            memset(pCur+o,128,4*3);
            
         
         }else if(ed->vlc.getB()){
            iTL=TOP_PX;
            if(ctx->j || (i&3)!=3 || ctx->i+16<ctx->w)f|=TOP_R_PX;
            if((i&3)==0 && i!=12)f|=B_PX;
            if(ctx->j || ((i&3)!=3 && i>3))f|=TOP_R_PX;
            
//            ed->vlc.addB(1);
            for(j=0;j<4;j++)resV[j]=ed->vlc.getAC();
            predV(pCur+o,stride,f,&resV[0]);
         }
         else{
            iTL=LEFT_PX;
            if(ctx->j || (i&3)!=3 || ctx->i+16<ctx->w)f|=TOP_R_PX;
            if((i&3)==0 && i!=12)f|=B_PX;
            if(ctx->j || ((i&3)!=3 && i>3))f|=TOP_R_PX;
  //          ed->vlc.addB(0);
            for(j=0;j<4;j++)resH[j]=ed->vlc.getAC();
            predH(pCur+o,stride,f,&resH[0]);
         }

         if(ed->vlc.getB()){
            q_dct[0]=ed->vlc.getDC()+iPredDC;iPredDC=q_dct[0];
            iDecFlags=ed->dec4x1(&q_dct[0],1,k,16);
            if(iDecFlags)iBlocksEnc16++;

            ed->deQN<0>(&q_dct[0],&dct[0],t,16);

            void t_idct4_s(DCT_TYPE *t, unsigned char *dst, int stride, int iX);

            t_idct4_s(&dct[0],pCur+o,stride,iDecFlags);
         }
         else iPredDC=0;
         
      }
      //return 0;
      if(ed->iVisDecoder){
         short sb[64];
         memset(sb,150,128);
         int ofs;
         
         int o=((ctx->h-ctx->j-16)-ctx->j)*stride;
         int c=iPic?235:40;
         if(k==0)o++;
         for(i=0;i<16;i++){
            pCur[o+i*3+stride*k]=c;
            pCur[o+i*3+stride*15-stride*k]=c;
            pCur[o+i*stride+k*3]=c;
            pCur[o+15*3+i*stride-k*3]=c;
         }
         return 0;
      }
      
   }
//repBestB:
   if(!iDec){
      
      T_ALIGN_64(unsigned char,saved,256);
      if(iBestBits)TDCTX::getBlock16(&saved[0],pCur,stride);
      
      int iBits=ed->vlc.iBitPos;
      
      
      for(i=0;i<16;i++){
         int iBestSad=256*256*4,iSadPredV=256*256*4,iSadPredH=256*256*4,s;
         //void predV(unsigned char *cur,int stride, int f, int *fl);
         int o=t_ofs_16[i];
         int resH[]={0,0,0,0},resV[]={0,0,0,0,};
         int f=ctx->j|(i>3)?TOP_PX:0;
         if(ctx->i || (i&3)!=0)f|=LEFT_PX;
         if(!f ){
            iTL=TOP_PX;
            memset(pCur+o,128,4*3);
            memset(pCur+o,128,4*3);
            memset(pCur+o,128,4*3);
            memset(pCur+o,128,4*3);
            
         }
         else{
              iTL=0;
            if(ctx->j || (i&3)!=3 || ctx->i+16<ctx->w)f|=TOP_R_PX;
            if((i&3)==0 && i!=12)f|=B_PX;
            if(ctx->j || ((i&3)!=3 && i>3))f|=TOP_R_PX;

            if(f&TOP_PX)iSadPredV=sadPredV(pCur+o,pRef+o, stride,f, &resV[0], iBestSad);
            if(f&LEFT_PX)iSadPredH=sadPredH(pCur+o,pRef+o, stride,f, &resH[0], iSadPredV);
            

            if(iSadPredV<=iSadPredH){
               iTL=TOP_PX;
               ed->vlc.addB(1);
               for(j=0;j<4;j++)ed->vlc.toAC(resV[j]);
               predV(pCur+o,stride,f,&resV[0]);
            }
            else{
               iTL=LEFT_PX;
               ed->vlc.addB(0);
               for(j=0;j<4;j++)ed->vlc.toAC(resH[j]);
               predH(pCur+o,stride,f,&resH[0]);
            }
         }

         void t_fdct4_s_d(unsigned char *src,unsigned char *src2, int stride, DCT_TYPE *d );
         t_fdct4_s_d(pRef+o,pCur+o,stride,&dct[0]);

         s=ed->QTest<0>(&dct[0],t,0,0,16);
         if(s)s=ed->QFast<2>(&q_dct[0],&dct[0],t,16,0,k,0);
         

         if(s){
            
            ed->vlc.addB(1);
            ed->vlc.toDC(q_dct[0]-iPredDC); iPredDC=q_dct[0];

            iDecFlags=ed->enc4x1(&q_dct[0],1,k,16);

            if(iDecFlags)iBlocksEnc16++;

            ed->deQN<0>(&q_dct[0],&dct[0],t,16);

            void t_idct4_s(DCT_TYPE *t, unsigned char *dst, int stride, int iX);

            t_idct4_s(&dct[0],pCur+o,stride,iDecFlags);
         }
         else {ed->vlc.addB(0);iPredDC=0;}

         if(iBestBits && ed->vlc.iBitPos-iBits>iBestBits+12){
            TDCTX::putBlock16(&saved[0],pCur,stride);
            return 0;
         }



      }
      if(iBestBits){debugss("bbx",iBestBits,ed->vlc.iBitPos-iBits);}

   }
   if(1){
      int iFC=(((t[0]/5)+((t[1]*9)>>7)*2+2+(t[0]>>2))>>2);
      //if(!(ctx->j|ctx->i))debugss("fc",t[0],t[1]);
      if(!iBlocksEnc16){
         //void incBlock4x(unsigned char *pCur, int stride);
         //incBlock4x(pCur,stride);
          void filter_4x4_16_dc(unsigned char *p, int stride, int dc);
          filter_4x4_16_dc(pCur,  stride, iFC);//(iFC>>1)+1);

      }
      else{
         void filter_4x4_16_a(unsigned char *p, int stride, int a);
         filter_4x4_16_a(pCur,  stride, iFC);//t[1]>>4);//((iDCQ-12)>>3)
      }
      if(ed->iIsKey){
         void filter_16_top(unsigned char *p, int stride, int a);
         void filter_16_left(unsigned char *p, int stride, int a);
            if(ctx->j)filter_16_top(pCur,  stride, iFC);
            if(ctx->i)filter_16_left(pCur,  stride,iFC);
      }
   }

   
   return 1;
}
template <int iDec>
static void encDecPredN(CTVLCX *vlc, int *p ,int iCnt){
   int i;
   if(iDec){
      p[0]=vlc->getDC();
      if(vlc->getB()){
         for(i=1;i<iCnt;i++)p[i]=vlc->getAC();
      }
      else{
         for(i=1;i<iCnt;i++)p[i]=0;
      }
      return;
   }
   vlc->toDC(p[0]);
   int iCoefs=0;
   for(i=1;i<iCnt;i++)if(p[i]){iCoefs=1;break;}
   if(iCoefs){
      vlc->addB(1);
      for(i=1;i<iCnt;i++)vlc->toAC(p[i]);
   }
   else
      vlc->addB(0);
}

template  <int iDec, int iPic>
int encMB16_NonDifT2(ENC_BL_CTX *ctx, TDCTX *ed, unsigned char *pCur, unsigned char *pRef, int stride,int k,int  iIsB, int i_CanRestore, int &iIsBigCost, int iBestBits=0)
{
   //const int iPic=0;
   void t_idct8_s(DCT_TYPE *t, unsigned char *dst, int stride, int iX);
   void t_fdct8_s(unsigned char *src, int stride, DCT_TYPE *d );
   void t_fdct8_s_d(unsigned char *src,unsigned char *src2, int stride, DCT_TYPE *d );;
   void t_idct8_s_put(DCT_TYPE *t, unsigned char *dst, int stride);

   const int t_ofs[]={0,24,stride*8,24+stride*8};
   
   DCT_TYPE dct[4][64];
   DCT_TYPE q_dct[4][64];
   const int *t=k?&ed->tab_uv[128]:&ed->tab_y[128];
   int i,j;//,iDCQ;
   //int iHasDCs=0;
   //int dctDC[16];
   int iDecFlags[4]={0xff,0xff,0xff,0xff};
   
   int iPredDC=0;
   int iFlag=0;
   int iPredValPrev=8;
//   if(ed->iVisDecoder)pCur+=2;
   int iTL=0;
   
   if(iDec){
      for(i=0;i<4;i++){
         int o=t_ofs[i];
         int resH[]={0,0,0,0,0,0,0,0,},resV[]={0,0,0,0,0,0,0,0,};
         int f=ctx->j|(i>1)?TOP_PX:0;
         if(ctx->i || i==1 || i==3)f|=LEFT_PX;
         if(f)if(ctx->j && (i==0 || i==2 || (i==1 && ctx->i+16<ctx->w)))f|=R_PX;
         if(!f){
            iTL=TOP_PX;
            //if(!i)ed->vlc.addB(1);
            memset(pCur+o,128,8*3);
            memset(pCur+o,128,8*3);
            memset(pCur+o,128,8*3);
            memset(pCur+o,128,8*3);

            memset(pCur+o,128,8*3);
            memset(pCur+o,128,8*3);
            memset(pCur+o,128,8*3);
            memset(pCur+o,128,8*3);
         }else if(ed->vlc.getB()){
            iTL=TOP_PX;
            if(i==0)f|=B_PX;
            if(ctx->j || i==2)f|=TOP_R_PX;
            
//            ed->vlc.addB(1);
            encDecPredN<iDec>(&ed->vlc,&resV[0],8);
            //for(j=0;j<8;j++)resV[j]=ed->vlc.getAC();
            predV(pCur+o,stride,f,&resV[0]);
            
    //char bb[128];sprintf(&bb[0],"%3d,%3d,%3d,%3d,%3d,%3d,%3d,%3d,",resV[0],resV[1],resV[2],resV[3],resV[4+0],resV[4+1],resV[4+2],resV[4+3]); 
        //   debugss(&bb[0],0,TOP_PX);
         }
         else{

            if(ctx->j || i==2)f|=TOP_R_PX;
            iTL=LEFT_PX;
            if(i==0)f|=B_PX;
  //          for(j=0;j<8;j++)resH[j]=ed->vlc.getAC();
            encDecPredN<iDec>(&ed->vlc,&resH[0],8);
            predH(pCur+o,stride,f,&resH[0]);
    //char bb[128]; sprintf(&bb[0],"%3d,%3d,%3d,%3d,%3d,%3d,%3d,%3d,",resH[0],resH[1],resH[2],resH[3],resH[4+0],resH[4+1],resH[4+2],resH[4+3]); 
        //       debugss(&bb[0],0,LEFT_PX);
         }

         if(ed->vlc.getB()){
            short savedDC[4];
            iPredDC=0;
            savedDC[0]=ed->vlc.getDC()+iPredDC;iPredDC=savedDC[0];
            savedDC[1]=ed->vlc.getDC()+iPredDC;iPredDC=savedDC[1];
            savedDC[2]=ed->vlc.getDC()+iPredDC;iPredDC=savedDC[2];
            savedDC[3]=ed->vlc.getDC()+iPredDC;iPredDC=savedDC[3];
            //int iCoefs=0;
            ed->dec4x_15<0>(&q_dct[i][0],k);
            iDecFlags[i]=ed->iDecDct4x4;
            ed->deQ4x4_Flag<1>(&q_dct[i][0],&dct[i][0],t,iDecFlags[i]);

            dct[i][0]= (savedDC[0]*t[0]);//+1)>>1;
            dct[i][16]=(savedDC[1]*t[0]);//+1)>>1;
            dct[i][32]=(savedDC[2]*t[0]);//+1)>>1;
            dct[i][48]=(savedDC[3]*t[0]);//+1)>>1;
          //  fncPred[iPredValPrev](pCur+t_ofs[i],stride,iFlag);
            //iDecFlags[i]=0;
            if(ed->iVisDecoder){
                if(iDecFlags[i])t_idct8_s(&dct[i][0],pCur+t_ofs[i],stride,iDecFlags[i]);
               iDecFlags[i]=0;

            }
             else
                t_idct8_s(&dct[i][0],pCur+t_ofs[i],stride,iDecFlags[i]);
         }
         else {iDecFlags[i]=0;}

      }
      //return 0;
      if(ed->iVisDecoder){
         short sb[64];
         memset(sb,150,128);
         int ofs;
         
         int o=((ctx->h-ctx->j-16)-ctx->j)*stride;
         int blo=iDecFlags[0]|iDecFlags[3]|iDecFlags[2]|iDecFlags[1];
         if(blo){
            ofs=0;
            dbg_pic(ed,pCur+o+ofs,&sb[0],stride,iDecFlags[2],k,iPic);
            ofs=24;
            dbg_pic(ed,pCur+o+ofs,&sb[0],stride,iDecFlags[3],k,iPic);
            ofs=stride*8;
            dbg_pic(ed,pCur+o+ofs,&sb[0],stride,iDecFlags[0],k,iPic);
            ofs=stride*8+24;
            dbg_pic(ed,pCur+o+ofs,&sb[0],stride,iDecFlags[1],k,iPic);
         }
         int c=iPic?235:40;
         if(k==0)o++;
         for(i=0;i<16;i++){
            pCur[o+i*3+stride*k]=c;
            pCur[o+i*3+stride*15-stride*k]=c;
            pCur[o+i*stride+k*3]=c;
            pCur[o+15*3+i*stride-k*3]=c;
         }         
         if(!k){//!blo || iPic){
               char bb[128];
               short *d;
               d=&dct[0][0];sprintf(&bb[0]," %3d,%3d,%3d,%3d,",d[0],d[16],d[32],d[48]); if(iPic)bb[0]='(';debugss(&bb[0],k,t[0]);
               d=&dct[1][0];sprintf(&bb[0]," %3d,%3d,%3d,%3d,",d[0],d[16],d[32],d[48]); if(iPic)bb[0]='(';debugss(&bb[0],k,t[0]);
               d=&dct[2][0];sprintf(&bb[0]," %3d,%3d,%3d,%3d,",d[0],d[16],d[32],d[48]); if(iPic)bb[0]='(';debugss(&bb[0],k,t[0]);
               d=&dct[3][0];sprintf(&bb[0]," %3d,%3d,%3d,%3d,",d[0],d[16],d[32],d[48]); if(iPic)bb[0]='(';debugss(&bb[0],k,t[0]);

         }
         return 0;
      }
   }
//repBestB:
   if(!iDec){
      
      T_ALIGN_64(unsigned char,saved,256);
      if(iBestBits)TDCTX::getBlock16(&saved[0],pCur,stride);
      
      int iBits=ed->vlc.iBitPos;
      
      
      for(i=0;i<4;i++){
         int iBestSad=256*256*32,iSadPredV=256*256*32,iSadPredH=256*256*32,s;
         //void predV(unsigned char *cur,int stride, int f, int *fl);
         int o=t_ofs[i];
         int resH[]={0,0,0,0,0,0,0,0,},resV[]={0,0,0,0,0,0,0,0,};
         int f=ctx->j|(i>1)?TOP_PX:0;
         if(ctx->i || i==1 || i==3)f|=LEFT_PX;
         if(ctx->j || i==2)f|=TOP_R_PX;

         if(!f ){
            iTL=TOP_PX;
            //if(!i)ed->vlc.addB(1);
            memset(pCur+o,128,8*3);
            memset(pCur+o,128,8*3);
            memset(pCur+o,128,8*3);
            memset(pCur+o,128,8*3);

            memset(pCur+o,128,8*3);
            memset(pCur+o,128,8*3);
            memset(pCur+o,128,8*3);
            memset(pCur+o,128,8*3);
            
         }
         else{
            iTL=0;
            if(i==0)f|=B_PX;

            if(ctx->j && (i==0 || i==2 || (i==1 && ctx->i+16<ctx->w)))f|=R_PX;
            if(f&TOP_PX)iSadPredV=sadPredV(pCur+o,pRef+o, stride,f, &resV[0], iBestSad);
            if(f&LEFT_PX)iSadPredH=sadPredH(pCur+o,pRef+o, stride,f, &resH[0], iSadPredV);
            

            if(iSadPredV<=iSadPredH){
               iTL=TOP_PX;
               ed->vlc.addB(1);
               encDecPredN<iDec>(&ed->vlc,&resV[0],8);
               predV(pCur+o,stride,f,&resV[0]);
               //for(j=0;j<8;j++)ed->vlc.toAC(resV[j]);
            }
            else{
               iTL=LEFT_PX;
               ed->vlc.addB(0);
               encDecPredN<iDec>(&ed->vlc,&resH[0],8);
               predH(pCur+o,stride,f,&resH[0]);
            //   for(j=0;j<8;j++)ed->vlc.toAC(resH[j]);
            }
         }

         t_fdct8_s_d(pRef+o,pCur+o,stride,&dct[i][0]);
//dct[i][0]*=2;dct[i][16]*=2;dct[i][32]*=2;dct[i][48]*=2;
         s=ed->QFast<1>(&q_dct[i][0],&dct[i][0],t,64,0,k,0);
         short savedDC[4]={0,0,0,0};


         if(s){
            iPredDC=0;
            ed->vlc.addB(1);
            ed->vlc.toDC(q_dct[i][0]-iPredDC); savedDC[0]=q_dct[i][0]; iPredDC=savedDC[0];
            ed->vlc.toDC(q_dct[i][16]-iPredDC);savedDC[1]=q_dct[i][16];iPredDC=savedDC[1];
            ed->vlc.toDC(q_dct[i][32]-iPredDC);savedDC[2]=q_dct[i][32];iPredDC=savedDC[2];
            ed->vlc.toDC(q_dct[i][48]-iPredDC);savedDC[3]=q_dct[i][48];iPredDC=savedDC[3];
            ed->enc4x_15(&q_dct[i][0],0,k,iPic==0);
            iDecFlags[i]=ed->iDecDct4x4;
            ed->deQ4x4_Flag<1>(&q_dct[i][0],&dct[i][0],t,iDecFlags[i]);

            dct[i][0]= (savedDC[0]*t[0]);//+1)>>1;
            dct[i][16]=(savedDC[1]*t[0]);//+1)>>1;
            dct[i][32]=(savedDC[2]*t[0]);//+1)>>1;
            dct[i][48]=(savedDC[3]*t[0]);//+1)>>1;

            t_idct8_s(&dct[i][0],pCur+o,stride,iDecFlags[i]);
         }
         else {ed->vlc.addB(0);iDecFlags[i]=0;}

         if(iBestBits && ed->vlc.iBitPos-iBits>iBestBits-15){
            TDCTX::putBlock16(&saved[0],pCur,stride);
            return 0;
         }



      }
      if(iBestBits){debugss("bbx",iBestBits,ed->vlc.iBitPos-iBits);}

   }
   if(1){
      int iFC=(((t[0]/5)+((t[1]*9)>>7)*2+2+(t[0]>>2))>>2);
      //if(!(ctx->j|ctx->i))debugss("fc",t[0],t[1]);
      if(!(iDecFlags[0]|iDecFlags[1]|iDecFlags[2]|iDecFlags[3]) ){
         //void incBlock4x(unsigned char *pCur, int stride);
         //incBlock4x(pCur,stride);
          void filter_4x4_16_dc(unsigned char *p, int stride, int dc);
          filter_4x4_16_dc(pCur,  stride, iFC);//(iFC>>1)+1);

      }
      else{
         void filter_4x4_16_a(unsigned char *p, int stride, int a);
         if((iDecFlags[0]|iDecFlags[1]|iDecFlags[2]|iDecFlags[3])) filter_4x4_16_a(pCur,  stride, iFC);//t[1]>>4);//((iDCQ-12)>>3)
      }
      if(ed->iIsKey){
         void filter_16_top(unsigned char *p, int stride, int a);
         void filter_16_left(unsigned char *p, int stride, int a);
            if(ctx->j)filter_16_top(pCur,  stride, iFC);
            if(ctx->i)filter_16_left(pCur,  stride,iFC);
      }
   }

/*
   if(iHasDCs){
      for(i=0;i<16;i++)dctDC[i]=dctDC[i]*iDCQ;
      idct4x4dc_s(&dctDC[0]);

   }
   for(i=0;i<4;i++){
      dct[i][0]=dctDC[t_dc[i]+0];
      dct[i][16]=dctDC[t_dc[i]+1];
      dct[i][32]=dctDC[t_dc[i]+4];
      dct[i][48]=dctDC[t_dc[i]+5];

     t_idct8_s(&dct[i][0],pCur+t_ofs[i],stride,iDecFlags[i]);
   }
   
  */

   
   return 1;
}

#endif
#if 1
void loadPred16(){loadPred4x4();}
#else

#include "pred.inl"
#define T_USE_PRED16
template  <int iDec>
int pred16Key(ENC_BL_CTX *ctx, TDCTX *ed, unsigned char *pCur, unsigned char *pRef, int stride){

   int F=(ctx->i?1:0)|(ctx->j?2:0);
   int iBestID=0;
      int iSad=-1;
      int iBest=0xffffff;
   if(!iDec){
      int i;
      
      for(i=0;i<7;i++){
         if(fncPred16[i](pCur,stride,F)){
            //iSad=sadInt(pCur,pRef,stride,iBest)+ed->vlc.bitsLen[i]*10;
            int encCalcBitsMB16(ENC_BL_CTX *ctx, TDCTX *ed,unsigned char *pCur, unsigned char *pRef, int stride,int k,int  iIsB);
            iSad=encCalcBitsMB16(ctx,ed,pCur,pRef,stride,0,0);
            //if(!i || iSad<iBest)iSad+=encCalcBitsMB16(ctx,ed,pCur+1,pRef+1,stride,1,0);
            //if(!i || iSad<iBest)iSad+=encCalcBitsMB16(ctx,ed,pCur+2,pRef+2,stride,2,0);
            if(!i || iSad<iBest){
               iBestID=i;
               iBest=iSad;
               if(!iSad)break;
            }
         }
      }
      fncPred16[iBestID](pCur,stride,F);
      ed->vlc.toVLC(iBestID);
   }
   else{
      iBestID=ed->vlc.getVlc();
      fncPred16[iBestID](pCur,stride,F);
   }
   return iBest;
}

#endif

template<int iPic>
static int checkDCCoefs(int  *block,int *c, int q, int iCnt, int t0, int t1){

   //return iCnt;////69340,66KB
   if((iCnt==1 ||(iCnt==2 && c[0]))&& (c[8] || c[2] || c[1] || c[4]))return iCnt;
   //if(iPic)return iCnt;
   void idct4x4dc_s(int *c);
   int i;
   int d[16];
   int dcBl=0;
   //q*=2;
   for(i=0;i<16;i++){
      //if(i && mmabs(c[i])>(2-iPic))return iCnt;
      d[i]=c[i];
      dcBl+=block[i];
   }
   int dc=d[0];
   if(1){//69340,66KB
      //if(iPic)return  iCnt;
      dcBl=(dcBl+8)>>4;d[0]=0;
//q>>=1;
      
      idct4x4dc_s(&d[0]);for(i=0;i<16;i++){d[i]*=q;d[i]+=4;d[i]>>=3;}
      int iErrSum=0;
      int iErrSQ=0;
      int iNotDctSum=0;
      int iNotDctSQ=0;

      for(i=0;i<16;i++){
         int dif=d[i]-(block[i]-dcBl);
         int difN=(block[i]-dcBl);
         dif+=8;dif>>=4;difN+=8;difN>>=4;
         iErrSum+=mmabs(dif);
         iErrSQ+=dif*dif;
         iNotDctSum+=mmabs(difN);
         iNotDctSQ+=difN*difN;
       //  if(d[i]>iLim || d[i]<-iLim)return iCnt;
      }
      //debugss("t0,q",t0,q);debugss("errs-sum",iErrSum,iNotDctSum);debugss("errs-sq",iErrSQ,iNotDctSQ);
      //memset(&c[1],0,15*sizeof(int));
      //return c[0]?1:0;
      //---if(iErrSum*3<iNotDctSum )return iCnt;
      //if(iErrSum<iNotDctSum && iErrSQ<iNotDctSQ)return iCnt;
      
      if(iErrSum*6<iNotDctSum*5  && iErrSQ*6<iNotDctSQ*5)return iCnt;
      //if(iErrSum*5<iNotDctSum*4  && iErrSQ*5<iNotDctSQ*4)return iCnt;
      /*
      if((iErrSQ*4<iNotDctSQ || iErrSum*5<iNotDctSum*2) && iErrSum*7<iNotDctSum*4 && iErrSQ*3<iNotDctSQ){
         if(iErrSum*14<iNotDctSum*10 && iErrSQ*2<iNotDctSQ)return iCnt;
         if(iErrSum*4<iNotDctSum*3 && iErrSQ*3<iNotDctSQ)return iCnt;
         if(iErrSQ*4<iNotDctSQ && iErrSum*10<iNotDctSum*9)return iCnt;
         if(iErrSQ*3<iNotDctSQ  && iErrSum*8<iNotDctSum*7)return iCnt;
         if((iErrSQ*2<iNotDctSQ && iErrSQ+12000<iNotDctSQ) && iErrSum*5<iNotDctSum*4)return iCnt;

         if(iErrSum*4<iNotDctSum*3 && iErrSQ*2<iNotDctSQ){
            if(iErrSum*3<iNotDctSum*2)return iCnt;
            if(iErrSQ*3<iNotDctSQ)return iCnt;
         }
         if(iErrSQ*8<iNotDctSQ*3 && iErrSum*2<iNotDctSum)return iCnt;
      }
      */
      
      //debugss("t0,q",t0,q);debugss("errs-sum",iErrSum,iNotDctSum);debugss("errs-sq",iErrSQ,iNotDctSQ);
      memset(&c[1],0,15*sizeof(int));
      return c[0]?1:0;
   }

   
   d[0]=0;

   
   int iLim=(t0*3);//(t1*(4+iPic))>>5;
   if(iLim>40)iLim=40;
   else if(iLim<8)iLim=8;
   int iLimAvg=(t0+8)>>4;
   if(iLimAvg>5)iLimAvg=5;

   int iBigCoefs=0;
   idct4x4dc_s(&d[0]);
   int avg[5];
   
   int iLimAvg3=(iLimAvg+2)/3;
   int iLimAvg2=(iLimAvg*3+2)>>2;

   avg[0]=(d[0]+d[1]+d[4]+d[5]+32)>>6;
   avg[1]=(d[2]+d[3]+d[6]+d[7]+32)>>6;
   avg[2]=(d[8]+d[9]+d[12]+d[13]+32)>>6;
   avg[3]=(d[10]+d[11]+d[14]+d[15]+32)>>6;
   avg[4]=(d[5]+d[6]+d[9]+d[10]+32)>>6;
   
   if(
        mmabs(avg[0])>iLimAvg3 || mmabs(avg[1])>iLimAvg3 || mmabs(avg[2])>iLimAvg3 || mmabs(avg[3])>iLimAvg3 || 

         mmabs(avg[0]-avg[2])>iLimAvg || mmabs(avg[0]-avg[1])>iLimAvg || mmabs(avg[0]-avg[3])>iLimAvg
      || mmabs(avg[1]-avg[3])>iLimAvg || mmabs(avg[1]-avg[2])>iLimAvg 
      || mmabs(avg[2]-avg[3])>iLimAvg
//      || mmabs(avg[4]-avg[0])>iLimAvg || mmabs(avg[4]-avg[1])>iLimAvg || mmabs(avg[4]-avg[2])>iLimAvg || mmabs(avg[4]-avg[3])>iLimAvg
      || mmabs(avg[4]-avg[0])>iLimAvg2 || mmabs(avg[4]-avg[1])>iLimAvg2 || mmabs(avg[4]-avg[2])>iLimAvg2 || mmabs(avg[4]-avg[3])>iLimAvg2
      //|| mmabs(avg[4]-d[0]/4)>iLimAvg || mmabs(avg[4]-d[3]/4)>iLimAvg || mmabs(avg[4]-d[12]/4)>iLimAvg || mmabs(avg[4]-d[15]/4)>iLimAvg
      ){
      return iCnt;
   }
   else{
      memset(&c[1],0,15*sizeof(int));
      return c[0]?1:0;
      //if(!iPic){if(dc>-11 && dc<11)c[0]=0;iCnt=0;}else iCnt=1;
      //return iCnt;
      
   }
   
   for(i=0;i<16;i++){if(d[i]>iLim || d[i]<-iLim){iBigCoefs++;}}
   if(iBigCoefs<3){
      memset(&c[1],0,15*sizeof(int));
      debugss("cnt",iCnt,t0);
      //if(!iPic){if(dc>-11 && dc<11)c[0]=0;iCnt=0;}else iCnt=1;
      return c[0]?1:0;
      
   }


   return iCnt;
}
template<int iPic>
static int encDC(TDCTX *ed, int iHasDCs, int *dctDC,int k){
   int iCanSkip=1;
   //int dcs=iHasDCs;
  /*
   int iDiv=0;
   if(iHasDCs && iPic){
      int vMa=0,vMi=10000;
      for(int i=0;i<16;i++){
         int v=dctDC[i];
         if(v && i){
            if(v<0)v=-v;
            if(v>vMa){vMa=v;}
            if(v<vMi)vMi=v;
         }
      }
      if(vMi*8<=vMa){
         iDiv=1;
         for(int i=i;i<16;i++){if(dctDC[i]==-1 || dctDC[i]==1){iHasDCs--;dctDC[i]=0;}}
      }
  //    ed->vlc.toVLC(iDiv);
   }
   */
 
   if(1||iPic || k)ed->vlc.toDC((k?UV_DC_DEF:10)-iHasDCs);else ed->vlc.toVLC(iHasDCs);
   
   
   int iPrevVal=k?8:28;
   //int iPrevVal=iPic?(k?8:28):0;

   //static int of[16];
   /*
   if(1){
   static int cntDc=0;
   cntDc++;
   if((cntDc&1023)==0){
      for(int i=0;i<16;i++){debugss("dcx",of[i],i);}

   }
   }
   */
   
   for(int i=0;i<16 && iHasDCs>0;i++){
      //if(iDiv && i){dctDC[tabzz4x4[i]]/=iDiv;dctDC[tabzz4x4[i]]*=iDiv;}
      int val=dctDC[tabzz4x4[i]];
      //if(iDiv && i){dctDC[tabzz4x4[i]]*=iDiv;}
      
      if(val)
      {
    //     if(i<8)iCanSkip=0;
         //if(i && !iPic && !k){of[mmabs(val)>15?15:mmabs(val)]++;}else 
        // if(i && iPic && !k){of[i]++;}
         if(iPrevVal>24)ed->vlc.toL_Val_S(val,4);
         else if(iPrevVal>12)ed->vlc.toL_Val_S(val,3);
         else if(iPrevVal>4)ed->vlc.toL_Val_S(val,2);
         else  ed->vlc.toAC(val);

         iPrevVal=val;
         if(iPrevVal<0)iPrevVal=-iPrevVal;
         if(iPrevVal>1)iCanSkip=0;
         iHasDCs--;
      }
      else ed->vlc.addB(1);
      
   }
   return 0;//iCanSkip;
}

static void encZero2b_unsign(CTVLCX &vlc, int val){
   if(val==0){vlc.addB(1); vlc.addB(1);return;}
   else if(val==1){vlc.addB(0); vlc.addB(0); }
   else if(val==2){vlc.addB(0); vlc.addB(1); }
   else {vlc.addB(1); vlc.addB(0); vlc.toVLC(val-3);}
}


static void encZero3b(CTVLCX &vlc, int val,int &tmp){
   /*
000
1s
1s
01s
0010s
001010s
001011s
   */
   
   if(val==0){vlc.addB(0); vlc.addB(0);vlc.addB(0);return;}
   else if(val==1){vlc.addB(1); vlc.addB(0); }
   else if(val==-1){vlc.addB(1); vlc.addB(1); }
   else if(val==2){vlc.addB(0);vlc.addB(1); vlc.addB(0); }
   else if(val==-2){vlc.addB(0);vlc.addB(1); vlc.addB(1); }
   else {vlc.addB(0); vlc.addB(0); vlc.addB(1); if(val>0){vlc.addB(0);vlc.toVLC(val-3);}else {vlc.addB(1);vlc.toVLC(-val-3);}}
   
   tmp--;
return ;
}
int findScoreFlag_DC(int val, int tid);
int decScoreFlag_DC(int val, int tid);


#define DC_SC_MAX 7
template<int iPic>
int encDCF(TDCTX *ed, CTVLCX &vlc, int *dctDC, int k, int f){

   int edc=dctDC[0];
   if(iPic)edc-=ed->iPredDC;
   int abs_dc0=abs(edc);
   int eDCV=abs_dc0;

   if(eDCV>DC_SC_MAX)eDCV=DC_SC_MAX;

  int dcq=!k?ed->iDCQuant:ed->iDCQuantUV;
  int fl2b=(dcq+64)>>7; if(fl2b>3)fl2b=3;

  int ev=(eDCV*64+f);
  int sc2=findScoreFlag_DC(ev,((!!iPic)+((!k)<<1))+(fl2b<<2));
//  f=decScoreFlag_DC(sc2,((!!iPic)+((!k)<<1))+(fl2b<<2));

  if(k)vlc.toVLC(sc2);else vlc.toVLC_PN(sc2,3-fl2b);//vlc.toVLC_X(sc2,((12-(int)log((double)ed->iDCQuant))>>2)+1);
  if(eDCV==DC_SC_MAX)vlc.toVLC_PN(abs_dc0-DC_SC_MAX,4);
  if(edc)vlc.addB(edc<0);
  if(iPic)ed->iPredDC=dctDC[0];

  if((f&16)==0)return 0;
  ed->enc1x_15_dif_dc<1>(vlc,dctDC,iPic,f&31);
  return 0;
}
template<int iPic>
int decDCF(TDCTX *ed, CTVLCX &vlc, int *dctDC, int &iDCS,int k, int &f){

   //int edc=dctDC[0];
   //if(iPic)edc-=ed->iPredDC;
   //int eDCV=abs(edc);

   //if(eDCV>DC_SC_MAX)eDCV=DC_SC_MAX;

   iDCS=0;
  
  int dcq=!k?ed->iDCQuant:ed->iDCQuantUV;
  int fl2b=(dcq+64)>>7; if(fl2b>3)fl2b=3;

  

//  int dv=k?vlc.getVlc():vlc.getVlc_PN(2-(dcq>250)+(dcq<60));
  int dv=k?vlc.getVlc():vlc.getVlc_PN(3-fl2b);
  int iTabID=((!!iPic)+((!k)<<1))+(fl2b<<2);
  f=decScoreFlag_DC(dv,iTabID);
  
//  f=sc2&63;
  int eDCV=f>>6;
  
  if(eDCV==DC_SC_MAX)dctDC[0]=DC_SC_MAX+vlc.getVlc_PN(4);else dctDC[0]=eDCV;

  if(dctDC[0]){
     if(vlc.getB())dctDC[0]=-dctDC[0];
  }
  if(iPic){dctDC[0]+=ed->iPredDC;ed->iPredDC=dctDC[0];}
  iDCS=!!dctDC[0];

  static int iBEF[]={
      0,1,1,2,
      1,2,2,3,
      1,2,2,3,
      2,3,3,4,
   };
   ed->iAllBlocks=ed->iBlocks8orMore=0;
   ed->iBlocksED=iBEF[f&15];
  if(f&32)ed->iBlocks8orMore=1;
  
  f&=63;
  if((f&16)==0){memset(&dctDC[1],0,15*sizeof(int));return 0;}


int iBP=vlc.iBitPos;
  ed->dec1x_15_dif_dc<0,1>(vlc,dctDC,iPic,f&31);

  //int dccnt=0;for(int i=0;i<16;i++)if(dctDC[i])dccnt++;
     

  
 // addRacValP(dccnt,iTabID*2+1);
  if(iPic){
  //iBitGainX1sc+=(vlc.iBitPos-iBP);
  //ed->encTestBlQ<1,int>(&dctDC[0],NULL);
  }
  
  iDCS++;
  f&=~16;
  return 0;
}

#if 0
template<int iPic>
static int encDC_dcF(TDCTX *ed, CTVLCX &vlc, int iHasDCs, int *dctDC,int k,int f, int sc, int predf){

   //CTVLCX &vlc=ed->vlc;
//  int iPrevVal=k?8:28;
   ///static int iPrevDC=0;
   int dc0=dctDC[0];
  // int iCanSkip=!dc0;
//int findScoreFlag_DC(int val, int tid)
/*   
   if(1){//(f&16)==0 && (k?ed->tab_uv[128]:ed->tab_y[128])<80){
      dc0*=((k?ed->tab_uv[128]:ed->tab_y[128])*2);
      dc0+=64;dc0>>=7;if(ed->iIsB)dc0>>=1;

   }
   */


   int edc=dc0;
   
   if(iPic)edc-=ed->iPredDC;
   /*
   vlc.toVLC(sc);
   //ed->vlc.bitsLen[sc]
   //if(iPic && !k)vlc.toL_Val_S(dc0,3);else if(iPic)vlc.toDC(dc0);else vlc.toAC(dc0);
   if(!iPic && !f)CTVLCX::encZero2b(vlc,f==0 && edc>0?(edc-1):edc);else 
   if((!iPic && f))vlc.toAC(edc);else //-(iPic?ed->iPredDC:0)
   if(iPic && !f){
      vlc.toAC(edc);
   }
   else if(iPic)CTVLCX::encZero2b(vlc,edc);else CTVLCX::encZero2b(vlc,f==0 && dc0>0?(dc0-1):dc0);
   //else if(iPic)vlc.toDC(dc0-ed->iPredDC);else CTVLCX::encZero2b(vlc,f==0 && dc0>0?(dc0-1):dc0);
   //else if(iPic)vlc.toVLC_X(dc0-ed->iPredDC,2);else CTVLCX::encZero2b(vlc,f==0 && dc0>0?(dc0-1):dc0);
   //else if(iPic)vlc.toDC(dc0-ed->iPredDC);else encZero2b(vlc,dc0);
//   dctDC[0]=dc0*128;
  // if(ed->iIsB)dctDC[0]*=2;
  */
   if(1){
//  vlc.iBitPos=0;
  
   int abs_dc0=abs(edc);
   int eDCV=abs_dc0;
#define DC_SC_MAX 7
  if(eDCV>DC_SC_MAX)eDCV=DC_SC_MAX;
  //static int iPredx=4;
//  if(eDCV>2)eDCV=2;
  //int fl2b=((ed->tab_y[128]>40))+((ed->tab_y[128]>140)<<1);

  int dcq=!k?ed->iDCQuant:ed->iDCQuantUV;
//  if(dcq>160)fl2b=1+(dcq>320)*2;
 // else if(dcq>96)fl2b=1;
 // else if(dcq<32)fl2b=2;
  int fl2b=(dcq+64)>>7; if(fl2b>3)fl2b=3;
  //f<<=1;f|=ed->iHasBigCoefs;
//-*2+ed->iHasBigCoefs
  
  int sc2=findScoreFlag_DC((eDCV*64+f),((!!iPic)+((!k)<<1))+(fl2b<<2));//+iPredx*4);//+predf*4
  //iPredx=((f&16)==0)+(((f&15)?2:0));
  //debugsi("sc2",((!!iPic)+((!k)<<1)));
//*2+(edc<0)
  if(k)vlc.toVLC(sc2);else vlc.toVLC_PN(sc2,3-fl2b);//vlc.toVLC_X(sc2,((12-(int)log((double)ed->iDCQuant))>>2)+1);
  if(eDCV==DC_SC_MAX)vlc.toVLC_PN(abs_dc0-DC_SC_MAX,4);//2+(iPic && !ed->iIsKey));
//  if(eDCV>1)vlc.toVLC(abs_dc0-2);//2+(iPic && !ed->iIsKey));
  if(edc)vlc.addB(edc<0);
   }
  if(iPic)ed->iPredDC=dctDC[0];

  if((f&16)==0)return 0;
//inline int enc1x_15_pic_new_last_one(T *v, int k, int iAdd, CTVLCX *pvlc, int *iCoefsLeft=NULL, int j=NULL)
 // ed->enc1x_15_pic_new_last_one<1,int>(&dctDC[0],k,!iPic,&vlc);  return 0;
//  vlc.toVLC_PN(iHasDCs-1,1);ed->enc4x1<int>(vlc,&dctDC[0],1,k,16,iHasDCs);  return 0;
//  ed->enc1x4x15Ta<1,int,0>(&dctDC[0],iPic,k,vlc);      return 0;
 // ed->enc1x4x15TX<1,int,0>(&dctDC[0],iPic,k,vlc);      return 0;
  //if(iPic)
     //ed->enc1x4x15TX<1,int,0>(&dctDC[0],iPic,k,vlc);
 // else
// if(iPic) ed->enc1x_15_pic_new_last_one<1,int>(&dctDC[0],k,!iPic,&vlc); else
  ed->enc1x_15_dif_dc<1,int>(vlc,&dctDC[0],iPic,f&31);
  
     return 0;
  if(dc0)iHasDCs--;

  //static int e_dc[]={15,14,13,12,10,8,6,4,2,0,1,3,5,7,9,11};
  //static int e_dc[]={14,13,11,9,7,6,5,4,2,0,1,3,8,10,12,15};
  //static int e_dc[]={0,1,2,9,14,13,7,6,5,4,3,8,10,12,15};
  //0,6,4,5, 8,9,11,10, 2,1,3,7 ,12,13,14,15};
  //int getLen2x_test(int v);
      int L=16;
      //vlctab=tab[f][log(ed->tab_y[129]>>3)*2];
int bpBL=vlc.iBitPos;
int code=0;
//if(k)vlc.toVLC_PN(iHasDCs-1,2);else vlc.toVLC_PN(iHasDCs-1,3);
//vlc.toVLC(iHasDCs-1);
   if(k)TDCTX::enc_coef_m15(vlc,iHasDCs-1);else vlc.toVLC_PN(iHasDCs-1,1);//vlc.iBitPos+=4;   if(iHasDCs==1)vlc.iBitPos--;//1110
   // ////TDCTX::enc_coef_m15(vlc,e_dc[iHasDCs-1]);//vlc.toDC(9-iHasDCs);
   
//_ENC_D_CODE(iHasDCs-1);
//xxxx
  

   int bp=vlc.iBitPos;
   
   int iDCSum=0;
   int tmp=iHasDCs;
   int rep=1;
   int iPrevVal;
   int b1=1000;
   int b2=0;
   int iMaxDC=0;
repf1:
   vlc.iBitPos=bp;
  
   tmp=iHasDCs;
   //iPrevVal>>=1;
void debugsi(char *c, int a);
   //int iAddIf15=iHasDCs==15;
int iDbg=0;
   if(1){
      
         iPrevVal=dctDC[0];
      //else iPrevVal=(iHasDCs>2?3:2);//dctDC[0];
      if(iPrevVal<0)iPrevVal=-iPrevVal;
      //if(k)iPrevVal=1;
      b1=0;
     // int iWasZ=0;
   /*
   if(!k && iHasDCs>10 &&0){
      iDbg=1;
char bufD[64];
for(int i=0;i<16;i+=4){
   sprintf(bufD,"%3d,%3d,%3d,%3d",dctDC[i+0],dctDC[i+1],dctDC[i+2],dctDC[i+3]);   
   debugsi(bufD,k);
}
   }
   */
      
     if(iHasDCs>1 && iHasDCs!=15)vlc.addB(0);
     for(int i=1;i<16  && tmp>0;i++){
         int val=dctDC[tabzz4x4[i]];
         if(val)code|=(1<<i);
//if(val && i<8)iCanSkip=0;

         if(0&&iHasDCs>8){//   && (iPrevVal>5 || (iPrevVal>2 && iHasDCs>=14))){
            val=val>=0?(val<<1):(((-val)<<1)-1);
            
            if(tmp+i>=16)val--;//nav 0

               //int ba=coefSZ[iPic][k][i]<8?0:(coefSZ[iPic][k][i]<24?1:(coefSZ[iPic][k][i]<80?2:3));
            int ba=2;
            int r=iPrevVal;//coefSZ[iPic][k][i];
            while(r>12-(tmp>>2)){ba++;r>>=3;}
            if(tmp*2+i>=14 ){//|| tmp+i>=16 || i<iFirstZero
               vlc.toVLC_PN(val,ba);
            }
            else
              vlc.toVLC_PNZ(val,ba);//4232
         
            val=dctDC[tabzz4x4[i]];
            if(val){
               
               tmp--;
            iPrevVal=val;
            if(iPrevVal<0)iPrevVal=-iPrevVal;
            if(iPrevVal>iMaxDC)iMaxDC=iPrevVal;
            }
            //if(val)coefSZ[iPic][k][i]=(coefSZ[iPic][k][i]+abs(val)+1)>>1;
            continue;
         }
         //if(val)coefSZ[iPic][k][i]=(coefSZ[iPic][k][i]+abs(val)+1)>>1;
         if(val && tmp+i>=16){
            CTVLCX::encNonZero(vlc,val);
          //  vlc.toVLC_PN((val>=0?(val<<1):(((-val)<<1)-1))-1,(int)log((double)(iPrevVal+2)));
//            vlc.toVLC_PN((val>=0?(val<<1):(((-val)<<1)-1))-1,(int)log((double)(iPrevVal+2)));
            iPrevVal=val;
            if(iPrevVal<0)iPrevVal=-iPrevVal;
            if(iPrevVal>iMaxDC)iMaxDC=iPrevVal;
            tmp--;
            continue;
         }//((code&2) && (tabzz4x4[i]<4)) || ((code&4) && (tabzz4x4[i]&3)==0)|| 
//vlc.iBitPos--;

         if(POSIB_2Z(tmp,16)){//((iPrevVal<3 && tmp*7>(16-i)*3) || tmp*2+i>=14)){// && iPrevVal<9){
            CTVLCX::encZero2b(vlc,val);
            
            if(val){
               tmp--;
               iPrevVal=val;
               if(iPrevVal<0)iPrevVal=-iPrevVal;
               if(iPrevVal>iMaxDC)iMaxDC=iPrevVal;
            }
            //else iWasZ=1;
            continue;
         }

         if(val)
         {/*
            if(iPrevVal>24)vlc.toL_Val_S(val,4);
            else if(iPrevVal>12)vlc.toL_Val_S(val,3);
            else if(iPrevVal>4)vlc.toL_Val_S(val,2);
            else */ //if(i<8)vlc.toDC(val);else 
            vlc.toAC(val);
            
            //vlc.toVLC_PNZ((val>=0?(val<<1):(((-val)<<1)-1)),(int)log((double)(iPrevVal+2)));

            iPrevVal=val;
            if(iPrevVal<0)iPrevVal=-iPrevVal;
            
            if(iPrevVal>iMaxDC)iMaxDC=iPrevVal;
            tmp--;
         }
         else vlc.addB(1);
      }
if(iDbg)debugsi("bp",vlc.iBitPos-bp);
//if(iAddIf15)vlc.iBitPos-=15;
      if(iHasDCs<2 || rep==2 || iMaxDC>1 || iHasDCs==15)return 1;// || iMaxDC>2

      b1=vlc.iBitPos-bp;
      vlc.iBitPos=bp;
      vlc.addB(1);
   }
   /*
   if(0){
      vlc.iBitPos=bpBL;
      //vlc.addB(1);
      int getDifCodeOnes(int val);
      int sc=getDifCodeOnes((code>>1));
      if(sc<16)sc++;
      _ENC_D_CODE(sc);//TODO 2x

      vlc.iBitPos+=iHasDCs;
      return 1;
   }
   */
   
//repf2:
   tmp=iHasDCs;
/*

   int valb[3];;
   {
      if(iHasDCs<7){
         valb[0]=1;
         valb[1]=valb[2]=iHasDCs==15?2:3;
      }
      else{
         valb[1]=valb[0]=2;
         valb[2]=iHasDCs==15?2:3;
      }
   
   }
   
   int iZeroBits,iValBits;
   if(iHasDCs<7){iZeroBits=1;iValBits=2;}
   else {iZeroBits=2;iValBits=1;}
   // 0 10s 110s 1110s
   // 11 0s 101s 1011s
*/
   for(int i=1;i<16 && tmp>0;i++){
      int val=dctDC[tabzz4x4[i]];
         if(val)
         {
             //vlc.toAC(val);
            //0s
            //if(val<0){val=-val;}
            vlc.iBitPos+=(tmp+i==16?1:2);//val+2;//
                      //valb[val];//abs(val)+valb;
            tmp--;
         }
         else {vlc.iBitPos++;continue;}
      
      
  }
   if(iDbg)debugsi("bp 2   ",vlc.iBitPos-bp);
   /*
  if(rep==1){
     //if(iAddIf15)vlc.iBitPos-=15;
     b2=vlc.iBitPos-bp;
   //debugss("b1 b2",b1,b2);
     if(b1<b2){rep=2;goto repf1;}
  }
  */
   

   return 1;
}
#endif

template <int TO, int STEP>
static int analizeSkipL(unsigned char *pCur, unsigned char *pRef, const int stride ,int iDCQ){

//   return 0;
	int i, j;

 //  iDCQ>>=5;iDCQ++;

   int ec=0;

	for (j = 0; j < 16; j++) {

      for (i = 0; i < TO; i+=STEP){
         const int pic=pRef[i];
         const int d=mmabs((int)pCur[i]-pic);
         if(d<=1)continue; 

         const int L=pRef[i-STEP];
         const int R=pRef[i+STEP];
         const int B=pRef[i+stride];
         const int T=pRef[i-stride];

         const int L1=mmabs(L-pic);
         const int L2=mmabs(R-pic);
         const int L3=mmabs(B-pic);
         const int L4=mmabs(T-pic);
         int m1=max(L1,L2);
         int m2=max(L3,L4);
         int m=max(m1,m2);m++;
         
         if(d*2>m+iDCQ){
            ec+=10;
            if(ec>19)return 0;
            if(d>m+iDCQ)return 0;
            //if(d>m*2+iDCQ)return 0;
         }
      }
      if(ec>3)ec-=3;
      pCur+=stride;pRef+=stride;
   }
   return 1;
}
static int analizeSkip(unsigned char *pCur, unsigned char *pRef, const int stride ,int iDCQ){
   //return  0;
   if(iDCQ<=1)return 0;
   return analizeSkipL<48,3>(pCur,pRef,stride,iDCQ);
}

template <int TO, int STEP>
static int analizeSkipLN(unsigned char *pCur, unsigned char *pRef, const int stride ,int iDCQ){

//   return 0;
	int i, j;


	for (j = 0; j < 16; j++) {

      for (i = 0; i < TO; i+=STEP){
         const int pic=pRef[i];
         const int d=abs((int)pCur[i]-pic);
         if(d<=1)continue; 

         const int T=pRef[i-stride];
         const int R=pRef[i+STEP];
         /*
         const int B=pRef[i+stride];
         const int L=pRef[i-STEP];

         const int L1=abs(L-pic);
         const int L2=abs(R-pic);
         const int L3=abs(B-pic);
         const int L4=abs(T-pic);
         const int m1=min(L1,L2);
         const int m2=min(L3,L4);
         */
         const int X=pRef[i+stride-STEP];

         const int L2=abs(R-pic);
         const int L3=abs(X-pic);
         const int L4=abs(T-pic);
         const int m1=min(L3,L2);
         int m=min(m1,L4);m++;
         
         if(d*2>m+iDCQ){
            return 0;
            //if(d>m*2+iDCQ)return 0;
         }
      }
      pCur+=stride;pRef+=stride;
   }
   return 1;
}
static int analizeSkipN(unsigned char *pCur, unsigned char *pRef, const int stride ,int iDCQ){
   //return  0;
   if(iDCQ<=1)return 0;
   return analizeSkipLN<48,3>(pCur,pRef,stride,iDCQ);
}
int analizeSkip1(unsigned char *pCur, unsigned char *pRef, const int stride ,int iDCQ){
   return analizeSkipL<16,1>(pCur,pRef,stride,iDCQ);
}
static int *SADT=NULL;
void setSADTab(int *p){
   SADT=p;
}

void t_idct8_s_put_f(DCT_TYPE *t, unsigned char *dst, int stride, int iX);

#ifdef _WIN32
static int blockQ(unsigned char *cur, unsigned char *ref, int stride){

	int i, j;
   static int difs[512];
   static int *absdh=NULL;
   if(!absdh){
      //--absdh=&difs[256];
      //--for(i=0;i<256;i++)absdh[i]=absdh[-i]=i>>1;
      absdh=&difs[0];
      for(i=0;i<512;i++)absdh[i]=i>>1;
   }
   int iSQErr=0;
   

	for (j = 0; j < 16; j++) {

      for (i = 0; i < 48; i+=3){
         const int pic=ref[i];

         const int L=ref[i-3];
         const int R=ref[i+3];
         const int B=ref[i+stride];
         const int T=ref[i-stride];
         const int L1=absdh[L+pic];
         const int L2=absdh[R+pic];
         const int L3=absdh[B+pic];
         const int L4=absdh[T+pic];
         const int mP=(L1+L2+L3+L4+2)>>2;
         /*
         int d1=mP-cur[i];
         int d2=pic-cur[i];
         d1*=d1;d2*=d2;
         const int d=min(d1,d2);
         */
         int d1=mP-pic;
         int d2=pic-cur[i];
         d1*=d1;d2*=d2;
         int d=d2-d1;
         if(d<0)d=0;
         iSQErr+=d;
         
         //iRes += mP;//(tabSADM[pic-mP]);
         //iRes += (tabSADM[pic-mP]);
      }
		cur += stride;
      ref+=stride;

	}
   int getPSNRFromSQ(int iSq, int cnt);
   if(iSQErr==0)return 10000;
   if(iSQErr==1)return 8000;
	return getPSNRFromSQ(iSQErr,256);
}
#else
static int blockQ(unsigned char *cur, unsigned char *ref, int stride){return 0;}
#endif
static int g_iDeblock=0;
static int iBitsG=0;
static int iFXTest=0;
static int iIsUDP=1;
void setDeblTest(int f){iFXTest=f;}
void setUDPTest(int f){iIsUDP=f;}
int isUDPTest(){return iIsUDP;}
static int calcDCfromUL(unsigned char *pCur, int x, int y,int iDCQ,  const int stride){
   int i;
   int iPDC=0;

   if(y){
      for(i=0;i<48;i+=3){iPDC+=pCur[i-stride];}
      iPDC-=128*16;
   }
   if(x){
      for(i=0;i<16;i++){iPDC+=pCur[stride*i-3];}
      iPDC-=128*16;
   }
   if(x|y){
      iPDC=(iPDC+((!!x)+(!!y)))>>(((!!x)+(!!y)));
      iPDC=((((iPDC)))*32);
      //if(iPDC<0)iPDC-=(iDCQ>>1);else iPDC+=(iDCQ>>1);
      iPDC/=iDCQ;
   }
   return iPDC;
}

void t_fdct_2x2_8_s_d(unsigned char *src,unsigned char *src2, int stride, DCT_TYPE *d );
void t_idct_2x2_8_s_d(DCT_TYPE *d, unsigned char *dst, int stride, int iX );

int Q2x2(TDCTX *ed, DCT_TYPE *d,DCT_TYPE *q_dct, int iCnt, int *q){
   int i,sum=0;
   const int t1=q[0];//>>2;
   const int t2=q[1];//>>2;
   const int t3=q[3];//>>2;
   const int qt1=(t1>>2)+1;//>>2;
   const int qt2=(t2>>2)+1;//>>2;
   const int qt3=(t3>>2)+1;//>>2;
#define T_Q2x2(_O,_Q,_QA)if(d[_O]<0){q_dct[_O]=(d[_O]-_QA)/_Q;if(q_dct[_O])sum++;}else if(d[_O]>0){q_dct[_O]=(d[_O]+_QA)/_Q;if(q_dct[_O])sum++;}else q_dct[_O]=0;
   //#define T_Q2x2(_O,_Q,_QA)if((unsigned)(d[_O]+_QA)>_Q){q_dct[_O]=(d[_O]-_QA)/_Q;if(q_dct[_O])sum++;}else q_dct[_O]=0;
   for(i=0;i<iCnt;i++){
      T_Q2x2(i,t1,qt1);i++;
      T_Q2x2(i,t2,qt2);i++;
      T_Q2x2(i,t2,qt2);i++;
      T_Q2x2(i,t3,qt3);
   }
#undef T_Q2x2
   return sum;
}
int deQ2x2(TDCTX *ed, DCT_TYPE *d,DCT_TYPE *q_dct, int iCnt, int *q){
   int i,sum=0;
   const int t1=q[0];
   const int t2=q[1];
   const int t3=q[3];
   for(i=0;i<iCnt;i++){
      d[i]=q_dct[i]*t1;i++;
      d[i]=q_dct[i]*t2;i++;
      d[i]=q_dct[i]*t2;i++;
      d[i]=q_dct[i]*t3;;
   }
   return sum;
}
#ifdef _MSC_VER
#define DECLARE_ALIGNED( var, n ) __declspec(align(n)) var
#else
#define DECLARE_ALIGNED( var, n ) var __attribute__((aligned(n)))
#endif   

template <int iDec>
int encMB16_ok_2x2(ENC_BL_CTX *ctx, TDCTX *ed, unsigned char *pCur, unsigned char *pRef, int stride,int k,int &iIsBigCost){
   DECLARE_ALIGNED(DCT_TYPE dct[4][64],16);
   DECLARE_ALIGNED(DCT_TYPE q_dct[4][64],16);

   const int *t=k?&ed->tab_uv[128]:&ed->tab_y[128];
   int i;
   int sums[4];
   int f[4]={0,0,0,0};
   int q[4];
   /*
   const int t1=((t[0]*8+1)>>4);
   const int t2=((t[0]*6+1)>>4);
   const int t3=((t[0]*6+1)>>4);
   */
   //452+302
   int iBitPos=ed->vlc.iBitPos;
   int t0=(((t[1]>>1)+t[0])*41)>>6;if(t0<24){t0+=24;t0>>=1;}t0+=4;//t0+=12;
   
   const int t1=((t0*9+1)>>5);
   const int t2=((t0*7+1)>>5);
   const int t3=((t0*7+1)>>5);
//   const int t1=((t0*9+1)>>5);
  // const int t2=((t0*7+1)>>5);
   //const int t3=((t0*7+1)>>5);
   /*
   const int t1=4;//((t0*9+1)>>5);
   const int t2=1;//((t0*7+1)>>5);
   const int t3=1;//((t0*7+1)>>5);
   */


   const int f1=t2;//(t2*3)>>1;
   const int f2=((t3>>3)+2);
   int e=0;

   q[0]=t1;q[1]=t2;q[2]=t2;q[3]=t3;

   if(!iDec){// && !iPic && !k && !ed->iIsB){
      int m=2;
      int iHada=-1;
      getMBParamHada(ctx->i>>3, ctx->j>>3, k, ctx->w,iHada);
      if(iHada==0){
         ctx->mb->col[k].iSkip=MB16_2::eSkipQ;
         pEncStat->iSkipQ[k]++;
         return 0;
      }
      getMBParamMode(ctx->i>>3, ctx->j>>3, k, ctx->w,m);
      iIsBigCost=(m==0);
   }

   void t_filter2x2(unsigned char *dst, int stride, int iX, int a, int b);
   
   if(!iDec){
      
      t_fdct_2x2_8_s_d(pRef,pCur,stride,&dct[0][0]);
      t_fdct_2x2_8_s_d(pRef+24,pCur+24,stride,&dct[1][0]);
      t_fdct_2x2_8_s_d(pRef+stride*8,pCur+stride*8,stride,&dct[2][0]);
      t_fdct_2x2_8_s_d(pRef+24+stride*8,pCur+24+stride*8,stride,&dct[3][0]);
      for(i=0;i<4;i++){
         sums[i]=Q2x2(ed,&dct[i][0],&q_dct[i][0],64,&q[0]);
         if(sums[i]){
            e=1;
            ed->vlc.addB(1);
            f[i]=ed->enc2xT(&q_dct[i][0]);
            if(!ed->vlc.iCalcBitsOnly){
               //f[i]&=~(2<<16);
               deQ2x2(ed,&dct[i][0],&q_dct[i][0],64,&q[0]);
               t_idct_2x2_8_s_d(&dct[i][0],pCur+(i&1)*24+(i>1)*8*stride,stride,f[i]<<6);
               if(t2>3)t_filter2x2(pCur+(i&1)*24+(i>1)*8*stride,stride,f[i],f1,f2);
            }
         }
         else ed->vlc.addB(0);
      }
      
   }
   else{
      
      for(i=0;i<4;i++){
         if(ed->vlc.getB()){
            e=1;
            f[i]=ed->dec2xT(&dct[i][0],&q[0]);
         //   deQ2x2(ed,&q_dct[i][0],&dct[i][0],64);
            //f[i]&=
            if(!ed->iSkipPutBlocks){
               t_idct_2x2_8_s_d(&dct[i][0],pCur+(i&1)*24+(i>1)*8*stride,stride,f[i]<<6);
               if(t2>3)t_filter2x2(pCur+(i&1)*24+(i>1)*8*stride,stride,f[i],f1,f2);
            }
         }
      }
      if(ed->iVisDecoder){

         
         int o=((ctx->h-ctx->j-16)-ctx->j)*stride;
         int c=188,c2=240;;
         if(k==0)o++;
         for(i=0;i<16;i++){
            pCur[o+i*3+stride*k]=c;
            pCur[o+i*3+stride*15-stride*k]=c;
            pCur[o+i*stride+k*3]=c;
            pCur[o+15*3+i*stride-k*3]=c;

            pCur[o+i*3+stride*k+1]=c2;
            pCur[o+i*3+stride*15-stride*k+1]=c2;
            pCur[o+i*stride+k*3+1]=c2;
            pCur[o+15*3+i*stride-k*3+1]=c2;
         }
#if !defined(_WIN32_WCE) && !defined(__SYMBIAN32__) && !defined(ARM) && !defined(ANDROID_NDK) && !defined(__APPLE__)
         void debugIntValue(int v, unsigned char *p, int stride);
         debugIntValue(ed->vlc.iBitPos-iBitPos,pCur+stride*2+o+4,stride);
#endif
      }
   }
   return e;
}

int getBlockPSNR_SQ_F(unsigned char *p ,unsigned char *o, int stride, int step, int &iDif, int &f, const int iLim);
#if 0
def __SYMBIAN32__
int useFastBlockType(){return 1;}
#else
int useFastBlockType();
#endif


#ifdef _TEST_T_BITS
      //static int iG[32*(16<<2)];//(1 2 4 8) 16
      //static int i_m_cbp[32*(1<<(2+6))];
      static int iPrevF_16;
      static int iPrevIJ_16;//=(ctx->i*(1<<15))|(ctx->j);
      static int iPrevIsPic_16;
#endif
/*
#ifdef T_USE_PRED16
      r=encMB16_ok<iDec,iPic>(ctx,ed,pCur+1,pRef+1,stride,k+1,iIsB,i_CanRestore, iIsBigCost, iBestBits);
      r=encMB16_ok<iDec,iPic>(ctx,ed,pCur+2,pRef+2,stride,k+2,iIsB,i_CanRestore, iIsBigCost, iBestBits);
#endif
*/
//#include <omp.h>
 
void video_log(int b, int x, int y,const char *format,...);
void video_log_r(char *p, int l);
void video_log_set(char *p, int l);

#if 0

template<int iFrames>
class CTLogFrames{
   char *buf;
   int iLen;
   int iBlocksIn;
   int iSize;
   int iPrevBlockIn;
   char *fr[iFrames+1];
   int iLenFr[iFrames+1];
public:
   CTLogFrames(){iPrevBlockIn=0;iBlocksIn=0;iLen=0;iSize=128*400*3*2;reinit(1);}
   void reinit(int iFirst=0){
      iLenFr[iFrames]=iLen;
      for(int i=0;i<=iFrames;i++){
         if(iFirst)iLenFr[i]=0;
         char *nbuf=new char [iSize];
         if(fr[i] && !iFirst){memcpy(nbuf,fr[i],iLenFr[i]);delete fr[i];}
         fr[i]=nbuf;
      }
      buf=fr[iFrames];

   }
   ~CTLogFrames(){for(int i=0;i<=iFrames;i++)delete fr[i];}
   void addBlock2Log(char *p, int l){
      if(iLen+l>=iSize){
         iSize*=2;
         reinit();

      }
      memcpy(&buf[iLen],p,l);
      iLen+=l;
      buf[iLen]=0;//iLen++;
      iBlocksIn++;
     // if(iPrevBlockIn==iBlocksIn)sendToMainLog();

   }
   void sendToMainLog(){
      if(!iLen)return ;
      iLenFr[iFrames]=iLen;
      fr[iFrames]=buf;
      video_log_set("",0);

      for(int i=0;i<iFrames;i++){
         memcpy(fr[i],fr[i+1],iLenFr[i+1]);iLenFr[i]=iLenFr[i+1];
         video_log_r("+++++++",i+1);
         video_log_r(fr[i],iLenFr[i]);
      }

      iPrevBlockIn=iBlocksIn;
      //video_log_r(&buf[0],iLen);
      iLen=0;
      iBlocksIn=0;
   }

};
CTLogFrames<4> logfr;

class CTVLogRow{
   char buf[128];
   int iLen;
   int iDec;
public:
   CTVLogRow(int iPic, int iDec, int k, int b,int x, int y)
      :iDec(iDec){
        if(iDec)  return;
        if(x==0 && y==0 && !k)logfr.sendToMainLog();
        iLen=sprintf(&buf[0],"%d%d%d(%3d,%3d)",iPic,b,k,x,y);
   }
   ~CTVLogRow(){
      if(!iDec){
      buf[iLen]='\r';iLen++;buf[iLen]='\n';iLen++;buf[iLen]=0;
      logfr.addBlock2Log(&buf[0],iLen);
      //video_log_r(&buf[0],iLen);
      }
    }
   void addT(char *p){if(!iDec)iLen+=sprintf(&buf[iLen]," %s",p);}
   void addI(int i){if(!iDec)iLen+=sprintf(&buf[iLen]," %d",i);}
   void addV(char *p, int i){if(!iDec)iLen+=sprintf(&buf[iLen]," %s=%d",p,i);}
};
#define T_LOG_START  CTVLogRow vl(iPic,iDec,k,b,ctx->i>>4,ctx->j>>4);
#define LOGI(_A) vl.addI(_A);
#define LOGT(_A) vl.addT(_A);
#define LOGV(_A) vl.addV(#_A,_A)

#else

#define T_LOG_START  
#define LOGI(_A) 
#define LOGT(_A) 
#define LOGV(_A) 

#endif

int dcErrCalc(int *t1, int *t2){
   int d=0;
   for(int i=0;i<16;i++){
      int dif=t1[i]-t2[i];
      d+=(dif*dif);
   }
   return d;
}

template<class T, int iPic>
int optim(TDCTX *ed, CTVLCX &vl,T *qc, T *c, int iDCQ, int iDcCnt){
   T ccReal[16];
   T ccRestored[16];
   void fdct4x4dc_s( int *d);
   void idct4x4dc_s( int *d);
   int dq   = iDCQ<<1;
   iDCQ>>=3;


   //   inline  void deQN(DCT_TYPE *p, DCT_TYPE *deq_dct, const int *tab, int n)

   //ed->deQN
   T blQ[16];memcpy(blQ,qc,16*(sizeof(T)));
   T blDeQ[16];



   blDeQ[0]=0;
   int co[16];
   int iCoCnt=0;
   int coAdd=0;
   int zz,zzz;
   for(zz=0;zz<16;zz++){
      //  if(blQ[zz]){co[iCoCnt]=zz;blDeQ[zz]=blQ[zz]*t[zz];iCoCnt++;}else blDeQ[zz]=0;
      int qcoef = abs(blQ[zz]);
      int coef = abs(c[zz]);
      
      //coAdd

      if(qcoef){
         //(qcoef==1 && qcoef * dq > coef)||
         //if (zz||(zz && qcoef * dq < coef && (coef < ((qcoef+1) * dq ))))
         if(zz)
         {
            if(qcoef==2 || (qcoef==1 && qcoef*dq<coef) ||(qcoef*dq>coef+(dq>>3))){
               co[iCoCnt]=zz;iCoCnt++;
            }else {coAdd++;}

            if(qcoef>3)return iDcCnt;
         }
         else {coAdd++;}
         blDeQ[zz]=blQ[zz]*dq;

      }else  blDeQ[zz]=0;
   }
   int iBestCCnt=iCoCnt;
   if(iCoCnt && iCoCnt<5){
      T blDeQr[16];
      memcpy(&blDeQr[0],&blDeQ[0],16*(sizeof(T)));
      int bpdx=vl.iBitPos;
      ed->enc1x_15_dif_dc<1,int>(vl,&qc[0],iPic,0);
      int iBestDifB=vl.iBitPos-bpdx;vl.iBitPos=bpdx;
      memcpy(ccReal,c,sizeof(T)*16);
      ccReal[0]+=8;
      idct4x4dc_s(&ccReal[0]);
      for(int i=0;i<16;i++){ccReal[i]>>=3;}

      idct4x4dc_s(&blDeQ[0]);

      //for(int i=0;i<16;i++){if(blDeQ[0]<iDCQ && blDeQ[0]>-iDCQ)blDeQ[0]=0;}
      int iErr=dcErrCalc(&ccReal[0],&blDeQ[0]);
      int iBestV=-1;
      int iCoefsCnt=0;

      for(zz=1;zz<(1<<iCoCnt);zz++)
         //zz=(1<<iCoCnt)-1;
      {
         memcpy(blQ,qc,16*(sizeof(T)));
         memcpy(blDeQ,blDeQr,16*(sizeof(T)));
         iCoefsCnt=0;//iCoCnt;

         for(zzz=0;zzz<iCoCnt;zzz++){
            int pos=co[zzz];
            if(zz &(1<<zzz)){
               int coef=blQ[pos];
               if(coef<0)coef++;else coef--;
               if(coef){ blDeQ[pos]=coef*iDCQ;iCoefsCnt++;}
               blQ[pos]=coef;
            }else {iCoefsCnt++;blDeQ[pos]=blQ[pos]*iDCQ;}
         }
         idct4x4dc_s(&blDeQ[0]);
      //for(int i=0;i<16;i++){if(blDeQ[0]<iDCQ && blDeQ[0]>-iDCQ)blDeQ[0]=0;}

         int iE=dcErrCalc(&ccReal[0],&blDeQ[0]);
         if(iE<=iErr || (iE<iErr)){
            int bpd=vl.iBitPos;
            ed->enc1x_15_dif_dc<1,int>(vl,&blQ[0],iPic,0);
            //ed->enc1x_15_dif(&blQ[0], &xcnt[0], z);
            if((iBestDifB>vl.iBitPos-bpd) || ((iE<iErr) && iBestDifB>=vl.iBitPos-bpd)){
               debugsi("bbb",iBestDifB-(vl.iBitPos-bpd));
               iErr=iE;
               iBestV=zz;
               iBestCCnt=iCoefsCnt;
               iBestDifB=vl.iBitPos-bpd;
            }
            vl.iBitPos=bpd;

         }
      }
      if(iBestV>=0){
         //memcpy(blQ,&q_dct[i][z<<4],16*(sizeof(DCT_TYPE)));
         //memset(&q_dct[i][z<<4],0,16*(sizeof(DCT_TYPE)));
         zz=iBestV;
         for(zzz=0;zzz<iCoCnt;zzz++){
            int pos=co[zzz];
            if(zz &(1<<zzz)){
               int coef=qc[pos];
               if(coef<0)coef++;else coef--;
               qc[pos]=coef;
            }
         }
      }

   }


   return iBestCCnt+coAdd;


}

void setSkipLoopF(int f){g_iSkipLoop=f;}

#ifdef _TEST_T_BITS
#define encMB16_ok encMB16_okN
#else
#define encMB16_ok encMB16_okO
#endif

#define DEC_4x4(_ID,_ofs)\
      if(iPic && iPicR)t_idct8_s_put_f(&dct[_ID][0],pCur+_ofs,stride,iDecFlags[_ID]);\
      else t_idct8_s(&dct[_ID][0],pCur+_ofs,stride,iDecFlags[_ID]);

#define TR_2x4x4(_O, _ID)\
   if(iPic && iPicR)t_fdct8_s(pRef+_O,stride,&dct[_ID][0]);\
   else  t_fdct8_s_d(pRef+_O,pCur+_O,stride,&dct[_ID][0]);

#define TRPIC_2x4x4(_O, _ID)  t_fdct8_s(pRef+_O,stride,&dct[_ID][0]);
#define TRDIF_2x4x4(_O, _ID)  t_fdct8_s_d(pRef+_O,pCur+_O,stride,&dct[_ID][0]);
   

#ifdef _TEST_T_BITS

template  <int iDec, int iPic>
static int encMB16_okN(ENC_BL_CTX *ctx, TDCTX *ed, unsigned char *pCur, unsigned char *pRef, int stride,int k,int  iIsB, int i_CanRestore, int &iIsBigCost, int iBestBits=0){
  

   //int iPic=(!!k || !(ctx->i && cyx->j);
   DECLARE_ALIGNED(unsigned char  saved[256],32);
   DECLARE_ALIGNED(DCT_TYPE dct[4][64],64);
   DECLARE_ALIGNED(DCT_TYPE q_dct[4][64],64);
   DECLARE_ALIGNED(int dctDC[17],32);
   //DCT_TYPE dct[4][64];
   //DCT_TYPE  q_dct[4][64];
//k=0;
   const int *t=k?&ed->tab_uv[128]:&ed->tab_y[128];
   int s;//,iMaxCoef;
   int i;
   int ofs;
   int iMaxQ=0;
//   int iPos;
   int iHasDCs=0;
   int iBlocksEnc=0;
   int iBlocksEnc16=0;
   int iBitPos=ed->vlc.iBitPos;
   int iBitPosDC=0;
   int iCheckHadaDIFs=1;
   //int iDCBitsCnt=0;
   int iCanRestore=!iDec && ctx->iIsPic==0 && iPic==0  && i_CanRestore!=-1 && !ed->iIsKey && i_CanRestore!=-7;
  // if(iIsB)iCanRestore=0;
   if(ed->iIsReferenceFrame){ed->iIsB=iIsB=0;}
   int iDCQ;
   int iDecFlags[4]={0xff,0xff,0xff,0xff};
  // int iWasB=ed->iThisWasB;
   int b=!!(iIsB|ed->iThisWasB|ed->iThisWasBX);
   int iCanBePic=!iDec && !ctx->iIsPic && iPic==0 && !b && !iIsB&& (!k || !ctx->iHasUVMode);
  // if(iIsB || iWasB)iCanRestore=0;
   //if(!iPic)ed->iPredDC=0;

//k=1;
  // if(!k && !iPic){iDCQ+=48;iDCQ>>=2;}
   

   //if(k && ctx->iHasUVMode && ctx->iDCDifAbs>iIsB)  iCanRestore=0;  
//   if(iIsB)iCanRestore=0;
   //iDCQ*=2;

int iSQErrStart=0,iSQErrEnd;


//iDCQ=ed->iIsReferenceFrame?24:30;
   //TODO *(int*)prx=0
   ed->iPrevCode=0;
iDCQ=k?ed->iDCQuantUV:ed->iDCQuant;

  // if(iPic)iDCQ>>=1;
   if(iPic && !ed->iIsKey){iDCQ*=5;iDCQ>>=2;iDCQ+=7;iDCQ&=~7;}//else {iDCQ+=7;iDCQ&=~7;}
   if(!k){
  // if(iPic && ed->iIsKey){iDCQ=k?ed->iDCQuantUV:ed->iDCQuant;iDCQ*=2;}
   //else if(iPic){iDCQ=k?ed->iDCQuantUV:ed->iDCQuant;iDCQ*=2;}
   }
   int iIncKeyDCQ=0;
   //--if(!ed->iIsKey &&  iPic){iDCQ<<=1;iIncKeyDCQ=1;}
   //----------------------?????????????????????????----------------------<<
   ctx->iDCQ=iDCQ;
  // int iPsnrLim=ed->iQVal*17+3100;
  // int iSSim=0;
   int iMaxDC=0;
   int iDCDif=0;
//   int iCanRestoreIfDc=0;
//   int iClearArtifacts=1;
//   int iIncRestoreAndDecMinPsnr=0;
//   int iEncDCOnly=0;
   int iCanSkipFast=1;
   int iDCBitCnt=0;
   int iMaxQDC=0;
//iDCQ=16;//+=64;iDCQ>>=2;
   int m=k?2:0,iSad=2500,iMinPosSad=2000,iTryMode=1,iDev=6000,iVecLen=4;
   int iPicR=iPic;

   int getBlockPSNR_UV(unsigned char *p ,unsigned char *o, int w, int h, int stride, int step);
   void t_idct8_s(DCT_TYPE *t, unsigned char *dst, int stride, int iX);
   void t_fdct8_s(unsigned char *src, int stride, DCT_TYPE *d );
   void t_fdct8_s_d(unsigned char *src,unsigned char *src2, int stride, DCT_TYPE *d );;
   void t_idct8_s_put(DCT_TYPE *t, unsigned char *dst, int stride);
   void fdct4x4dc_s( int *d);
   void idct4x4dc_s( int *d);

   /*
   if(!k  && (ctx->i && ctx->j) && (((ctx->i>>4)&1) +((ctx->j>>4)&1)==1) && iPic){
      if(!ed->iVisDecoder && !ed->iSkipPutBlocks){
         unsigned char *pX=pCur;
         unsigned char *uX=pCur-stride;
         unsigned char *lX=pCur-3;
         unsigned char tl=uX[-3];
         unsigned char xx[16];
         ed->iPredDC=0;
         if(1){
            for(int a=0;a<16;a++){xx[a]=lX[a*stride];}
            for(int a=0;a<16;a++){
               for(int b=0;b<48;b+=3){
                  int cc=(xx[a]+uX[b])-tl;
                  //cc*=2;cc+=((pX[b-3]+pX[b-stride]));
                  //cc+=2;cc>>=2;
                  if(cc>240)cc=240;else if(cc<16)cc=16;
                  pX[b]=cc;
               }
               pX+=stride;

            }
         }else {
            int dc=0;
            for(int a=0;a<16;a++){dc+=lX[a*stride];dc+=uX[a*3];}
            dc+=16;dc>>=5;
            for(int a=0;a<16;a++){
               for(int b=0;b<48;b+=3){
                  pX[b]=dc;
               }
               pX+=stride;
            }
         }

         iPicR=0;
      }
   }
   */
   int iHada=-1;
   T_LOG_START
   if(!iPic && !iDec && k==0 && i_CanRestore!=-2){
      //getMBParams(ctx->i>>3, (ctx->j)>>3, k, ctx->w, m, iSad, iMinPosSad, iTryMode, iDev, iVecLen);
      /*
   int iPicS=0;
      iPicS=t[0]*4;
      TRPIC_2x4x4(0,0);
      TRPIC_2x4x4(3*8,1);
      TRPIC_2x4x4(stride*8,2);
      TRPIC_2x4x4(stride*8+3*8,3);
      for(i=0;i<4;i++)dct[i][0]=dct[i][16]=dct[i][32]=dct[i][48]=0;
      for(i=0;i<256;i++)iPicS+=abs(dct[0][i]);

   TR_2x4x4(0,0);
   TR_2x4x4(3*8,1);
   TR_2x4x4(stride*8,2);
   TR_2x4x4(stride*8+3*8,3);

   if(iPicS){
      for(i=0;i<4;i++)dct[i][0]=dct[i][16]=dct[i][32]=dct[i][48]=0;
      int ds=0;
      for(i=0;i<256;i++)ds+=abs(dct[0][i]);
      if(ds>iPicS)return 7;
   }
      */
      //if(!m && !iIsB && (iSad*3>iDev*4+iDCQ+10000 || iSad>iDev+1000) && iSad*3>iMinPosSad*5+iDCQ)return 7;
      getMBParamHada(ctx->i>>3, ctx->j>>3, k, ctx->w,iHada);
      //iHada=-1;
      if(!ed->iIsReferenceFrame && !ed->iIsKey && i_CanRestore!=-7 && !ctx->iIsPic){

         if(iHada==0){
LOGT("hada0");
            ctx->mb->col[k].iSkip=MB16_2::eSkipQ;
            pEncStat->iSkipQ[k]++;

            return 0;
         }

      }
      if(ed->iIsReferenceFrame && !iIsB && iHada<0)iCanRestore=0;
   }
   int iFastBlockType=!iDec && !iPic && useFastBlockType();


   //  int iNeedGain300=0;
   int iSadUV=-1;
   /*
   if(k && !iDec && !iPic){

      
      //static int iLimSk=ed->iSQQuantErr4x4Y*4;
         if(ctx->iHasUVMode)iSadUV=ctx->iUVSad;
         else if(!getMBParamUV(ctx->i>>3, (ctx->j)>>3, k, ctx->w,iSadUV))
            iSadUV=-1;
     //    if(iSadUV>=0 && iSadUV*8<t[0]+12)iSadUV=sadInt(pCur,pRef,stride,t[0]*2+500);
LOGV(iSadUV);
    //  if(iSadUV>=0 && iSadUV*8<t[0]+12 && iSadUV<64)return 0;
      if(iSadUV>30 && (ctx->mb->col[0].iType==ctx->mb->ePic4x4 || ctx->mb->col[k-1].iType==ctx->mb->ePic4x4) && !b){
         getMBParams(ctx->i>>3, (ctx->j)>>3, k, ctx->w, m, iSad, iMinPosSad, iTryMode, iDev, iVecLen);
         if(!m && iSadUV>iDev)return 7;
      }
   }

   else 
   */
   if(!iDec && !iPic && !ed->iIsKey && !ctx->iIsPic && !k && i_CanRestore!=-2){


      getMBParams(ctx->i>>3, (ctx->j)>>3, k, ctx->w, m, iSad, iMinPosSad, iTryMode, iDev, iVecLen);
      if(iSad!=2 && iSad<24)iSad=((iMinPosSad*3)>>2);
      ctx->m=m;// && iSad*4>(iMinPosSad-100)*5;
//v_log("m=%d,s=%d,d=%d,ms=%d,",m,iSad,iDev,iMinPosSad);
LOGV(m);LOGI(iSad);LOGI(iDev);LOGI(iMinPosSad);

      if(iSad*2<t[0] && iSad<iMinPosSad+50 && iSad<iDev+50){
         ctx->mb->col[k].iSkip=MB16_2::eSkip7;
         pEncStat->iSkip1[k]++;
         LOGT("sk7");
         return 0;
      }
      if(iSad<10+(b)*100 )return 0;
      if(!iIsB && !m && iSad>t[0]){// && iSad>iDev+200){
        // return 7;
         //4095 4921
         if(iSad>iDev+t[0]*6 && iSad+200>iMinPosSad)return 7;
         if(iDev==10 && iSad>t[0]*4+20)return 7;
         if(iSad>iDev+t[0]+150 && iSad>iMinPosSad)return 7;
         if(iSad>iDev*2+100 && iSad>iMinPosSad+100)return 7;
         if(iSad>iDev+100 && iSad>iMinPosSad*2)return 7;
         //if(iSad>iDev+100+t[0] && iSad>(iMinPosSad-100)+t[0])return 7;
         //if(iSad>iDev*2+(t[0]>>2) && iSad>(iMinPosSad-100))return 7;
         LOGT("ret7");
         if(iSad>t[0] && iSad*3>(iMinPosSad-200)*4+200 && iSad>iDev+100 && !(b)){
            if(iDev*2<t[0]+20)return 7;
         }
         if(ed->iIsReferenceFrame ||iSad>iDev+((t[0]+800)>>3)){
            if(iSad>t[0]*2 && iSad>iDev && iDev*3<t[0])return 7;
            if(ctx->i && ctx->iPrevDCCnt<=10 && ctx->mb[-1].col->iType==MB16_2::ePic4x4 
               && !(b) && iSad*3>iMinPosSad*5+300+(iDCQ>>2) && iSad*4>iDev*4+200+(iDCQ>>2) && iDev<5000)return 7;
            if(ed->iIsReferenceFrame){
               
               if(iDev*2+20<t[0])return 7;

               if(iSad>iDev+(iDCQ>>2)+100)return 7;
               if(iSad*3>iMinPosSad*4+(iDCQ)+300 && iDev<4000)return 7;
               if(iSad>iMinPosSad+iDCQ && iSad>iDev+200)return 7;
            }
         }
      }
      //if(iDif>(iDCQ>>7)+(iIsB|ed->iThisWasB) && (iDev<2000))iCanRestore=0;

      

      if((iIsB|ed->iThisWasB) && m==100 && iSad<iDev && iSad*2<iMinPosSad && (iSad<(50+iDCQ)*2 )){
         ctx->mb->col[k].iSkip=MB16_2::eSkip5;
         pEncStat->iSkip1[k]++;
         return 0;
      }


      //(dc>>4)*128
      if(!iPic && iSad>iMinPosSad+t[0]*(8+iIsB*2)+50)iCanSkipFast=0;
   }
   
   iTryMode&=31;//



//TODO next vers addGetBit
   int iEncodeSeperateDC=1;//iPic || k;//+.3 psnr
  // if(!iPic && !k && iDec)iEncodeSeperateDC=ed->vlc.getB();
   //const int iEnableDifFilter=!iPic && (k||(iDec && (ed->iIsB|ed->iThisWasB)));//+.3 psnr//TODO detect WASB
   //int iCheckDCSkip=1;
   int iTestPSNRSkip;
   int iTestSkipDC;
   if(!iDec){
      iTestSkipDC=1;
      iTestPSNRSkip=1;
   ofs=0;
   //memset(&dct[_ID][1],0,30);
     
//   if(iPic){if(k){memset(&dct[_ID][0],0,32);for(int t=0;t<16;t++){dct[_ID][0]+=(pRef[(_O)+(t&3)*3+stride*((t>>2))]-128);dct[_ID][0]*=2;dct[_ID][0]+=128*16*2;}}else t_fdct8_s(pRef+_O,stride,&dct[_ID][0]);}

   int iPicS=0;
iCheckHadaDIFs=0;
   if(!k && !m && 
      iCheckHadaDIFs &&  
      !iPic
      && (k||iSad*9+200>iMinPosSad*8)
      ){
      iPicS=t[0]*4;
      TRPIC_2x4x4(0,0);
      TRPIC_2x4x4(3*8,1);
      TRPIC_2x4x4(stride*8,2);
      TRPIC_2x4x4(stride*8+3*8,3);
      for(i=0;i<4;i++)dct[i][0]=dct[i][16]=dct[i][32]=dct[i][48]=0;
      for(i=0;i<256;i++)iPicS+=abs(dct[0][i]);

 }
   TR_2x4x4(0,0);
   TR_2x4x4(3*8,1);
   TR_2x4x4(stride*8,2);
   TR_2x4x4(stride*8+3*8,3);

   if(iPicS){
      int ds=0;
      for(i=0;i<256;i++)ds+=abs(dct[0][i]);
      if(ds>iPicS)return 7;
   }
	/*
   {

   TR_2x4x4(0,0);
   TR_2x4x4(3*8,1);
   TR_2x4x4(stride*8,2);
   TR_2x4x4(stride*8+3*8,3);
   }
   */
   

   void t_fdct4(DCT_TYPE *t);

   /*
   0 1 4 5 
   2 3 6 7 
   8 9 12 13 
   10 11 14 15

   */
  
//if(iEncodeSeperateDC){dct[_B][_C]=0;}
#define _SET_DC(_A,_B,_C) dctDC[_A]=dct[_B][_C];

   // iPos=0;
   _SET_DC(0,0,0); _SET_DC(1,0,16);_SET_DC(2,1,0); _SET_DC(3,1,16);
   _SET_DC(4,0,32); _SET_DC(5,0,48);_SET_DC(6,1,32); _SET_DC(7,1,48);
   _SET_DC(8,2,0);_SET_DC(9,2,16);_SET_DC(10,3,0); _SET_DC(11,3,16); 
   _SET_DC(12,2,32);  _SET_DC(13,2,48); _SET_DC(14,3,32);_SET_DC(15,3,48);

   const int iDCQ2=iDCQ*2;
   //int iDCQAdd=iPic?iDCQ:(iDCQ2/6+1);//(iPic && ed->iIsKey)|| ed->iIsKey ?((int)(iDCQ2/2.1)):(iPic?(iDCQ2/3):(iDCQ2/3+1));//(iDCQ2*10/22);
   
   iHasDCs=0;
   int iMiDc=100000000;
   int iMaDc=-100000000;
  // int iGC=0;
   for(i=0;i<16;i++){
      if(iMiDc>dctDC[i])iMiDc=dctDC[i];if(iMaDc<dctDC[i])iMaDc=dctDC[i];  
     // if(!iPic && dctDC[i]<t[0] && dctDC[i]>-t[0])iGC++;
   }//-8 0
   
   iMaxDC=max(-iMiDc,iMaDc);
   iDCDif=((iMaDc-iMiDc));//*15+8)>>4;
   if(iDCDif>iMaxDC)iMaxDC=iDCDif;
   if(iMaxDC>t[0]*2 && iMaxDC>16){iTestPSNRSkip=0;iTestSkipDC=0;}

LOGV(iMaxDC);
   //int block[17];


   
if(iEncodeSeperateDC){
   for(i=0;i<4;i++)dct[i][0]=dct[i][16]=dct[i][32]=dct[i][48]=0;
   
      //void fdwt(int *p);
    //  fdwt(&dctDC[0]);
   const int iMSh=(1<<16)/iDCQ2+1;
   const int iDCQAdd=iPic?((1<<16)/3+1):((1<<16)/6+1);
         fdct4x4dc_s(&dctDC[0]);
//         int coRRR[16];memcpy(coRRR,dctDC,16*(sizeof(coRRR[0])));
  //       int repCnt=0;;
//repdc:
         for(i=0;i<16;i++){
            const int _s=dctDC[i]>>31;
            const int av=(dctDC[i]+_s)^_s;
            if(av*(8)<iDCQ2*(6-iPic))dctDC[i]=0;else
            {
               //dctDC[i]=(av+iDCQAdd)/iDCQ2;
               dctDC[i]=(av*iMSh+iDCQAdd)>>16;
               if(dctDC[i]){
                  iHasDCs++;
                  if(dctDC[i]>iMaxQDC)iMaxQDC=dctDC[i];
                  dctDC[i]=(dctDC[i]+_s)^_s;
               }
            }
            //else 
         }
         /*
         if((iHasDCs>1 || (iHasDCs && !dctDC[0])) && repCnt==0){
            iHasDCs=0;
            repCnt++;
            goto repdc;
         }
         */
         LOGV(iHasDCs);
         
        // if(iClearDc==15 && iHasDCs){iHasDCs=0;memset(&dctDC[1],0,sizeof(dctDC[0])*15);if(dctDC[0])iHasDCs=1;}
         //if(toDC==1) memset(&dctDC[1],0,sizeof(dctDC[0])*15);
         
         if(iPic==0 && iHasDCs<2 && (iMaxQDC<2 || iMaxQDC*t[0]<20) && i_CanRestore!=-2){
            if(iHasDCs && dctDC[0]){if(iMaxDC>11+(b)*4) {}else {iMaxDC=0;dctDC[0]=0;iHasDCs=0;iMaxQDC=0;}}

            if(k && (iSadUV>t[0] || iSadUV<0)){
            }
            else if((b ||k) && !iHasDCs && (k || ((m==100 || iSad*2<iMinPosSad+iDCQ) && iSad<iDev&& iSad<iMinPosSad+200 && iSad<800+iDCQ*4))){
               pEncStat->iSkip2[k]++;
               ctx->mb->col[k].iSkip=MB16_2::eSkip9;
         LOGT("sk9");
               return 0;
            }
         }
   

}//if iPic

//int score=100;//iPic && !ed->iIsKey?0: 100;//iPic?0:100;// ?0:100;//iIgnoreDC?0:100;//iPic || iCanRestore?100:0;// && iStartPsnr>3500?0:100;
int iRep=0;
//#define T_USE_DEC_REP_Q
#ifdef T_USE_DEC_REP_Q
     // int iBlockBP=ed->vlc.iBitPos;
int iBitPosX=ed->vlc.iBitPos;
rep_decBits:

ed->vlc.iBitPos=iBitPosX;
if(!k && !iPic)ed->vlc.addB(iRep);
if(iRep){
   iBlocksEnc=0;

//   for(i=0;i<256;i++){dct[0][i]++;dct[0][i]>>=1;}
   for(i=0;i<256;i++){dct[0][i]<<=1;}
}
#endif
      int res[4]={0,0,0,0};
      //int mv_modes[]={2,4,8,16};

      int ress=0;

      const int iLowQvalPic=iPic && !ed->iIsKey;

      //for(int a=0;a<256;a++){if(dct[0][a]>0)dct[0][a]-=t[0]/4;else if(dct[0][a]<0)dct[0][a]+=t[0]/4;}
      //   ed->iSetFlagPic=0;
         
      int iLowDC=!iHasDCs || iMaxQDC*t[0]<16 || /*iMaxDC*4<t[0]*3 ||*/ iMaxDC<12+(b)*16 || (iHasDCs==15 && iMaxDC*4<t[0]*3 && iMaxQDC<2);
         for(i=0;i<4;i++){
            
            //if(!iStartPsnr && !iPic && !k && !iIsB){iBlocksEnc=1;ress=2;break;}

            if(iPic){
               //s=ed->QTestN<iPic>(&dct[i][0],(iIsB|ed->iThisWasB),k);
               if(!iLowQvalPic){
                  s=ed->QFast<iPic>(&q_dct[i][0],&dct[i][0],t,64,iIsB,k,iIsB || !iMaxDC);
//                  s=ed->QFnc<&quant_pic_nonKey>(&q_dct[i][0],&dct[i][0],t,64);
               }else {
                  //if(s)
                     //s=ed->QFastLPic(&q_dct[i][0],&dct[i][0],t);
#if defined(__SYMBIAN32__) || defined(__APPLE__) || defined(ANDROID_NDK) || defined(__linux__)
                  s=ed->QTestN<0>(&dct[i][0],iIsB,k);
#else
                  s=ed->QFnc<&quant_pic_nonKey>(&q_dct[i][0],&dct[i][0],t,64);//gcc compilers do not like quant_pic_nonKey
#endif
               }
               /*
               if(s==1){
                  int coc=0;
                  for(int a=1;a<64;a++)if(q_dct[i][a])coc++;
                  pEncStat->iOnes[k][1]+=coc-1;
               }
               */
              // else if(s)pEncStat->iOnes[k][1]--;
               
            }else {
               //if(!iPic && !k && !iIsB && iMaxDC>1){iBlocksEnc++;ress+=1;res[i]=1;break;}
               //if(iIsB && !k)s=1;else 
               //if(iRep  || (iMaxQDC && t[0]>80) || t[0]>120)s=1;else 
               if((!iLowDC && !b) || t[0]>200 || i_CanRestore==-2){s=1;}else  s=ed->QTestN<iPic>(&dct[i][0],(iIsB|ed->iThisWasB),k); //
              //??? if(iHasDCs>1 && iStartPsnr==0 && !iPic && !k && !iIsB)s=2;
            }
              // s=ed->QTest<iPic>(&dct[i][0],t,iIsB,k); 
            //
            
           if(s){iBlocksEnc++;ress+=s;res[i]=s;if(!iPic && !k && !iIsB)break;}

         }
         //if(score<5+iIsB*2){if(iBlocksEnc)debugss("score",k,ress);ress=iBlocksEnc=0;res[0]=res[1]=res[2]=res[3]=0;}
 
    //  const int iResLim=0;//ed->iIsReferenceFrame?0:(0+3*iIsB);

LOGV(iLowDC);
      //if(iMaxDC<t[1] && (iBlocksEnc==0 || ress<=iResLim))iHasDCs=0;
     if(iPic==0 && iBlocksEnc==0 
        &&   iLowDC ){// || iMaxDC<t[1] )){// || (cnt==100 && iCanRestore)){

         pEncStat->iSkipQ[k]++;
         ctx->mb->col[k].iSkip=MB16_2::eSkipQ;
//debugss("res",ress,dctDC[0]);
         return 0;
      }
     //if(!iPic && k && !b && testSendPic(pCur,pRef,stride))return 7;

//63600 256 q80
/*
     if(!iPic && !m && !(b)  &&!k && iSad*3>iMinPosSad*4+iDCQ+100 && iSad>iDev+iDCQ &&  iSad>iDCQ+100 && !iFastBlockType){
        if(!iLowDC &&//iCanBePic && ed->iIsReferenceFrame &&   
           iSad>iDev+200){return 7;}//&& mmabs(dctDC[0])<5
     }
     */
     int iBitFlag=0; 
     if((!iBlocksEnc)){// || (!iPic && ress<=iResLim && (iPic?iDCDif:iMaxDC)<t[1]))){// && (!iACTested || iDCSum<2 || !iIncCoefs  || iPic ||  iIsB || k || iHasDCs==1 || iMaxDC*2<t[0]*3|| iLowDC || iDCDif*2<t[0]*3)){
        for(i=0;i<4;i++){
           iDecFlags[i]=0;
           res[i]=0;
        //   ed->vlc.addB(0);
           dct[i][0]=dct[i][16]=dct[i][32]=dct[i][48]=0;
        }
        //if(iClearArtifacts )memset(&dct[0][0],0,128*4);
     }
     else{
//        int iHasBlocks=iBlocksEnc;
        iBlocksEnc=0;
        ress=0;
//        const int iBadBLQ=!ed->iIsReferenceFrame && (iSad>iMinPosSad+(iDCQ>>2)+50 || iMaxQDC>1);
        // || iSad*3>iDev*2
        const int iBadBLQ=((!b && t[0]>200 ) || (iDev<4000 || iMinPosSad<1500)) && (iSad>iMinPosSad+(iDCQ>>2)+50 || iMaxQDC>1);
        //t_guant_fnc *qfnc=iBadBLQ?&quant_dif_badBlock:&quant_dif_goodBlock;
            int iDecim=i_CanRestore!=-2 && iLowDC &&  !ed->iIsKey && (k||iMaxQDC<2);
      
        for(i=0;i<4;i++){

            s=res[i];
            int coefsC[4]={1,1,1,1};
            if(!iPic){//  &&  (iFastCheckMode&(1<<i))==0){//&& iHada!=1){
               if(!iIsB && !k){//(!k||s) ){
#if defined(__SYMBIAN32__) || defined(__APPLE__) || defined(ANDROID_NDK) || defined(__linux__)

                  res[i]=s=ed->QFast<2>(&q_dct[i][0],&dct[i][0],t,64,iIsB,k,iIsB || !iMaxDC);
#else
                  res[i]=0;
#if 0
                  
                  
                  if(iBadBLQ){
                     res[i]=s=ed->QFnc<&quant_dif_badBlock>(&q_dct[i][0],&dct[i][0],t,64);

                  } else {
                     res[i]=s=ed->QFnc<&quant_dif_goodBlock>(&q_dct[i][0],&dct[i][0],t,64);
                  }


                  
                  //res[i]=s=ed->QFast<0>(&q_dct[i][0],&dct[i][0],t,64,iIsB,k,iIsB || !iMaxDC);


                  //
                  
                  
                  //enc1x_15_dif(v+(j<<4), &xcnt[0], j);

                  // slower better
                  /*
                  if(!s && iBadBLQ){
                     s=ed->QFnc<&quant_dif_try2>(&q_dct[i][0],&dct[i][0],t,64);
                     if(s<4)s=0;
                     res[i]=s;
                  }
                  */

#else
                  for(int z=0;z<64;z+=16){
                     if(iBadBLQ)
                        s=ed->QFnc<&quant_dif_badBlock>(&q_dct[i][z],&dct[i][z],t,16);
                     else {
                        s=ed->QFnc<&quant_dif_goodBlock>(&q_dct[i][z],&dct[i][z],t,16);
                     }
                     if(s){
                        coefsC[z>>4]=1;
                        res[i]+=s;
                     }
                  }
                  s=res[i];
#endif 
#endif
                  
                 //-- if(s>5)iStartPsnr=0;
               }//3729,95
               else if(s){
                 // if(k){
                  res[i]=0;
                  for(int z=0;z<64;z+=16){
                     s=ed->QFast<0>(&q_dct[i][z],&dct[i][z],t,16,iIsB,k,iIsB || !iMaxDC);
                     if(s){
                        coefsC[z>>4]=s;
                        res[i]+=s;
                        if(s>1)iDecim=0;
                     }
                  }
                  s=res[i];
                 // }else
  //res[i]=s=ed->QFnc<&quant_dif_goodBlock>(&q_dct[i][0],&dct[i][0],t,64);
               }
//if(!k && s>=MAXSC_Q_SZ && !iPic && !iIsB)return 7;
//               if(s>1 && !k && !m && !iPic && !iIsB &&  iSad*2>iMinPosSad*3+t[0] && iSad*2>iDev+100)return 7;
               //ed->iSetFlagPic &&


           
            }
            //381 92K
            //k dcq=t[0]*3
//------            
            //if((k) && s==1)s=0;//380 91K// var lietot ja ir filtrs


               if(iDecim && s && s<6 && ((coefsC[0]|coefsC[1]|coefsC[2]|coefsC[3])<2)){
                  int sk=0;
                  if(coefsC[0])sk+=x264_mb_decimate_score(&q_dct[i][ 0],16);
                  if(sk<3 && coefsC[1])sk+=x264_mb_decimate_score(&q_dct[i][16],16);
                  if(sk<3 && coefsC[2])sk+=x264_mb_decimate_score(&q_dct[i][32],16);
                  if(sk<3 && coefsC[3])sk+=x264_mb_decimate_score(&q_dct[i][48],16);
                  if(sk<3){s=res[i]=0;}

               }

         
            if(s){//(s && !k) || s>1){// &&(!k || iMaxCoef>16)){//>iLimQ){
               if(s>iMaxQ)iMaxQ=s;

               iBitFlag|=(1<<i);
  //             if((s>1 && (t[0]>32 || ed->iIsReferenceFrame)) || s>2)iStartPsnr=0;// || t[0]>100

               ress+=s;
               iBlocksEnc++;
           //    ed->vlc.addB(1);
            }
            else {
               iDecFlags[i]=0;
//               ed->vlc.addB(0);
               dct[i][0]=dct[i][16]=dct[i][32]=dct[i][48]=0;
               //if(iClearArtifacts)memset(&dct[i][0],0,128);
            }
            
         }
#ifdef T_USE_DEC_REP_Q      
     //iMaxQ>3-(iIsB|ed->iThisWasB)*2 &&
     if(!iPic &&!k && iRep==0 && (iBitFlag&15)==0 && !(b) && ed->iIncBitrateN){iRep=1;goto rep_decBits;}
 #endif

         
         LOGV(ress);
        if(!iPic &&  b && (!iHasDCs  ) && ress<2 && (k || iSad*2<iDev)){
           pEncStat->iSkipQ[k]++;
           ctx->mb->col[k].iSkip=MB16_2::eSkipQ;
           return 0;
        }
     }
// || iMaxDC*2<t[0]
     if(iPic==0 && (ed->iIsReferenceFrame==0 || !iHasDCs) && !iBlocksEnc){

//|| iMaxQDC<2
        if((iLowDC || !iHasDCs) ){// || (cnt==100 && iCanRestore)){
           pEncStat->iSkipQ[k]++;
           ctx->mb->col[k].iSkip=MB16_2::eSkipQ;
           return 0;
        }
/*
        if( iCanSkipDC && iHasDCs<3  && iMaxQDC<2){
           pEncStat->iSkipQ[k]++;
           ctx->mb->col[k].iSkip=MB16_2::eSkip2;
           return 0;
        }

*/
        if(!(dctDC[0]|dctDC[4]|dctDC[1]|dctDC[2]|dctDC[8]) && iMaxQDC<2 && iMaxDC*2<t[0] && !k){// || (cnt==100 && iCanRestore)){
           pEncStat->iSkipQ[k]++;
           ctx->mb->col[k].iSkip=MB16_2::eSkip3;
           //debugss("res2",ress,dctDC[0]);
           return 0;
        }
     }
     if(iPic==0 && !k &&  abs(dctDC[0]|dctDC[4]|dctDC[1])*iDCQ<(64+(iDCQ>>2)) && iMaxQ*t[0]<80 && iMaxQDC<2 
      //  && (b) //var lietot arii uz ne B
        && iSad<iMinPosSad && iSad*2<iDev)
     {
        int cs=((iMaxQDC|iMaxQ)*t[0]+16)>>4;
           if(analizeSkip(pCur,pRef,stride,(cs+(t[0]>>5)))){
           pEncStat->iSkip1[k]++;
           if(ed->iIsFirstPass)ctx->mb->col[k].iSkip=MB16_2::eSkip4;
           LOGT("s4");
           return 0;
           }
     }
     else if(iPic==0 && !k && !dctDC[0] && iSad*2<iDev+iDCQ && iSad<iMinPosSad+t[0]*2 && iMaxQDC<2 && iMaxQ<3){
        int cs=((iMaxQDC|iMaxQ)*t[0]+31)>>5;
           if(cs>2 && analizeSkip(pCur,pRef,stride,(cs+(t[0]>>5)))){
           pEncStat->iSkip1[k]++;
           if(ed->iIsFirstPass)ctx->mb->col[k].iSkip=MB16_2::eSkip4;
           LOGT("s41");
           return 0;
           }
     }
     
#if 0
     if(iEncodeSeperateDC){
        encDC<iPic>(ed, iHasDCs,&dctDC[0], k);
     }

     iDCBitCnt=ed->vlc.iBitPos-iBitPos;
     iBitPosDC=ed->vlc.iBitPos;
      static const int tf[]={0,1,1,2,
                             1,2,2,3,
                             1,2,2,3,
                             2,3,3,4};

      ed->vlc.toVLC(iBitFlag);
      ed->iAllBlocks=ed->iBlocks8orMore=0;
      if(tf[iBitFlag]>2){

         int iB16=0;
         for(i=0;i<4;i++){
            if(iBitFlag&(1<<i)){
               for(int b=0;b<64;b+=16){
                  if(q_dct[i][b+1])iB16++;else{
                     int *co=(int*)&q_dct[i][b];
                     for(int a=1;a<8;a++){
                        if(co[a]){iB16++;break;}
                     }
                  }
               }
            }
         }
       //  ed->iAllBlocks=iB16==tf[iBitFlag]*4;
         //ed->vlc.addB(ed->iAllBlocks);
         //if(!ed->iAllBlocks)
         {
            ed->iBlocks8orMore=iB16>8;
            ed->vlc.addB(ed->iBlocks8orMore);
         }
      }
      ed->iBlocksED=tf[iBitFlag];
#else
      static const int tf[]={0,1,1,2,
                             1,2,2,3,
                             1,2,2,3,
                             2,3,3,4};

      ed->iAllBlocks=ed->iBlocks8orMore=0;
      ed->iBlocksED=tf[iBitFlag];
      if(tf[iBitFlag]>2){

         int iB16=0;
         for(i=0;i<4;i++){
            if(iBitFlag&(1<<i) && iB16<=8){
               for(int b=0;b<64;b+=16){
                     long long  *co=(long long*)&q_dct[i][b];
                     if(co[0]|co[1]|co[2]|co[3]){iB16++;}
               }
            }
         }
       //  ed->iAllBlocks=iB16==tf[iBitFlag]*4;
         //ed->vlc.addB(ed->iAllBlocks);
         //if(!ed->iAllBlocks)
         if(iB16>8){
            ed->iBlocks8orMore=1;
            iBitFlag|=32;
         }
            //ed->iBlocks8orMore=iB16>8;
      }

//     encDCF<iPic>(ed, ed->vlc, &dctDC[0], k, iBitFlag+(ed->iBlocks8orMore?32:0)+((iHasDCs>1 || (!dctDC[0] && iHasDCs))<<4));
     encDCF<iPic>(ed, ed->vlc, &dctDC[0], k, iBitFlag+((iHasDCs>1 || (!dctDC[0] && iHasDCs))<<4));
     iDCBitCnt=ed->vlc.iBitPos-iBitPos;
     iBitPosDC=ed->vlc.iBitPos;

#endif
      if(iBitFlag&15 && iPic)memset(ed->prx,0,sizeof(ed->prx));
     for(i=0;i<4;i++){
        if(iBitFlag&(1<<i)){
            if(iEncodeSeperateDC){
               ed->enc4x_15(&q_dct[i][0],0,k,iPic==0);
               iDecFlags[i]=ed->iDecDct4x4;
               ed->deQ4x4_Flag<iPic>(&q_dct[i][0],&dct[i][0],t,iDecFlags[i]);
            }
            else{
               ed->enc4x(&q_dct[i][0],0,k,iPic==0);
               iDecFlags[i]=15;//ed->iDecDct4x4;
               ed->deQ<iPic,0>(&q_dct[i][0],&dct[i][0],t);
            }
            iBlocksEnc16+=tf[iDecFlags[i]];
        }
        else iDecFlags[i]=0;
     }

     /*
      if(iPic==0 && analizeSkipN(pCur,pRef,stride,((t[1]+40)>>6))){
         pEncStat->iSkip1[k]++;
         if(ed->iIsFirstPass)ctx->mb->col[k].iSkip=MB16_2::eSkip4;
         LOGT("s4");
         return 0;
      }
*/
#ifdef T_USE_DEC_REP_Q      
     //iMaxQ>3-(iIsB|ed->iThisWasB)*2 &&
     int bReq=(ctx->i>>4)+(ctx->j>>4)*(ctx->w>>4);
     bReq=ed->iReqBits*(bReq+1)/((ctx->h>>4)*(ctx->w>>4));
     if(!iPic &&!k && iRep==0 &&  !(b))ed->iIncBitrateN= ed->vlc.iBitPos<bReq;
     if(  !iPic &&!k && iRep==0 &&  !(b)&&  (( (ed->vlc.iBitPos-iBitPos)*2<ed->iAvgBlockBits) ||  (ed->iIncBitrateN && (ed->vlc.iBitPos-iBitPos)<ed->iAvgBlockBits*3)))//iMaxQ>1 && (iMaxQ>1 || ed->vlc.iBitPos-iBitPos>150-(iIsB|ed->iThisWasB)*180))
    // if(  !iPic &&!k && iRep==0 &&  !(b)&& (( (ed->vlc.iBitPos-iBitPos)*2<ed->iAvgBlockBits)))
     {iRep=1;goto rep_decBits;}
     if(iRep){
        for(i=0;i<16;i++){
           //--dctDC[i]<<=1;
        }
        for(i=0;i<256;i++){dct[0][i]>>=1;}
     }
#endif
     if(ed->vlc.iCalcBitsOnly || i_CanRestore==-2 || (b && (iMaxQDC>2 || iMaxQ>2))){
        if(!ed->vlc.iCalcBitsOnly && i_CanRestore!=-2){
         char *getDeblFlags(int iDecx, int w, int h);
         char *dbl=getDeblFlags(iDec,ctx->w,ctx->h);
         int xc=ctx->w>>4;
         int iPos2=(ctx->i>>4)+(ctx->j>>4)*xc;
         dbl[iPos2]&=~16;
        }
        return iHasDCs || iBlocksEnc;
     }

     
     // || (!ed->iIsReferenceFrame || iBlocksEnc)
     //
     if(iPic && iBestBits){
        int iBitsX=ed->vlc.iBitPos-iBitPos;
        // iBitsX*=8;iBitsX/=10;
        //--getMBParams(ctx->i>>3, (ctx->j)>>3, k, ctx->w, m, iSad, iMinPosSad, iTryMode, iDev, iVecLen);
        m=ctx->m;
        if((iBlocksEnc || !ed->iIsReferenceFrame))
        {
           int iBitsRem=0;

           if( m ||  (b) /*|| (!k && iSad<iMinPosSad+300 )*/)iBitsRem=0;else iBitsRem=iBestBits>>3;


           //iBitsRem=-(iBestBits>>3)+20;
           if(iBitsRem>(iBestBits>>3))iBitsRem=(iBestBits>>3);
           if(iBitsRem<4)iBitsRem=4;
           //iBitsRem=-iBestBits/8;
iBitsRem=(iBestBits>>3);
           iBitsX-=iBitsRem;
           // iBitsX+=iBlocksEnc;
           //           iBitsX+=iBlocksEnc16;

           //iBitsX*=3;iBitsX>>=2;

           if((iBestBits<iBitsX )){//521 1112// && (!ed->iIsReferenceFrame || iBlocksEnc)){
              //debugsi("bb-new old------------",iBitsX+iBitsRem-iBestBits);
              return 0;
           }

//           debugsi("bb-new old======",iBitsX+iBitsRem-iBestBits);

           //if(iDev>iSad || iSad>iMinPosSad+2000)iBitsX-=(iDCBitCnt>>2);
        }
        else{ 
           if(iBestBits*2<iBitsX+5)return 0;
           //debugss("bbb",ed->vlc.iBitPos-iBitPos,iBestBits);if(iBestBits<30)debugss("bbb, sad dev",iSad,iDev);


        }
           LOGV(iBitsX);
     }

     //if(iSQErrStart>ed->iSQQuantErrUV*(k?3:8) && (iBlocksEnc16 || !iLowDC))iStartPsnr=0;
     //iIsB=0;
     //---    if(iIsB && (iStartPsnr==0 ||!iCanRestore)&& iPic==0)return 1;
     //if(cnt==100 && )iCanRestore=0;
     //debugss("iDCBitsCnt",iDCBitsCnt,iHasDCs);

   }
   else {//dec
      //int iNewBitsTest=0;
      //int dcBitsOld=0;
      int iThisGain=0;
#ifdef T_USE_DEC_REP_Q      
      int iRep=0;
      if(!k && !iPic)iRep=ed->vlc.getB();
#endif

      int iBitFlag=0;
      decDCF<iPic>(ed, ed->vlc, &dctDC[0],iHasDCs, k, iBitFlag);

      if(iBitFlag&15 && iPic)memset(ed->prx,0,sizeof(ed->prx));
      for(i=0;i<4;i++){

         if(iBitFlag&(1<<i)){//ed->vlc.getB()){
            dct[i][0]=dct[i][16]=dct[i][32]=dct[i][48]=0;
            if(iPic){
               int ret=ed->dec4x_15<2>(&dct[i][0],k,t);if(ret<0)return ret;
            }
            else{
               int ret=ed->dec4x_15<1>(&dct[i][0],k,t);if(ret<0)return ret;
            }
            iDecFlags[i]=ed->iDecDct4x4;
            iBlocksEnc++;
            static const int tf[]={0,1,1,2,
               1,2,2,3,
               1,2,2,3,
               2,3,3,4};
            iBlocksEnc16+=tf[iDecFlags[i]];
         }
         else {
            dct[i][0]=dct[i][16]=dct[i][32]=dct[i][48]=0;
            iDecFlags[i]=0;
         }
      }
#ifdef T_USE_DEC_REP_Q      
      if(iRep){
//   for(i=0;i<256;i++){dct[0][i]++;dct[0][i]>>=1;}

   for(i=0;i<256;i++){dct[0][i]>>=1;}
      }
#endif

      if(ed->iSkipPutBlocks)return 0;
      if(ed->iVisDecoder){
         short sb[64];
         memset(sb,150,128);

         
         int o=((ctx->h-ctx->j-16)-ctx->j)*stride;
         int blo=iDecFlags[0]|iDecFlags[3]|iDecFlags[2]|iDecFlags[1];
         if(blo){
            ofs=0;
            dbg_pic(ed,pCur+o+ofs,&sb[0],stride,iDecFlags[2],k,iPic);
            ofs=24;
            dbg_pic(ed,pCur+o+ofs,&sb[0],stride,iDecFlags[3],k,iPic);
            ofs=stride*8;
            dbg_pic(ed,pCur+o+ofs,&sb[0],stride,iDecFlags[0],k,iPic);
            ofs=stride*8+24;
            dbg_pic(ed,pCur+o+ofs,&sb[0],stride,iDecFlags[1],k,iPic);
         }
         int c=iPic|ctx->iIsPic?235:40;
         if(k==0)o++;
         for(i=0;i<16;i++){
            pCur[o+i*3+stride*k]=c;
            pCur[o+i*3+stride*15-stride*k]=c;
            pCur[o+i*stride+k*3]=c;
            pCur[o+15*3+i*stride-k*3]=c;
         }
#if !defined(_WIN32_WCE) && !defined(__SYMBIAN32__) && !defined(ARM) && !defined(ANDROID_NDK) && !defined(__APPLE__)
         void debugIntValue(int v, unsigned char *p, int stride);
         if(!k){
            debugIntValue(ed->vlc.iBitPos-iBitPos-iThisGain,pCur+stride*2+o+2,stride);
    //        debugIntValue(sc,pCur+stride*(2+6)+o+1+10*3,stride);
         }
         else 
            debugIntValue(ed->vlc.iBitPos-iBitPos-iThisGain,pCur+stride*(2+6)+o+2,stride);
#endif

         return 0;
      }
   }




  // int iDecDif=0;
int iDCCleared=0;
   #undef _SET_DC
#define _SET_DC(_A,_B,_C) dct[_B][_C]=dctDC[_A];
   int dc0=0;
   int dcS0=dctDC[0];
     //for(int a=0;a<256;a++){if(dct[0][a]>0)dct[0][a]+=t[0]/4;else if(dct[0][a]<0)dct[0][a]-=t[0]/4;}
  
   if(iHasDCs){
      dc0=abs(dcS0);
      //int dc1=max(abs(dctDC[1]),abs(dctDC[4]));
      

     // if(iPic)iDCQ+=(iDCQ>>4);
      //if(!k){iDCQ*=9;iDCQ&=~3;iDCQ>>=3;}
      //&& (!iPic ||k)
      //iDCQ<<=4;
      if(dc0 && iHasDCs==1 ){
         if(!iPic && !iDec && !iBlocksEnc && dc0*iDCQ<(80+(b)*128)){// || (((dc0*iDCQ+4)>>3)<((iDCQ+2)>>2)  )){
            pEncStat->iSkipQ[k]++;
            ctx->mb->col[k].iSkip=MB16_2::eSkip5;
           LOGT("skdc1");
            return 0;
         }
         //int iDQ=(iDCQ);

        // idct4x4dc_s(&dctDC[0]);
         //T_FIX_DC(dctDC[0],iDCQ)
        //??? idct4x4dc_s(&dctDC[0]);for(i=0;i<16;i++)dctDC[i]>>=3;
         if((iDCQ&7)){
          //  debugsi("aa",iDCQ);
           dctDC[0]=(dctDC[0]*iDCQ+4)>>3;//T_FIX_DC(dctDC[i],(iDQ>>sh))
               //dctDC[i]+=(dctDC[i]>0)<<1;dctDC[i]>>=2;
         }
         else
         {
            int iDQ=(iDCQ)>>3;
               dctDC[0]=dctDC[0]*(iDQ);//T_FIX_DC(dctDC[i],iDQ)
         }
         //dctDC[0]=(dctDC[0]*iDCQ+4)>>3;
         for(i=1;i<16;i++)dctDC[i]=dctDC[0];
      }
      else 
      {
         //void idwt(int *p);
         //idwt(&dctDC[0]);
            //if(!k)for(i=0;i<16;i++){dctDC[i]*=(tma[i]);}idct4x4dc_s(&dctDC[0]);int iDQ=(iDCQ>>(k?1:3));//>>1;//<<1;//>>1;
            idct4x4dc_s(&dctDC[0]);
         
         

         //--int sh=2;while(sh && iDQ>1 && (!(iDQ&1))){iDQ>>=1;sh>>=1;}
//         if(iDQ>1 && (!(iDQ&1))){iDQ>>=1;sh>>=1;}
         
         //dctDC[0]+=sh;
      //iDCQ>>=1;
         //3
            
         if((iDCQ&7)){
          //  debugsi("aa",iDCQ);
            
            for(i=0;i<16;i++){
               dctDC[i]=(dctDC[i]*iDCQ+4)>>3;//T_FIX_DC(dctDC[i],(iDQ>>sh))
               //dctDC[i]+=(dctDC[i]>0)<<1;dctDC[i]>>=2;
            }
         }
         else
         {
            int iDQ=(iDCQ)>>3;
            //iDQ>>=1;
            for(i=0;i<16;i++){
               dctDC[i]=dctDC[i]*(iDQ);//T_FIX_DC(dctDC[i],iDQ)
               //if(dctDC[i]<0)dctDC[i]+=(iDQ>>2);else if(dctDC[i]<0)dctDC[i]-=(iDQ>>2);
          //     if(!k){dctDC[i]/=tmu;dctDC[i]*=tmu;}
            }
         }
         
      }
      //iDCQ<<=4;

      if(!iPic && !iDec &&  !iBlocksEnc && iTestSkipDC && iMaxQDC<3 && 
         ((k && iMaxQDC<2)||(!k && iSad<iDev && iSad<iMinPosSad+100)) && !(dc0 && iHasDCs==1)&&(!dc0 || ( dc0*iDCQ<(40*(2+((b)))))) 
         
         && (iMaxQDC<2 || iMaxQDC*iDCQ<16*(2+(b)))){ //|| (dc0 && iHasDCs==1 && dc0*5<t[0]*2)
         int iCanSkip=1;
//         int fs=k?(iDCQ>>7):setFTabA(t[0],iPic);
         int fs=k?(0):setFTabA(t[0],iPic);

        // int iFC=_GET_FC(t[1]+(iPic?(t[1]>>2):0),iDCQ);//((iDCQ+20)>>5);+Pic jo bias lielaaks
         //_GET_FC(fs, t[1],(iDCQ>>iPic));
         //int iFC=_GET_FC(t[1]+(iPic?(t[1]>>1):0),(iDCQ>>iPic));//((iDCQ+20)>>5);+Pic jo bias lielaaks
        // if(iFC>200)iFC=200;
        // int fs=setFSTabVal(iFC,t[0],t[1]);
         
//            const int dcL=(((fs*12)+t[0])>>(2+(!!k)))+10;//(t[0]+16)>>(2+(!!k));//
            const int dcL=k?((t[0]>>2)+8):((fs)*20+(!fs)*12);//((t[0])>>(3+(!!k)))+10+fs*16;//(t[0]+16)>>(2+(!!k));//
                       //((t[0]*9)>>(4+(!!k)*2))+10;
            //const int dcL=fs*16-4;//((t[0]*5)>>(3+(!!k)))+10;
            for(i=0;i<16;i++){
               if(dctDC[i]>dcL || dctDC[i]<-dcL){iCanSkip=0;break;}
               //if(dcthis*2>dcL*3){iCanSkip=0;break;}
            }
            if(iCanSkip){
               pEncStat->iSkipQ[k]++;
               ctx->mb->col[k].iSkip=MB16_2::eSkip8;
           LOGT("sk-dc");
               return 0;
            }
         

      }
      
      
      _SET_DC(0,0,0); _SET_DC(1,0,16);_SET_DC(2,1,0); _SET_DC(3,1,16);
      _SET_DC(4,0,32); _SET_DC(5,0,48);_SET_DC(6,1,32); _SET_DC(7,1,48);
      _SET_DC(8,2,0);_SET_DC(9,2,16);_SET_DC(10,3,0); _SET_DC(11,3,16); 
      _SET_DC(12,2,32);  _SET_DC(13,2,48); _SET_DC(14,3,32);_SET_DC(15,3,48);
#undef _SET_DC
   }

 
   const int iRestoreB=0;

   ctx->iPrevDCCnt=iHasDCs+iBlocksEnc16*16;

//-------------------   //&& !k && iDev<4000
   // 
   int iSSim=0;
   int iTestSSIMSkip=0;
   int iStartPsnr=0;
   int iRStartPsnr=0;
   if(!iPic && !iDec){
      if(iTestSSIMSkip && !m&&
         !k && (iSad+100)*7>iMinPosSad*8 && iMaxQDC<3){
         float ssim=get_ssim(pCur,pRef,stride,k);//+(k?0.2f:0.0f);
         iSSim=(int)(ssim*1000.f);
         setSSIM_STAT(ctx->i>>4,ctx->j>>4,k,ctx->w,iSSim);
         if(!m && iSSim<800 )return 7;
      }

      //||(dc0>2 && dc0*iDCQ>12))
      //|| (dc0>1 && dc0*iDCQ>(100+(iIsB|ed->iThisWasB)*28))
      if(!iTestPSNRSkip){}else 
      if((!k && (iSad>iDev || (iSad>iMinPosSad+200))) || ed->iIsReferenceFrame || iMaxQDC+iMaxQ>3){}else 
      if(
      (!dc0 && k && iMaxQDC<2 && (iMaxQ|iMaxQDC)*t[0]<128) ||
      ((
      (!k && iSad<iMinPosSad)
      || (!k &&   iMaxQ+iMaxQDC<3 && (iMaxQ<=iIsB || iMaxQ*t[1]<48 || !iBlocksEnc) && (iMaxQDC<=iIsB || iMaxQDC*t[0]<48) //&& iSad*2<iMinPosSad+iDCQ
       //  && (( iSad<iDev+100 && iSad<iMinPosSad+iDCQ+50) || !iBlocksEnc)//-- && (iMaxQ<3 || iMaxDC<16)
         )))){
            int getBlockPSNR_SQ_F(unsigned char *p ,unsigned char *o, int stride, int step, int &iDif, int &f, const int iLim);;
            iRStartPsnr=iStartPsnr=
               k?getBlockPSNR_UV_SQ(pCur,pRef,16,16,stride,3,iSQErrStart):getBlockPSNR_SQ(pCur,pRef,16,16,stride,3,iSQErrStart);
               //getBlockPSNR_SQ_F(pCur,pRef,stride,3,iSQErrStart,iFastCheckMode,ed->iSQQuantErr4x4Y);
            if(m==100)iStartPsnr+=80;
            else if((!dc0 || ( dc0*iDCQ<(40*(2+(!!(b)))))))iStartPsnr+=40;
            if(iStartPsnr>iLastFramePsnr+100)iStartPsnr+=20;
            /*
            if(!k && iSQErrStart<ed->iSQQuantErr4x4Y){
               pEncStat->iSkipQ[k]++;
               ctx->mb->col[k].iSkip=MB16_2::eSkip7;
               debugsi("psnrSk",iStartPsnr);
               return 0;
            }
            */
            iCanRestore=1;
      }
      if(((iIsB) && iRestoreB==0)&& !iStartPsnr)return 1;
      //-------------------
      if(iStartPsnr || iSSim){
         //if(!k)iStartPsnr=iRStartPsnr=blockQ(pCur,pRef,stride);
         if(!iIsB || iRestoreB)TDCTX::getBlock16(&saved[0],pCur,stride);
      }
      else iCanRestore=0;
   }

   if(!iBlocksEnc16 && ((dcS0 && iHasDCs==1) || (iPic && iHasDCs==0))){
      void putDC16x16(DCT_TYPE dc_c, unsigned char *dstp, int stride);
      void addDC16x16(DCT_TYPE dc_c, unsigned char *dstp, int stride);
      if(iPic &&iPicR){
           putDC16x16(dct[0][0],pCur,stride);
      }else 
         addDC16x16(dct[0][0],pCur,stride);

    }
    /*else if(!iBlocksEnc16){
       void inc4x_s3(unsigned char *pCur, int iAdd, int strdie,  int *dc);
       inc4x_s3(pCur,!(iPic &&iPicR),stride,&dctDC[0]);
       iHasDCs=0;

    }*/else{
       /*
       if((iHasDCs>1 || (!dcS0 && iHasDCs==1)) && (!iPicR || !iBlocksEnc16)){
int iNew=1;
//for(int a=1;a<16;a++){if(abs(dctDC[a])>t[0]){iNew=0;break;}}
//if(iNew)
{
          void inc4x_s3(unsigned char *pCur, int iAdd, int strdie,  int *dc);
          inc4x_s3(pCur,!(iPic &&iPicR),stride,&dctDC[0]);
          if(!iBlocksEnc16)iHasDCs=0;
#define _SET_DC(_A,_B,_C) dct[_B][_C]=0;
      _SET_DC(0,0,0); _SET_DC(1,0,16);_SET_DC(2,1,0); _SET_DC(3,1,16);
      _SET_DC(4,0,32); _SET_DC(5,0,48);_SET_DC(6,1,32); _SET_DC(7,1,48);
      _SET_DC(8,2,0);_SET_DC(9,2,16);_SET_DC(10,3,0); _SET_DC(11,3,16); 
      _SET_DC(12,2,32);  _SET_DC(13,2,48); _SET_DC(14,3,32);_SET_DC(15,3,48);
#undef _SET_DC
      iPicR=0;
      //for(int a=0;a<256;a++){if(dct[0][a]>t[0])dct[0][a]-=t[0];else if(dct[0][a]<-t[0])dct[0][a]+=t[0];}
}
}
*/

      ofs=0;
      DEC_4x4(0,0);
      DEC_4x4(1,8*3);
      DEC_4x4(2,stride*8);
      DEC_4x4(3,stride*8+8*3);
    }
   int psnr=0;
   
   
   if(!iDec && !iPic){
      if(iTestSSIMSkip && iSSim){
         float ssim=get_ssim(pCur,pRef,stride,k);//+(k?0.2f:0.0f);
         int iSS=(int)(ssim*1000.f);
         if(iSSim*65+10>iSS*64){
            pEncStat->iSkipLast[k]++;
            ctx->mb->col[k].iSkip=MB16_2::eSkipSSIM;
            if(!iIsB)TDCTX::getBlock16(&saved[0],pCur,stride);
            return 0;
         }
      }
      if(iStartPsnr && iCanRestore){

      //iIsBigCost=;
      

//         int psnr=k?getBlockPSNR_UV(pCur,pRef,16,16,stride,3):getBlockPSNR(pCur,pRef,16,16,stride,3);
         psnr=k?getBlockPSNR_UV_SQ(pCur,pRef,16,16,stride,3,iSQErrEnd):getBlockPSNR_SQ(pCur,pRef,16,16,stride,3,iSQErrEnd);
            setPSNR_STAT(ctx->i>>4,ctx->j>>4,k,ctx->w,iRStartPsnr,psnr);
           LOGV(psnr);

         do{
            const int wb=!!(iIsB|ed->iThisWasB);
//break;
            int d=psnr-iStartPsnr;
            int dr=psnr-iRStartPsnr;
            if(k && !iBlocksEnc){d*=2;dr*=2;}
            //if(dr>200)break;
            
            int bc=ed->vlc.iBitPos-iBitPos;

            iIsBigCost=bc*3>d*2;
            //if(d<50)
            if(dr>80+wb*20)break;
            if(d>t[1]*2 && bc*2<d)break;
            if(dr>50){
               if(dr>bc*(2+wb+(!!k)))break;
               if(!k  && bc*5<d && d>t[1]*2+30)break;
               if(!k  && bc<d && d>t[1]*4+60)break;
               //if(!k  && b<d && d>200-t[1] && d>t[0]*2)break;
               //if(d>t[0]*4+40 && iRStartPsnr<iLastFramePsnr+100)break;
               //if(((psnr>iLastFramePsnr+100 && iLastFramePsnr)|| d>300 || bc*(4+wb*4)<d || (iDev>iSad+300 && d>70+wb*30))&& d>80+wb*30)break;
            }
            if(1){
               if(!iIsB || iRestoreB)TDCTX::putBlock16(&saved[0],pCur,stride);
               pEncStat->iSkipLast[k]++;
              // debugsi(k?"psnrSk-k":"psnrSk",b);
               ctx->mb->col[k].iSkip=MB16_2::eSkipLast;
               //void debugsi(char*,int);              
            //   debugsi("msq============",k+100*(iMaxQDC*100+iMaxQ));
            
//if(!iIsB && !k)debugss("skl1",dr,b);
               return 0;
            }
         }while(0);


         ctx->iLastBlockPsnr=psnr;
      }
   //      debugss("------psnr",psnr,iStartPsnr);
     //    debugss("------psnr",ed->vlc.iBitPos-iBitPos,k*100+iIsB);
   }
   if(!iDec && !iPic &&  !iIsB){
#ifdef _TI4x4
      if(!m && !iIsB && iSad*4>iDev && iSad>iMinPosSad+200 && ed->vlc.iBitPos-iBitPos>120)iIsBigCost=1;else
#endif
     // if(iDev<iSad)iIsBigCost=m==0;else
      iIsBigCost=0;
      if(m || (iFastBlockType && !k))iIsBigCost=0;// || (iTryMode==0 && iSad<iDev)
      else if((!k && (iSad>iMinPosSad || iSad>iDev) ) || (k && ed->vlc.iBitPos-iBitPos>10)) iIsBigCost=1;
      /*
      else
      if(iHada==1){
         iIsBigCost=0;
      }
      else if(iIsBigCost==4)iIsBigCost=1;
      else if(iLastFramePsnr && iSad<iDev && iMinPosSad>6000 && iRStartPsnr+100>iLastFramePsnr)iIsBigCost=0;
      else if(iBlocksEnc16==0 && ed->vlc.iBitPos-iBitPos<34 && iHasDCs<4 && iLastFramePsnr && iSad<iDev+200 && (iSad<iDev+100 || iRStartPsnr>iLastFramePsnr || psnr>iLastFramePsnr+200))iIsBigCost=0;
      else if(!k && !iIsB){
         // m==0??????????
         if(//(iSad*2>iMinPosSad*3+200+iDCQ && iSad*3>iDev)||
            (iSad>iDev && iSad>iMinPosSad+200+iDCQ && iSad>iDCQ*2) 
            || (iSad>iMinPosSad*2+100 && iSad*2>iDev) 
            //|| (iSad*3>iMinPosSad*4+100 && iSad*2>iDev+200) 
            || (iSad>iMinPosSad+500 && iSad*2>iDev+2000))
            iIsBigCost=1;else iIsBigCost=0;
         
      }
      */
      //if(iMaxQ>1 && iSad*2>iMinPosSad*3 && !m)iIsBigCost=1;
     // if(!m && iSad>iDev)return 7;
#ifdef T_USE_PRED16
      if(iSad<iDev)iIsBigCost=0;
#endif
   }
   //iIsBigCost=1;
   //iIsBigCost=1;
   /*
   if(!iDec && ed->iIsReferenceFrame)
TDCTX::getBlock16(&saved[0],pRef,stride);
TDCTX::putBlock16(&saved[0],pCur,stride);
   }
   */
   ctx->iBlocksEnc16=iBlocksEnc16;
   if(!iDec && psnr && !iIsB)ctx->mb->col[k].iPrevStartPsnr=psnr;
int iDifFileterd=0;
if(((!iDec  && !g_iSkipLoop)  || ed->iFilter) && t[0]>19  &&(iDec || !iIsB || iRestoreB)){
      void filter_4x4_16_f(unsigned char *p, int stride, int a, int *f);
      void filter_4x4_16_dc(unsigned char *p, int stride, int dc);
      void filter_4x4_16_a(unsigned char *p, int stride, int a);
      void filter_16_top(unsigned char *p, int stride, int a);
      void filter_16_left(unsigned char *p, int stride, int a);
      void filter_4x4_16_a_dcf(unsigned char *p, int stride, int a, int *f, int *dc);
      //if(iFXTest)
      {//iFAll|iIsB|ed->iThisWasB){
        
         //--int iFC=(t[1]>>4)+(iDCQ>>5);
         //--
         //--
         int fs;
//         int iFC=_GET_FC(fs, t[1],(iDCQ>>iPic));//((iDCQ+20)>>5);+Pic jo bias lielaaks
   fs=setFTabA(t[0],iPic);//+(!!iPic)*(t[0]>>2));
         
         if(fs){
//                  iFC=((iDCQ<<(iPic && !ed->iIsKey))+t[1]+48)>>4;
                 // iFC=((iDCQ<<(!iPic))+t[1]+48)>>4;
           //321 int iFC=(t[0]*2+iDCQ*(1+(!iPic))+32+t[1]*2)>>5;//6+4+9
//            int iFC=(t[1]+t[0]+iDCQ*(1+(!iPic))+32)>>4;//6+4+9
            int iFC=((t[1]+t[0]+iDCQ*(1+(!iPic))+64)>>4);//6+4+9
            //if(!iDec && !(ctx->i && ctx->j) && !k && iHasDCs>1){debugsi("fs",fs);debugsi("a",iFC);}
                  //iFC=((iDCQ<<(!!iPic ))+t[1]+48)>>4;

         if(iFC>200)iFC=200;

           //--iFC=(iDCQ+t[1]*2)>>4;//12;if(k)iFC+=4;
            if(iPic && !iBlocksEnc){
               //int iFC2=(iDCQ>>3)+1;
               //TODO fast filter if iMaxDCQ<2
               if(t[0]>24 && ((!dcS0 && iHasDCs) ||  iHasDCs>1))
                  filter_4x4_16_dc(pCur,  stride,iFC);//iDCQ/12);
                  //filter_4x4_16_a_dcf(pCur,  stride, iFC,&iDecFlags[0],NULL);
            }
            else if((!dcS0 && iHasDCs) ||  iHasDCs>1 || (iBlocksEnc)){
         //      if(iDec && !k)debugsi("db fc",iFC);
              
               //void filter_4x4_16_a_dcf(unsigned char *p, int stride, int a, int *f, int *dc){
               filter_4x4_16_a_dcf(pCur,  stride, iFC,&iDecFlags[0],iPic?&dctDC[0]:NULL);
            }
        //   fxMB(pCur,iFC>>1,stride);

         }
            if(!k)iDifFileterd=1;
      }
   }

if(!k ){
   char *getDeblFlags(int iDecx, int w, int h);
   char *dbl=getDeblFlags(iDec,ctx->w,ctx->h);
   if(dbl){
      int xc=ctx->w>>4;
      int iPos2=(ctx->i>>4)+(ctx->j>>4)*xc;
      
      //if(t[0]<16 || t[1]<48){dbl[iPos2]=64;}else
      

      //if(!k)
      dbl[iPos2]&=~16;

      if(iDCQ<40){
         dbl[iPos2]|=64;
         if(ctx->i && (dbl[iPos2-1]&64)){dbl[iPos2]&=~(8|2);}
         if(ctx->j && (dbl[iPos2-xc]&64)){dbl[iPos2]&=~(4|1);}
      }
      else{
         dbl[iPos2]|=4|8;
         if(ctx->i+16<ctx->w)dbl[iPos2+1]|=8;
         dbl[iPos2+xc]|=4;
      }
      if(iPic)dbl[iPos2]&=~(32|16);
      else if(t[1]>48 && iDCQ>40){if(!iPic && !iDifFileterd &&  (!dcS0  || iHasDCs>1 || (iBlocksEnc))) dbl[iPos2]|=32;}
      
   }
}
LOGT("ok");
   /*

   if(iPic){
      int iBx=ed->vlc.iBitPos-iBitPos;iBx*=3;iBx/=10;
      iBitsG+=iBx;
   }
*/
//if(!iPic && !iDec && !k)debugsi("dev",iDev/((ed->vlc.iBitPos-iBitPos)));

   
   //if(!iDec)debugss("psnr",iRStartPsnr,t[0]);
   //if(iDec && !k)debugss("bits-Y",ed->vlc.iBitPos-iBitPos,iHasDCs+iPic*100);
   //if(iDec && k)debugss("bits-UY",ed->vlc.iBitPos-iBitPos,iHasDCs+iPic*100);
   return 1;
}



#endif
template  <int iDec, int iPic>
static int encMB16_okO(ENC_BL_CTX *ctx, TDCTX *ed, unsigned char *pCur, unsigned char *pRef, int stride,int k,int  iIsB, int i_CanRestore, int &iIsBigCost, int iBestBits=0){
  

//   if(iDec && k)return 0;
//#define  iPic 0
  // DECLARE_ALIGNED(DCT_TYPE saved[256],8);
  // if(iPic==0 && k==0)return 0;
   //????????? if(iPic && ed->iIsKey && !k)return encPicMB16W<iDec,iPic>(ctx,ed,pCur,pRef,stride,iBestBits);
   //if(!k)return encPicMB16W<iDec,iPic>(ctx,ed,pCur,pRef,stride,iBestBits);
//#define _TI4x4
   //T_ALIGN_64(unsigned char,saved,256);
   //__declspec(align(x))

   DECLARE_ALIGNED(unsigned char  saved[256],32);
   DECLARE_ALIGNED(DCT_TYPE dct[4][64],16);
   DECLARE_ALIGNED(DCT_TYPE q_dct[4][64],16);
   DECLARE_ALIGNED(int dctDC[17],32);
   //DCT_TYPE dct[4][64];
   //DCT_TYPE  q_dct[4][64];
   int iStartPsnr=0;
//k=0;
   const int *t=k?&ed->tab_uv[128]:&ed->tab_y[128];
   int s,iCoefs;//,iMaxCoef;
   int i;
   int ofs;
   int iMaxQ=0;
//   int iPos;
   int iHasDCs=0;
   int iBlocksEnc=0;
   int iBlocksEnc16=0;
   int iBitPos=ed->vlc.iBitPos;
   int iBitPosDC=0;
   //int iDCBitsCnt=0;
   int iCanRestore=!iDec && ctx->iIsPic==0 && iPic==0  && i_CanRestore!=-1 && !ed->iIsKey && i_CanRestore!=-7;
  // if(iIsB)iCanRestore=0;
   if(ed->iIsReferenceFrame){ed->iIsB=iIsB=0;}
   int iDCQ;
   int iDecFlags[4]={0xff,0xff,0xff,0xff};
   int iWasB=ed->iThisWasB;
   int b=!!(iIsB|ed->iThisWasB|ed->iThisWasBX);
   int iCanBePic=!iDec && !ctx->iIsPic && iPic==0 && !iWasB && !iIsB&& (!k || !ctx->iHasUVMode);
  // if(iIsB || iWasB)iCanRestore=0;
   //if(!iPic)ed->iPredDC=0;

//k=1;
#ifdef T_encMB16_DCTd24x4_UV
   if(k)
      return encMB16_DCTd24x4_UV<iDec,iPic>(ctx,ed,pCur,pRef,stride,k,iIsB,i_CanRestore, iIsBigCost, iBestBits);
#endif
   if(iPic){
      iDCQ=(t[0]*3+ed->iDCQuant)>>2;//(t[0]*4+ed->iDCQuant+4)>>2;
      //iDCQ=((t[0]*2+ed->iDCQuant+8))>>1;
      if(iDCQ>512){iDCQ+=512;iDCQ>>=1;}
      else if(iDCQ<8){iDCQ+=8;iDCQ>>=1;}
   }
   else{
    //  iDCQ=((t[0]*4+ed->iDCQuant*2+16))>>1;
      iDCQ=(t[0]*4+ed->iDCQuant+8)>>2;//(t[0]+16)>>1;
      if(iDCQ>1024){iDCQ+=1024;iDCQ>>=1;}
      else if(iDCQ<16){iDCQ+=16;iDCQ>>=1;}
      
   }
  // if(!k && !iPic){iDCQ+=48;iDCQ>>=2;}
   

   if(k && ctx->iHasUVMode && ctx->iDCDifAbs>iIsB)  iCanRestore=0;  
//   if(iIsB)iCanRestore=0;
   //iDCQ*=2;

int iSQErrStart=0,iSQErrEnd,iRStartPsnr=0;


//iDCQ=ed->iIsReferenceFrame?24:30;

//iDCQ=60;
   if(k)iDCQ+=64;
  
   if(iIsB)iDCQ+=128;
  //if(k)iDCQ=t[0];
   iDCQ++;iDCQ&=~1;
  // if(iIsB && !ctx->i && !ctx->j && !iDec)debugss("dcq",iDCQ,t[0]);
   //if(!k && !iIsB){iDCQ=t[0]*2+3;iDCQ&=~3;}
//iCanRestore=0;
   //if(!k)iDCQ=8;
//   iDCQ+=3;iDCQ&=~3;
//----------------------
   //
#ifdef _TEST_T_BITS
   //ed->iHasBigCoefs=0;
   //ed->iGBits=0;
   //if(k || iPic){
   if(k || iPic)memset(ed->prx,0,sizeof(ed->prx));//TODO *(int*)prx=0
   //memset(ed->prxt,0,sizeof(ed->prxt));
   //memset(ed->pr1,0,sizeof(ed->pr1));
  // memset(ed->pr0,0,sizeof(ed->pr0));
   //if(!k){ed->pr1[1]=1;ed->pr1[1]=1;}
   //}
   ed->iPrevCode=0;
   SET_DCQ
//   if(iPic && !ed->iIsKey){iDCQ=(t[0]*6+9)>>4;iDCQ<<=3;}
iDCQ=k?ed->iDCQuantUV:ed->iDCQuant;
  // if(iPic)iDCQ>>=1;
   if(iPic && !ed->iIsKey){iDCQ*=5;iDCQ>>=2;iDCQ+=7;iDCQ&=~7;}//else {iDCQ+=7;iDCQ&=~7;}
  // iDCQ>>=1;
   //iDCQ=4;
   //if(iPic && !ed->iIsKey){iDCQ*=2;}
   //iDCQ=32;
#endif
   //iDCQ=t[0]*4;
   //----------------------?????????????????????????---------------------->>
   int iIncKeyDCQ=0;
   //--if(!ed->iIsKey &&  iPic){iDCQ<<=1;iIncKeyDCQ=1;}
   //----------------------?????????????????????????----------------------<<
   ctx->iDCQ=iDCQ;
  // int iPsnrLim=ed->iQVal*17+3100;
  // int iSSim=0;
   int iMaxDC=0;
   int iDCDif=0;
//   int iCanRestoreIfDc=0;
//   int iClearArtifacts=1;
//   int iIncRestoreAndDecMinPsnr=0;
   int iBitX;
//   int iEncDCOnly=0;
   int iSkipQOnly=0;
   int iCanSkipFast=1;
   int iACTested=0;
   int iDCBitCnt=0;
   int iMaxQDC=0;
//iDCQ=16;//+=64;iDCQ>>=2;
   int m=k?2:0,iSad=2500,iMinPosSad=2000,iTryMode=1,iDev=6000,iVecLen=4;
      int iCanSkipX=1;
/*
      if(!iDec && iCanRestore && (k && !iIsB)){
         return 7;
         int ar=analize(pCur, pRef,  stride,  k, iIsB, t);
         if(ar==7)return 7;
         if(ar==0)return 0;
         return 7;
         iCanRestore=0;
      }
      */
//   int iMinDC=1000000;
   int getBlockPSNR_UV(unsigned char *p ,unsigned char *o, int w, int h, int stride, int step);

   int iHada=-1;
   //if(!iPic && !iDec && !iIsB && testSendPic(pCur,pRef,stride))return 7;
   //iCanRestore=0;
      //if(!iPic && !iDec && !iIsB && ((ctx->j>>4)&3)==3)return 7;
      //if(!iPic && !iDec && !iIsB && ((ctx->i>>4)&7)==3)return 7;
   T_LOG_START
//#define v_log(_A) video_log(b,ctx->i>>4,ctx->j>>4,_A);
//if(!iIsB && !iPic && !iDec && k)return 7;
   if(!iPic && !iDec && k==0){
      //getMBParams(ctx->i>>3, (ctx->j)>>3, k, ctx->w, m, iSad, iMinPosSad, iTryMode, iDev, iVecLen);
      
      //if(!m && !iIsB && (iSad*3>iDev*4+iDCQ+10000 || iSad>iDev+1000) && iSad*3>iMinPosSad*5+iDCQ)return 7;
      getMBParamHada(ctx->i>>3, ctx->j>>3, k, ctx->w,iHada);
      //iHada=-1;
      if(!ed->iIsReferenceFrame && !ed->iIsKey && i_CanRestore!=-7 && !ctx->iIsPic){

         if(iHada==0){
LOGT("hada0");
            ctx->mb->col[k].iSkip=MB16_2::eSkipQ;
            pEncStat->iSkipQ[k]++;

            return 0;
         }

      }
      if(ed->iIsReferenceFrame && !iIsB && iHada<0)iCanRestore=0;
   }
   int iFastBlockType=!iDec && !iPic && useFastBlockType();


   int iSkipFast=1;
   if(iHada==0 || iIsB ||ed->iThisWasB)iSkipFast=0;
   //  int iNeedGain300=0;
   int iSkMinTested=0;
   int iSadUV=-1;
   /*
   if(k && !iDec && !iPic){

      
      //static int iLimSk=ed->iSQQuantErr4x4Y*4;
         if(ctx->iHasUVMode)iSadUV=ctx->iUVSad;
         else if(!getMBParamUV(ctx->i>>3, (ctx->j)>>3, k, ctx->w,iSadUV))
            iSadUV=-1;
     //    if(iSadUV>=0 && iSadUV*8<t[0]+12)iSadUV=sadInt(pCur,pRef,stride,t[0]*2+500);
LOGV(iSadUV);
    //  if(iSadUV>=0 && iSadUV*8<t[0]+12 && iSadUV<64)return 0;
      if(iSadUV>30 && (ctx->mb->col[0].iType==ctx->mb->ePic4x4 || ctx->mb->col[k-1].iType==ctx->mb->ePic4x4) && !b){
         getMBParams(ctx->i>>3, (ctx->j)>>3, k, ctx->w, m, iSad, iMinPosSad, iTryMode, iDev, iVecLen);
         if(!m && iSadUV>iDev)return 7;
      }
   }

   else 
      */if(!iDec && !iPic && !ed->iIsKey && !ctx->iIsPic && !k){


      getMBParams(ctx->i>>3, (ctx->j)>>3, k, ctx->w, m, iSad, iMinPosSad, iTryMode, iDev, iVecLen);
      ctx->m=m;
//v_log("m=%d,s=%d,d=%d,ms=%d,",m,iSad,iDev,iMinPosSad);
LOGV(m);LOGI(iSad);LOGI(iDev);LOGI(iMinPosSad);

      if(iSad*2<t[0] && iSad<iMinPosSad+50 && iSad<iDev+50){
         ctx->mb->col[k].iSkip=MB16_2::eSkip7;
         pEncStat->iSkip1[k]++;
         LOGT("sk7");
         return 0;
      }
      
      //m=0;
      //if(!iDec && !iPic && !iIsB  && !m &&   iSad>iMinPosSad+iDCQ && iSad*4>iDev && testSendPic(pCur,pRef,stride))return 7;
//      if(!iIsB && !m && (iSad>iMinPosSad+iDCQ*2+200 || iSad>iDev+t[0]*8+400) && iSad*4>iDev){
    //  if(!iIsB && !m && (iSad*4)>(iMinPosSad+iDev*3+iDCQ+800))return 7;
      if(iSad<10+(b)*100 )return 0;
      if(!iIsB && !m && iSad>t[0]){// && iSad>iDev+200){
        // return 7;
         if(iSad>iDev+t[0]+150 && iSad>iMinPosSad)return 7;
         if(iSad>iDev*2+100 && iSad>iMinPosSad+100)return 7;
         if(iSad>iDev+100 && iSad>iMinPosSad*2)return 7;
         //if(iSad>iDev+100+t[0] && iSad>(iMinPosSad-100)+t[0])return 7;
         //if(iSad>iDev*2+(t[0]>>2) && iSad>(iMinPosSad-100))return 7;
         LOGT("ret7");
         if(iSad>t[0] && iSad*3>(iMinPosSad-200)*4+200 && iSad>iDev+100 && !(b)){
            if(iDev*2<t[0]+20)return 7;
         }
         if(ed->iIsReferenceFrame ||iSad>iDev+((t[0]+800)>>3)){
            if(iSad>t[0]*2 && iSad>iDev && iDev*3<t[0])return 7;
            if(ctx->i && ctx->iPrevDCCnt<=10 && ctx->mb[-1].col->iType==MB16_2::ePic4x4 
               && !(b) && iSad*3>iMinPosSad*5+300+(iDCQ>>2) && iSad*4>iDev*4+200+(iDCQ>>2) && iDev<5000)return 7;
            if(ed->iIsReferenceFrame){
               
               if(iDev*2+20<t[0])return 7;

               if(iSad>iDev+(iDCQ>>2)+100)return 7;
               if(iSad*3>iMinPosSad*4+(iDCQ)+300 && iDev<4000)return 7;
               if(iSad>iMinPosSad+iDCQ && iSad>iDev+200)return 7;
            }
            if(iDev<iDCQ*4+400 && iSad>iDev+(iDCQ>>2)+256+(b)*256)return 7;

            if((iSad>iMinPosSad+iDCQ+500) && iSad*3>iDev*2+500+iDCQ && (iSad>iDev || iSad>iMinPosSad*5 || iDev<8000 || iSad*5>iDev*4+5000)){// && !ed->iThisWasB &&  !ed->iThisWasBX){
               //if(iDif>(t[0]>>4)+2 && iSad>iDev+200)return 7;
               //if(iSad>iDev+iDCQ+100)return 7;
               //if(iSad>iDev+iDCQ+256)return 7;
               if(iSad>iDev && iSad>iDCQ*4+256)return 7;
               if(iSad>iDev+128+(iDCQ>>1) && iSad>iDCQ*4+(SADT?SADT[2]*100:250))return 7;
               if(testSendPic(pCur,pRef,stride))return 7;
            }
            if(iFastBlockType && iSad>iDev+iDCQ+(SADT?SADT[2]*100:250))return 7;
         }
      }
      if( (iSad<100+t[0]*8 || iSad*6<iMinPosSad*4 || (iSad+100<iDev && m>1)))iCanBePic=0;
      if( (iSad>iDev+2000+(iIsB ||ed->iThisWasB)*500 || iSad>iMinPosSad*2+2000+(iIsB ||ed->iThisWasB)*500))iCanRestore=0;
      //if(iDif>(iDCQ>>7)+(iIsB|ed->iThisWasB) && (iDev<2000))iCanRestore=0;

      if(iHada==1 && iMinPosSad<800)iCanRestore=0;
      if(iSad*4>iDev*5+300 && (b))iCanRestore=0;
      

      if((iIsB|ed->iThisWasB) && m==100 && iSad<iDev && iSad*2<iMinPosSad && (iSad<(50+iDCQ)*2 )){
         ctx->mb->col[k].iSkip=MB16_2::eSkip5;
         pEncStat->iSkip1[k]++;
         return 0;
      }
/*
      if(!k && iSad<iMinPosSad+800+iDCQ && canSkipMD(pCur,pRef,stride,(iDCQ>>8)+1)){
         return 0;
      }
*/

      if(0&&iCanRestore){

         int iWB=iWasB|ed->iIsB;
         if((iIsB|ed->iThisWasB) && m==100 && iSad*2<iMinPosSad &&  (iSad<(100+iDCQ)*8|| iSad*4+50<iMinPosSad )){
            ctx->mb->col[k].iSkip=MB16_2::eSkip4;
            pEncStat->iSkip1[k]++;
            return 0;
         }

         if(iVecLen>7 && iWB && iLastFramePsnr && !k&& !ed->iIsReferenceFrame &&  m==100 && iSad<iDev+iDCQ*2 && iSad*(5-iWB)<iMinPosSad*3+iDCQ*2){
            int iFCM=0;
            iStartPsnr=getBlockPSNR_SQ_F(pCur,pRef,stride,3,iSQErrStart,iFCM,ed->iSQQuantErr4x4Y);
            if(iSQErrStart<ed->iSQQuantErr4x4Y || iStartPsnr<iLastFramePsnr+iWB*200){
               ctx->mb->col[k].iSkip=MB16_2::eSkip7;
               pEncStat->iSkip1[k]++;
               return 0;
            }
         }
      }
      if(iHada<0){
         //if(!k && !(iIsB|ed->iThisWasB) && ((iSad>iDev*2+iDCQ*2+50 && iSad>iMinPosSad*2+iDCQ) || (iSad>iDev+iDCQ*4+100 && iSad>iMinPosSad*5+400)))return 7;

#if 0
#if 1
         if(!m && !iIsB  && iSad*4>iMinPosSad*5+100 && iSad>400 && (iSad>iDev+((256*iDCQ)>>7)+256 || iSad>iDev+SADT[3]*iDCQ+SADT[3]*64))return 7;

         if(ed->iIsReferenceFrame && SADT && iDev<4000 && (iDev-SADT[(iDCQ>>7)+1]*256<20 || iSad>iDev-SADT[(iDCQ>>7)+1]*64))return 7;
         if(iSad*4>iMinPosSad*5+100 && iSad>iDCQ*4+200 && iCanBePic && !m && !(iIsB|ed->iThisWasB) && !k && ed->iFramesAfterKey>4 && iSad>iDev+iDCQ*8 && iSad>iDev+800+ed->iSQQuantErr4x4Y && (iSad>iDev*3+300 || iSad>iMinPosSad+800 || iSad>iMinPosSad*2+200))return 7;
         int iPicDetected=0;
         if(iSad*4>iMinPosSad*5+100 && iSad>iDCQ*4+200 && iCanBePic && !m && !(b) && !k && (iSad>iMinPosSad+500  || (ed->iIsReferenceFrame)) && iSad>iDev+20 && ed->iFramesAfterKey>2){
            if(ed->iIsReferenceFrame &&   (iMinPosSad<500 || iDev<400))return 7;
            //if(!m && iSad>iDev*2+800)return 7;
            if(iSad>iDev+1000+iDCQ*8)return 7;
            int iBias=0;
            if(iCanBePic &&  SADT){
               iBias+=(iDCQ+t[1])*256>>4;
               iBias+=SADT[(t[1]>>5)+1]*256+1000+SADT[(iDif>3?3:iDif)]*256;
               if(ed->iFramesAfterKey<3){iBias+=SADT[(t[1]>>4)+1]*256;}
               if(iWasB)iBias+=SADT[3]*256;
               //if(iBias<SADT[2+(iIsB|iWasB)]*256)iBias=SADT[2+(iIsB|iWasB)]*256;
               if(iDif>4+iWasB && iSad>iDev+iBias)return 7;
            }
            else iBias+=200+((iDCQ>>7)+2)*256;

            if((iSad>iMinPosSad+500  && (iDev<20000 || iSad*2>iDev*3+5000)) || ed->iIsReferenceFrame){


               //iBias+=2000;
               if(SADT && iSad>iDev+SADT[(iDCQ>>7)+1]*256 && iSad<2000)return 7;
               if(iDif>8 && SADT && iSad>iDev+SADT[(iDif>12?12:iDif)]+100)return 7;
               if(iDif>1 && ((iSad*4>iDev*3+(iBias>>1)+1000 && iDif>3)||(iSad>iDev+iBias)) && ((iSad*2>iDev+iBias && iDif>4) || iSad*6>iDev*5+iBias) && 
                  //   ((SADT && iSad>iMinPosSad+(SADT[iDif+1]*256)+iBias)|| (!SADT && iSad>iMinPosSad+(iDif+1)*256+iBias)))iPicDetected++;
                  (iSad>iDev+iBias*3 || (SADT && iSad>iMinPosSad+(SADT[(iDif>24?24:iDif)+1]*256)+iBias)|| (!SADT && iSad>iMinPosSad+(iDif+1)*256+iBias)))iPicDetected++;
               if(ed->iIsReferenceFrame && ed->iFramesAfterKey>12){
                  if(iSad>iDev+iBias && (iMinPosSad+400<iDev || iSad*3>iMinPosSad*2))iPicDetected++;
                  if(iSad>iMinPosSad+300+iDCQ*4 && iSad*2>iDev+iBias)iPicDetected++;

                  if(iSad>iMinPosSad+200 && iSad*3>iDev*2+iBias)iPicDetected++;
                  if(iDev<3000 && iSad*2>iDev+256 && (iSad>iMinPosSad || iSad*3>iDev*2+iDCQ))iPicDetected++;
                  if(iPicDetected>1)return 7;
                  if(iDev<20 || iMinPosSad<430)return 7;
                  if(iSad>iDev+256 && iSad>iMinPosSad)return 7;
               }
               if(iCanBePic && SADT){
                  if(iSad>iDev+SADT[((iDif>(t[1]>>5)?(t[1]>>5):iDif))+1]*256+iBias)iPicDetected++;
                  //-- if(iSad>SADT[iDif+t[1]/20+t[0]/6]*256)iCanRestore=0;
               }
               if(iPicDetected){
                  return 7;
                  if(iPicDetected>1)return 7;
                  //      float ssim=get_ssim(pCur,pRef,stride,k);//+(k?0.2f:0.0f);
                  //            iSSim=(int)(ssim*1000.f);
                  //          setSSIM_STAT(ctx->i>>4,ctx->j>>4,k,ctx->w,iSSim);
                  //        if(iSSim<800)return 7;
               }
               //if(ed- && SADT && ((iSad>iDev+SADT[4]*256+iBias && iSad*2>iMinPosSad*3+SADT[8]*256+iBias) || (iSad>iDev+iBias+1000)))return 7;
            }
         }
#endif
#endif

      }//iHada

      //(dc>>4)*128
      if(!iPic && iSad>iMinPosSad+t[0]*(8+iIsB*2)+50)iCanSkipFast=0;
   }
   int iFastCheckMode=iDec || iTryMode>>5;
   if(iDec || (k || iPic))iFastCheckMode=0;
   
   iTryMode&=31;//
#if 0
   if(0&&!iPic && !iDec && ( m==100)&& (ed->iThisWasB|ed->iThisWasBX|iIsB) 
      && !k && iSad<iMinPosSad+200+2*iDCQ && !ed->iIsReferenceFrame){
      iSkMinTested=1;
      if(analizeSkip(pCur,pRef,stride,iDCQ)){
         pEncStat->iSkip1[k]++;
         if(ed->iIsFirstPass)ctx->mb->col[k].iSkip=MB16_2::eSkip1;
         return 0;
      }
   }
   if(!iPic && !iDec && iCanRestore && k &&0){
 
      //return 7;
      //int dif=mmabs(((pCur[0]+pCur[3]+pCur[12]+pCur[42]+2)>>2)-((pRef[0]-pRef[3]-pRef[12]-pRef[42]+2)>>2))-iIsB;
      int iSadUV=-1;
      //static int iLimSk=ed->iSQQuantErr4x4Y*4;
      if(1||ed->iIsFirstPass || !ctx->mb){
         if(ctx->iHasUVMode && k)iSadUV=ctx->iUVSad;
         else if(!getMBParamUV(ctx->i>>3, (ctx->j)>>3, k, ctx->w,iSadUV)){
            iSadUV=-1;
         }
         else {
            if(k && iSadUV>=0 && iSadUV<48-ed->iIsReferenceFrame*32+iIsB*30)return 0;
         }
         if(iSadUV==-1 )iSadUV=800;
        
       // iNeedGain300=!k && iSad*3+300<iMinPosSad*2;
        /*
        if(ed->iFramesAfterKey>2 && !iWasB){
//   if(iFramesAfterKey<3)iBias*=3;
           if(!k && m==0 && !iIsB && iSad*3>iDev*2 && iSad>iDev+iDCQ+1000 && iSad+5000>iDev &&
              (iMinPosSad<480+ed->iIsReferenceFrame*50 || 
              (ed->iIsReferenceFrame &&  (iSad>iDev || iSad*3>iMinPosSad*4+100) )
              ||( iSad>iDev+200 && iSad>iMinPosSad*2+300)||
              iSad*2>iMinPosSad*3+4000) 
              && iSad>iDCQ*4+100)return 7;

           if(m==0 && !iIsB && iSad+5000>iDev && iSad*3>iDev &&   iSad>iDev+iDCQ+1000 && iSad*2>iMinPosSad*3 && 
              (iDev*4<iMinPosSad*3 ||  iSad*3>iMinPosSad*2+600) && iDev<iSad && (iSad>2000 || iDev*3<iSad*2) && (iCanBePic))return 7;
         }
         */
        //if(ed->iFramesAfterKey>12 && ed->iIsReferenceFrame && !m && ((iDev+40<iSad &&  iSad*3>iMinPosSad*4) || (iDev>iSad)))return 7;
//if(!iIsB && iSad>iDev*2 && m==0 && iSad*3>iMinPosSad)return 7;
        int getBlockPSNR_SQ_F(unsigned char *p ,unsigned char *o, int stride, int step, int &iDif, int &f, const int iLim);
        
        if(k&& ctx->iHasUVMode){iDif=ctx->iDCDifAbs;iStartPsnr=ctx->iUVPsnr;iSQErrStart=ctx->iUVSadSQ;}else {
           if(k)
              iStartPsnr=getBlockPSNR_UV_SQ(pCur,pRef,16,16,stride,3,iSQErrStart);
           else{
              
             iStartPsnr=getBlockPSNR_SQ_F(pCur,pRef,stride,3,iSQErrStart,iFastCheckMode,ed->iSQQuantErr4x4Y);
             ctx->iUVPsnr=iStartPsnr;

              if(!k && iHada!=1 && (iSad<iDev+400 && iSad<iMinPosSad+400)&& iDif<=(iDCQ>>7)+1 && iDif<=(iIsB|ed->iThisWasB) && iFastCheckMode==(1|2|4|8)){
            setSSIM_STAT(ctx->i>>4,ctx->j>>4,k,ctx->w,0);
            setPSNR_STAT(ctx->i>>4,ctx->j>>4,k,ctx->w,iStartPsnr,0);
                pEncStat->iSkip3[k]++;
                if(ed->iIsFirstPass)ctx->mb->col[k].iSkip=MB16_2::eSkip3;
                return 0;
              }
              if(!iFastCheckMode && !k && !m && iCanBePic && ed->iFramesAfterKey>3 && iSad*5>iDev*4+500 && iStartPsnr+800<iLastFramePsnr)return 7;
              //if(ctx->i,)debugss("spsnr",t[0],iStartPsnr);

           {
              int mp=iMinPosSad-350;
              if(mp<2)mp=2;
              iStartPsnr+=(int)((log((double)mp)-7)*50);//57000 133KB
           }

              //iStartPsnr=getBlockPSNR_SQ(pCur,pRef,16,16,stride,3,iSQErrStart);
           }
           //if(!k)iStartPsnr+=(int)((log((double)iMinPosSad)-9)*60);//57100 134KB
           //if(!k)iStartPsnr+=(int)((log((double)iMinPosSad)-8)*50);//57000 133KB
           //if(!k)iStartPsnr+=(int)((log((double)iMinPosSad)-8.5)*100);
           

//           iStartPsnr=k?getBlockPSNR_UV_SQ(pCur,pRef,16,16,stride,3,iSQErrStart):getBlockPSNR_SQ(pCur,pRef,16,16,stride,3,iSQErrStart);
        }
         if(ctx->mb){
            ctx->mb->col[k].iStartPsnr=iStartPsnr;
            ctx->mb->col[k].iSQErrStart=iSQErrStart;
         }

      ctx->iLastBlockPsnr=iRStartPsnr=iStartPsnr;
      if(!k &&iSQErrStart<ed->iSQQuantErr4x4Y && (iSad<iDev || iSad<iMinPosSad+100))return 0;
        //if(iLastFramePsnr && !ed->iIsReferenceFrame && iLastFramePsnr-iIsB*200<iStartPsnr)return 0;
      
//???iStartPsnr+=(k?300:200);//corect psnr sq dc add

// iSad, iMinPosSad, iTryMode, iDev, iVecLen
if(iSad<iMinPosSad && iVecLen*(1+(iIsB|ed->iThisWasB)*2)>8){
   if(!k && (iIsB|ed->iThisWasB) && m<2)return 0;
   iStartPsnr+=50;
}
         
//if(iStartPsnr<4100-iIsB*100)iStartPsnr-=500;
         
         setSSIM_STAT(ctx->i>>4,ctx->j>>4,k,ctx->w,0);
         setPSNR_STAT(ctx->i>>4,ctx->j>>4,k,ctx->w,iStartPsnr,0);

        if(iSad<iDev+300 && iSad<iMinPosSad+300 && (iIsB|ed->iThisWasB) && !k && iLastFramePsnr && iLastFramePsnr<iRStartPsnr){
           pEncStat->iSkipPsnr[k]++;
          if(ed->iIsFirstPass)ctx->mb->col[k].iSkip=MB16_2::eSkipPsnr;
          return 0;
        }

/*
         if(0&&(!ctx->iHasUVMode || ctx->iDCDifAbs<7) && iSkipFast 
            && (!ed->iIsReferenceFrame && iDif==0)&&  (iDif==0 || iWasB || iIsB) 
            && ((iSadUV>=0 && iSadUV<300-ed->iIsReferenceFrame*150+iIsB*100) || iIsB) 
           && iDif<2 && (iDif*96<iDCQ || iDif==0) && 
            iCanSkipX && k>0 
            && ctx->mb->col[k].iSkip==MB16_2::eSkipTest && ctx->mb->col[k-1].iSkip!=MB16_2::eNotSkiped  
            && ((iStartPsnr>4400) ||(iStartPsnr>4200 && k==2))){
            pEncStat->iSkipPsnr[k]++;
            if(!iIsB)ctx->mb->col[k].iSkip=MB16_2::eSkipPsnr;
            return 0;
         }
         */
         //if(iStartPsnr>3700-iIsB*200+ed->iIsReferenceFrame*500)return 0;
      }
      else {
         if(k)return 0;
         if(ctx->mb->col[k].iSkip==MB16_2::eNotSkiped || ctx->mb->col[k].iSkip==MB16_2::eSkipQ)return 0;
         iStartPsnr=ctx->mb->col[k].iStartPsnr;
         iSQErrStart=ctx->mb->col[k].iSQErrStart;
      }


      if(!(iIsB|ed->iThisWasB) && k && iLastFramePsnr && iLastFramePsnr>iStartPsnr){iCanRestore=0;iStartPsnr=0;}
      
      if(!k &&iSkipFast && iSad<iMinPosSad+500 && iSad<iDev+200 && iDif<=(iDCQ>>7)){
         if(iLastFramePsnr && iLastFramePsnr-(iIsB|ed->iThisWasB)*300+(k?200:0)+ed->iIsReferenceFrame*400+300<iRStartPsnr 
            && iSad*(ed->iIsReferenceFrame+1)<iMinPosSad)
         {
            pEncStat->iSkipPsnr[k]++;
            if(!(iIsB|ed->iThisWasB))ctx->mb->col[k].iSkip=MB16_2::eSkipPsnr;
           // if(!iIsB)iLimSk=iSQErrStart;
            return 0;
         }
     
         if(iStartPsnr>6400 || (iLastFramePsnr && iLastFramePsnr+200<iRStartPsnr && iSQErrStart<96+(iIsB|ed->iThisWasB)*256-ed->iIsReferenceFrame*64)){
            ctx->mb->col[k].iSkip=MB16_2::eSkipPsnr;
            pEncStat->iSkipPsnr[k]++;
            return 0;
         }
         /*
         if(iStartPsnr>2800 && ((k==0  || iIsB || iVecLen==0) && 
            ((iRStartPsnr==ctx->mb->col[k].iPrevStartPsnr && !k) || 
            (k && iRStartPsnr==ctx->mb->col[k].iPrevStartPsnr))) && iDev==ctx->mb->iPrevDev){
            if(m==0 && iSkipFast && !ed->iIsReferenceFrame){
               if(iIsB || ctx->mb->col[k].iSkip!=MB16_2::eSkipPsnr){
                  if(!iIsB)ctx->mb->col[k].iSkip=MB16_2::eSkipQ;
                  pEncStat->iSkipQ[k]++;
                  return 0;
               }
            }
            else{
               iCanSkipX=0;
            }
            iSkipQOnly=1;
         }
         */
      }
      

      
     //if(m<1 && iStartPsnr<4000 && ed->iIsReferenceFrame && ed->iFramesAfterKey>12 && iSad>iMinPosSad+500 && (iSad*3>iMinPosSad*4+300 || iSad*3>iDev*2) && (iCanBePic))return 7;
     //if(iCanBePic && k && iStartPsnr<4200 && ed->iIsReferenceFrame && iSadUV>1000)return 7;
//if(iStartPsnr>3400-iIsB*100 && iSad*4<iMinPosSad*5)return 0;

      if(!(iIsB|ed->iThisWasB)){
         if(ctx->mb->col[k].iSkip!=MB16_2::eSkipQ)ctx->mb->col[k].iSkip=MB16_2::eSkipPsnr;
         ctx->mb->iPrevDev=iDev;
         ctx->mb->col[k].iPrevStartPsnr=iRStartPsnr;
      }

      iStartPsnr*=(iMinPosSad+200000+(k?200000:0));
      iStartPsnr/=(iSad+200250-(iIsB|ed->iThisWasB)*150+ed->iIsReferenceFrame*200+(k?200000:0));

      if(m && m!=100){
         int mm=m==1?257:258;
         iStartPsnr*=mm;  iStartPsnr+=128;iStartPsnr>>=8;
      }

//      if(iSad<iDev+500 && iLastFramePsnr && !k &&!iIsB && !ed->iIsReferenceFrame && iLastFramePsnr+200<iRStartPsnr)iCanBePic=0;

      if(iSkipFast && !k && iSad*(3-(iIsB|ed->iThisWasB))+256<iMinPosSad*2 &&  iDif<=iIsB && iLastFramePsnr && iLastFramePsnr-iIsB*300+100<iRStartPsnr){
         pEncStat->iSkipPsnr[k]++;
         if(!(iIsB|ed->iThisWasB))ctx->mb->col[k].iSkip=MB16_2::eSkipPsnr;
         return 0;
      }
      //if(k && iDif<=iIsB+1 && ((iLastFramePsnr+4000)>>1)-iIsB*300<iRStartPsnr)return 0;
/*
      if(ed->iIsReferenceFrame)iPsnrLim+=400;
      if(k)iPsnrLim+=400;
      if(k==1)iPsnrLim-=200;else if(k==2)iPsnrLim+=200;
*/
      

   }
   //if(!iPic && !iDec && !iIsB && iStartPsnr<2500 && (iSad>iMinPosSad*3+500 || (iSad*2>iDev && iSad*2>iMinPosSad*3+2000))){return 7;}
#endif


   void t_idct8_s(DCT_TYPE *t, unsigned char *dst, int stride, int iX);
   void t_fdct8_s(unsigned char *src, int stride, DCT_TYPE *d );
   void t_fdct8_s_d(unsigned char *src,unsigned char *src2, int stride, DCT_TYPE *d );;
   void t_idct8_s_put(DCT_TYPE *t, unsigned char *dst, int stride);
   void fdct4x4dc_s( int *d);
   void idct4x4dc_s( int *d);
//TODO next vers addGetBit
   int iEncodeSeperateDC=1;//iPic || k;//+.3 psnr
  // if(!iPic && !k && iDec)iEncodeSeperateDC=ed->vlc.getB();
   const int iEnableDifFilter=!iPic && (k||(iDec && (ed->iIsB|ed->iThisWasB)));//+.3 psnr//TODO detect WASB
   int iSkipAC=0;
   const int iPicR=iPic;
   //int iCheckDCSkip=1;
   if(!iDec){
   ofs=0;
   //memset(&dct[_ID][1],0,30);
     
//   if(iPic){if(k){memset(&dct[_ID][0],0,32);for(int t=0;t<16;t++){dct[_ID][0]+=(pRef[(_O)+(t&3)*3+stride*((t>>2))]-128);dct[_ID][0]*=2;dct[_ID][0]+=128*16*2;}}else t_fdct8_s(pRef+_O,stride,&dct[_ID][0]);}

   TR_2x4x4(0,0);
   TR_2x4x4(3*8,1);
   TR_2x4x4(stride*8,2);
   TR_2x4x4(stride*8+3*8,3);
	/*
   {

   TR_2x4x4(0,0);
   TR_2x4x4(3*8,1);
   TR_2x4x4(stride*8,2);
   TR_2x4x4(stride*8+3*8,3);
   }
   */
   

   void t_fdct4(DCT_TYPE *t);

   /*
   0 1 4 5 
   2 3 6 7 
   8 9 12 13 
   10 11 14 15

   */
  
//if(iEncodeSeperateDC){dct[_B][_C]=0;}
#define _SET_DC(_A,_B,_C) dctDC[_A]=dct[_B][_C];

   // iPos=0;
   _SET_DC(0,0,0); _SET_DC(1,0,16);_SET_DC(2,1,0); _SET_DC(3,1,16);
   _SET_DC(4,0,32); _SET_DC(5,0,48);_SET_DC(6,1,32); _SET_DC(7,1,48);
   _SET_DC(8,2,0);_SET_DC(9,2,16);_SET_DC(10,3,0); _SET_DC(11,3,16); 
   _SET_DC(12,2,32);  _SET_DC(13,2,48); _SET_DC(14,3,32);_SET_DC(15,3,48);

   iBitX=0;
   //for(i=0;i<16;i++){int v=(dctDC[i]+4)>>3;if(v)iBitX+=ed->getBitLen(v)+1;else iBitX++;}
   const int iDCQ2=iDCQ*2;
   const int iDCQAdd=iPic?iDCQ:(iDCQ2/6+1);//(iPic && ed->iIsKey)|| ed->iIsKey ?((int)(iDCQ2/2.1)):(iPic?(iDCQ2/3):(iDCQ2/3+1));//(iDCQ2*10/22);
   
   iHasDCs=0;
   int iMiDc=100000000;
   int iMaDc=-100000000;
  // int iGC=0;
   for(i=0;i<16;i++){
      if(iMiDc>dctDC[i])iMiDc=dctDC[i];if(iMaDc<dctDC[i])iMaDc=dctDC[i];  
     // if(!iPic && dctDC[i]<t[0] && dctDC[i]>-t[0])iGC++;
   }//-8 0
   
   iMaxDC=max(-iMiDc,iMaDc);
   iDCDif=((iMaDc-iMiDc));//*15+8)>>4;
   if(iDCDif>iMaxDC)iMaxDC=iDCDif;

LOGV(iMaxDC);
   //int block[17];


   
if(iEncodeSeperateDC){
   for(i=0;i<4;i++)dct[i][0]=dct[i][16]=dct[i][32]=dct[i][48]=0;
   /*
   if(!iPic && iStartPsnr){
      if( !k && iMinPosSad<800 && iMaxDC>(iDCQ>>3)+16) iStartPsnr=0;
      
      else if(iMaxDC>t[1] && iMaxDC>t[0]+32){
         if(iMaxDC>iDCQ+128)iStartPsnr=0; else 
   if(!iIsB && ((!k && (iMaxDC>t[1]+16)) ||(k && iMaxDC>t[1]+iDCQ)))iStartPsnr=0;
   else if(iMaxDC>t[0]+32 && iGC<4)iStartPsnr=0;
   else if(iMaxDC>t[0]+32 && iGC>12)iStartPsnr=0;
   else if(iMaxDC>t[1]+32)iStartPsnr=0;
   else if(iMaxDC>t[0]*2+32)iStartPsnr=0;
   else if(!k && iMaxDC>((t[0]*iMinPosSad)>>10)+16)iStartPsnr=0;
      }
   }
   */
   {
      //void fdwt(int *p);
    //  fdwt(&dctDC[0]);
         fdct4x4dc_s(&dctDC[0]);
         if(!k && 0){
         for(i=0;i<16;i++){dctDC[i]/=16;}
         idct4x4dc_s(&dctDC[0]);
         int tmu=t[0]>>1;
         int tdi=t[0]>>1;
         for(i=0;i<16;i++){dctDC[i]/=tdi;dctDC[i]*=tmu;}
         fdct4x4dc_s(&dctDC[0]);
         }

//         const int iDifLim=t[5];//1|k?t[5]:t[1];//iMinPosSad>10000?100:(iMinPosSad<2000?16:(iMinPosSad/125));
//         const int toDC=!k && iDCDif*(4-iPic)<t[0]?1:16;//4-iPic*2
       //  const int toDC=16;//iDCDif*2<t[0]?1:16;//4-iPic*2
         /*
         for(i=0;i<16;i++){
            const int iCur_dc=dctDC[i];
            if(iCur_dc<0){
               dctDC[i]=-((iDCQAdd-iCur_dc)/iDCQ2);
               if(dctDC[i]){
                  iHasDCs++;
                  //if(-dctDC[i]>iMaxQDC)iMaxQDC=-dctDC[i];
                  if(-dctDC[i]>iMaxQDC)iMaxQDC=-dctDC[i];
                  //if(!iPic && dctDC[i]<-1 && (iDCDif>iDifLim || dctDC[i]<-2 || !i)){iStartPsnr=0;iCheckDCSkip=0;}
               }
            }else{ 
               dctDC[i]=(iCur_dc+iDCQAdd)/iDCQ2;
               if(dctDC[i]){
                  iHasDCs++;
                  if(dctDC[i]>iMaxQDC)iMaxQDC=dctDC[i];
               }
            }
         }
         */
         //int iClearDc=0;
         ///int coRRR[16];memcpy(coRRR,dctDC,16*(sizeof(coRRR[0])));
         for(i=0;i<16;i++){
            const int _s=dctDC[i]>>31;
            const int av=(dctDC[i]+_s)^_s;
            if(av*(8)<iDCQ2*(6-iPic))dctDC[i]=0;else
            {
               dctDC[i]=(av+iDCQAdd)/iDCQ2;
               if(dctDC[i]){
                  iHasDCs++;
                  if(dctDC[i]>iMaxQDC)iMaxQDC=dctDC[i];
                  dctDC[i]=(dctDC[i]+_s)^_s;
               }
            }
            //else 
         }
         if(iHasDCs>1 || (iHasDCs && !dctDC[0])){
            //iHasDCs=optim<int,iPic>(ed,ed->vlcTest,&dctDC[0], &coRRR[0], iDCQ,iHasDCs);

         }
         LOGV(iHasDCs);
         
        // if(iClearDc==15 && iHasDCs){iHasDCs=0;memset(&dctDC[1],0,sizeof(dctDC[0])*15);if(dctDC[0])iHasDCs=1;}
         //if(toDC==1) memset(&dctDC[1],0,sizeof(dctDC[0])*15);
         
         if(iPic==0 && iHasDCs<2 && (iMaxQDC<2 || iMaxQDC*t[0]<20)){
            if(iHasDCs && dctDC[0]){if(iMaxDC>11+(b)*4) iHasDCs=1;else {iMaxDC=0;dctDC[0]=0;iHasDCs=0;iMaxQDC=0;}}

            if(k && (iSadUV>t[0] || iSadUV<0)){
            }
            else if((iWasB ||  iIsB ||k) && !iHasDCs && (k || ((m==100 || iSad*2<iMinPosSad+iDCQ) && iSad<iDev&& iSad<iMinPosSad+200 && iSad<800+iDCQ*4))){
               pEncStat->iSkip2[k]++;
               ctx->mb->col[k].iSkip=MB16_2::eSkip9;
         LOGT("sk9");
               return 0;
            }
         }
         /*
         if(iPic==0 && !k && iHasDCs && (iMaxDC<11+(b)*4 || (!dctDC[0]&& iMaxDC*4<t[0]*3))){
            memset(&dctDC[0],0,sizeof(dctDC[0])*16);
            iHasDCs=0;
            iMaxQDC=0;
            iMaxDC=0;
         }
         */
   }
   /*
   if(!iPic && iDCDif>24 && mmabs(dctDC[0])>1) iStartPsnr=0;

      if(!k && ((iSad<iDev+100 && iSad<iMinPosSad+1000) || iSad<iMinPosSad+100)&& !iPic && 
         ((iStartPsnr>3600 && iLastFramePsnr==0) ||(iLastFramePsnr&& iLastFramePsnr-(iIsB|ed->iThisWasB)*200<iStartPsnr))
         && (iIsB|ed->iThisWasB) && (!iHasDCs || (dctDC[0] && iHasDCs==1 && mmabs(dctDC[0])*iDCQ<160)) ){
         pEncStat->iSkip2[k]++;
         if(ed->iIsFirstPass)ctx->mb->col[k].iSkip=MB16_2::eSkip2;
         //debugss("sk2",dc,iStartPsnr);
         return 0;
      }
      */
      /*
   if(!iHasDCs && !iPic && iIsB && (k || (iSad<iMinPosSad+iDCQ+200 && iSad<1500))){
      pEncStat->iSkipQ[k]++;
      ctx->mb->col[k].iSkip=MB16_2::eSkip2;
      return 0;
   }
   */
   
   
//    if(iEncodeSeperateDC){for(i=0;i<4;i++)dct[i][0]=dct[i][16]=dct[i][32]=dct[i][48]=0;}
   //iLowDC0=mmabs(dctDC[0])<2 || mmabs(dctDC[0])*iDCQ<100+iIsB*96;
   //iLowDC0=mmabs(dctDC[0])<2 || mmabs(dctDC[0])*iDCQ<90+iIsB*80;
#if 0
   if(0&&iHada!=1 && !iPic && !ed->iIsKey  && !ctx->iIsPic && iStartPsnr){
      //??if(iDCDif>iDCQ2*2+8) iStartPsnr=0;
      //--if(iDCDif>t[0]*3+12) iStartPsnr=0;
      if(1&&(iHasDCs || iWasDCs)){
         //-log((double)(iSad*iSad>>8))
if(iDCDif>iDCQ+256 || (!k && iDCDif>iDCQ+128 && iSad>iDev+500)) iStartPsnr=0;else 
if(iDCDif>16 && dctDC[0] && iDCDif>t[0]*2 && iDCDif*7>t[0]*(12+log((double)(iDev)))+12+(iIsB|ed->iThisWasB)*12) iStartPsnr=0;
else if(k && iDCDif>16 && mmabs(dctDC[0])>1) iStartPsnr=0;
///if(!iLowDC0)iStartPsnr=0;
//if(!iIsB && iDCDif*3>iDCQ2*2 && iLastFramePsnr>iRStartPsnr+300)iStartPsnr=0;//TODO low check qval UV 
      }
      int dcox=mmabs(dctDC[0]);

      if(!k && (iSQErrStart<ed->iSQQuantErrUV)&& ((iSad<iDev+100 && iSad<iMinPosSad+1000) || iSad<iMinPosSad+100)
         && (iLastFramePsnr==0 || iLastFramePsnr+ed->iIsReferenceFrame*300-(iIsB|ed->iThisWasB)*300<iRStartPsnr) 
         &&  iStartPsnr>3400-(iIsB|ed->iThisWasB)*200){// || iSQErrStart<64*(iIsB?128:(ed->iIsReferenceFrame?16:64)))){
         //|| (iMaxDC<t[1] && (iWasDCs<4 || !dctDC[0]))
         if(dcox<2 && (iMaxDC<24 || !iWasDCs || (!k && iMaxDC<t[1] && iDev>5000) || iMaxDC<t[0] ||  (dctDC[0] && iHasDCs==1 && mmabs(dctDC[0])*iDCQ<150+(iIsB|ed->iThisWasB)*40))){
            pEncStat->iSkip1[k]++;
            ctx->mb->col[k].iSkip=MB16_2::eSkip5;
            //debugss("sk2",iStartPsnr,iSad);
            return 0;
         }
         iSkipAC=1;
      }
      //|| (iMaxDC<t[1] && !dctDC[0])|| (iMaxDC<t[1] && (iWasDCs<4 || !dctDC[0]))
      if(!k&&dcox<2 && iDCChecked && (!iWasDCs || (!k && iMaxDC<t[1] && iDev>5000) || iMaxDC<t[0]   )&& iSkipAC){
         pEncStat->iSkip1[k]++;
         ctx->mb->col[k].iSkip=MB16_2::eSkip6;
         return 0;
      }

      if(!k&&dcox<2 && iStartPsnr && iDCChecked && !iWasDCs && (iSad<iDev+100 && iSad<iMinPosSad+200) &&  (iLastFramePsnr && iRStartPsnr>iLastFramePsnr-(iIsB|ed->iThisWasB)*300+ed->iIsReferenceFrame*300 ) ){
        // ed->vlc.addB(1);
         pEncStat->iSkip2[k]++;
         ctx->mb->col[k].iSkip=MB16_2::eSkip2;
         //debugss("sk2",iStartPsnr,k);
         return 0;
      }
   }
#endif
}//if iPic

//int score=100;//iPic && !ed->iIsKey?0: 100;//iPic?0:100;// ?0:100;//iIgnoreDC?0:100;//iPic || iCanRestore?100:0;// && iStartPsnr>3500?0:100;
int iRep=0;
//#define T_USE_DEC_REP_Q
#ifdef T_USE_DEC_REP_Q
     // int iBlockBP=ed->vlc.iBitPos;
int iBitPosX=ed->vlc.iBitPos;
rep_decBits:

ed->vlc.iBitPos=iBitPosX;
if(!k && !iPic)ed->vlc.addB(iRep);
if(iRep){
   iBlocksEnc=0;

//   for(i=0;i<256;i++){dct[0][i]++;dct[0][i]>>=1;}
   for(i=0;i<256;i++){dct[0][i]<<=1;}
}
#endif
      int res[4]={0,0,0,0};
      //int mv_modes[]={2,4,8,16};

      int ress=0;

      if(iPic==0 && !k && (iHada==0 || iHada==1))iSkipAC=1;
      const int iLowQvalPic=iPic && !ed->iIsKey;
      
      if(0){//(iSkipAC && !k)|| (k && (ctx->iMeanUV==1 || (iPic && ctx->iMeanUV==10)))){// || (k && ed->iIsKey)){//(iEncDCOnly || iSkipAC) && i_CanRestore!=-1){
      }
      else {//if(iPic || iLastFramePsnr==0|| iRStartPsnr<iPsnrLim+200+ed->iIsReferenceFrame*400-iIsB*300){//  ||  /*!iSSim ||*/ (iSSim &&  iSSim<990-iIsB*30+ed->iIsReferenceFrame*8)){
         iACTested=1;
      //   ed->iSetFlagPic=0;
         
         for(i=0;i<4;i++){
            
            if(!iPic && iFastCheckMode&(1<<i))continue;
            //if(!iStartPsnr && !iPic && !k && !iIsB){iBlocksEnc=1;ress=2;break;}

            if(iPic){
               //s=ed->QTestN<iPic>(&dct[i][0],(iIsB|ed->iThisWasB),k);
               if(!iLowQvalPic){
                  s=ed->QFast<iPic>(&q_dct[i][0],&dct[i][0],t,64,iIsB,k,iIsB || !iMaxDC);
//                  s=ed->QFnc<&quant_pic_nonKey>(&q_dct[i][0],&dct[i][0],t,64);
               }else {
                  //if(s)
                     //s=ed->QFastLPic(&q_dct[i][0],&dct[i][0],t);
#if defined(__SYMBIAN32__)  || defined(ANDROID_NDK) || defined(__linux__) || defined(__APPLE__)
                  int _todo_pix_android_symb;
                  s=ed->QTestN<0>(&dct[i][0],iIsB,k);
#else
                  s=ed->QFnc<&quant_pic_nonKey>(&q_dct[i][0],&dct[i][0],t,64);
#endif
               }
               /*
               if(s==1){
                  int coc=0;
                  for(int a=1;a<64;a++)if(q_dct[i][a])coc++;
                  pEncStat->iOnes[k][1]+=coc-1;
               }
               */
              // else if(s)pEncStat->iOnes[k][1]--;
               
            }else {
               //if(!iPic && !k && !iIsB && iMaxDC>1){iBlocksEnc++;ress+=1;res[i]=1;break;}
               //if(iIsB && !k)s=1;else 
               if(iRep  || (iMaxQDC && t[0]>80) || t[0]>120)s=1;else s=ed->QTestN<iPic>(&dct[i][0],(iIsB|ed->iThisWasB),k); //
              //??? if(iHasDCs>1 && iStartPsnr==0 && !iPic && !k && !iIsB)s=2;
            }
              // s=ed->QTest<iPic>(&dct[i][0],t,iIsB,k); 
            //
            
           if(s){iBlocksEnc++;ress+=s;res[i]=s;if(!iPic && !k && !iIsB)break;}

         }
         //if(score<5+iIsB*2){if(iBlocksEnc)debugss("score",k,ress);ress=iBlocksEnc=0;res[0]=res[1]=res[2]=res[3]=0;}
      }

    //  const int iResLim=0;//ed->iIsReferenceFrame?0:(0+3*iIsB);
      int iLowDC=!iHasDCs || /*iMaxDC*4<t[0]*3 ||*/ iMaxDC<12+(b)*16 || (iHasDCs==15 && iMaxDC*4<t[0]*3 && iMaxQDC<2);

LOGV(iLowDC);
      //if(iMaxDC<t[1] && (iBlocksEnc==0 || ress<=iResLim))iHasDCs=0;
     if(iPic==0 && iBlocksEnc==0 
        &&   iLowDC ){// || iMaxDC<t[1] )){// || (cnt==100 && iCanRestore)){

         pEncStat->iSkipQ[k]++;
         ctx->mb->col[k].iSkip=MB16_2::eSkipQ;
//debugss("res",ress,dctDC[0]);
         return 0;
      }
     //if(!iPic && k && !b && testSendPic(pCur,pRef,stride))return 7;

//63600 256 q80


//
     /*
     if(t[0]<64&&(iIsB|ed->iThisWasB)&&!iPic && !iBlocksEnc && iHasDCs && (iHasDCs>1 || !dctDC[0])){
        iHasDCs=checkDCCoefs<iPic>(&block[0],&dctDC[0],iDCQ,iHasDCs,t[0],t[1]);
        if(!iBlocksEnc && !iHasDCs){
           pEncStat->iSkipQ[k]++;
           ctx->mb->col[k].iSkip=MB16_2::eSkipQ;
           return 0;
        }
        //iStartPsnr=0;
     }
     */
     
     //309 203
     if(!iPic && !m && !(b)  &&!k && iSad*3>iMinPosSad*4+iDCQ+100 && iSad>iDev+iDCQ &&  iSad>iDCQ+100 && !iFastBlockType){
        if(!iLowDC &&//iCanBePic && ed->iIsReferenceFrame &&   
           iSad>iDev+200){return 7;}//&& mmabs(dctDC[0])<5
     }
     int iCanSkipDC=!iEncodeSeperateDC?0:encDC<iPic>(ed, iHasDCs,&dctDC[0], k);
     if(0&&!iPic && iCanSkipDC && iHasDCs<3 && !iBlocksEnc && iMaxQDC<2){
         pEncStat->iSkipQ[k]++;
         ctx->mb->col[k].iSkip=MB16_2::eSkip1;
         return 0;
     }
     /*
#ifdef _TEST_T_BITS
     if(iPic){
        if(iDCRem && !dctDC[0])iHasDCs++;
        dctDC[0]+=iDCRem;
     }
#endif
     */
     iDCBitCnt=ed->vlc.iBitPos-iBitPos;
     iBitPosDC=ed->vlc.iBitPos;

     if((!iBlocksEnc)){// || (!iPic && ress<=iResLim && (iPic?iDCDif:iMaxDC)<t[1]))){// && (!iACTested || iDCSum<2 || !iIncCoefs  || iPic ||  iIsB || k || iHasDCs==1 || iMaxDC*2<t[0]*3|| iLowDC || iDCDif*2<t[0]*3)){
        for(i=0;i<4;i++){
           iDecFlags[i]=0;
           ed->vlc.addB(0);
           dct[i][0]=dct[i][16]=dct[i][32]=dct[i][48]=0;
        }
        //if(iClearArtifacts )memset(&dct[0][0],0,128*4);
     }
     else{
//        int iHasBlocks=iBlocksEnc;
        iBlocksEnc=0;
        ress=0;
//        const int iBadBLQ=!ed->iIsReferenceFrame && (iSad>iMinPosSad+(iDCQ>>2)+50 || iMaxQDC>1);
        // || iSad*3>iDev*2
        const int iBadBLQ=(iDev<4000 || iMinPosSad<1500) && (iSad>iMinPosSad+(iDCQ>>2)+50 || iMaxQDC>1);
        //t_guant_fnc *qfnc=iBadBLQ?&quant_dif_badBlock:&quant_dif_goodBlock;

        for(i=0;i<4;i++){

            s=res[i];
            if(!iPic){//  &&  (iFastCheckMode&(1<<i))==0){//&& iHada!=1){
               if(!iIsB && !k){//(!k||s) ){
#if defined(__SYMBIAN32__) || defined(ANDROID_NDK) || defined(__linux__) || defined(__APPLE__)

                  res[i]=s=ed->QFast<2>(&q_dct[i][0],&dct[i][0],t,64,iIsB,k,iIsB || !iMaxDC);
#else
                  res[i]=0;
#if 1
#if 1
                  if(iBadBLQ){
                     res[i]=s=ed->QFnc<&quant_dif_badBlock>(&q_dct[i][0],&dct[i][0],t,64);
//                     if(s>6)res[i]=s=ed->QFnc<&quant_dif_goodBlock>(&q_dct[i][0],&dct[i][0],t,64);

                  } else {
                     res[i]=s=ed->QFnc<&quant_dif_goodBlock>(&q_dct[i][0],&dct[i][0],t,64);
                  }
#else
                  void t_idct4_s(DCT_TYPE *t, unsigned char *dst, int stride, int iX);
                  unsigned char ccReal[12*4];
                  unsigned char ccRestored[12*4];
                  int xcnt[4];
                  for(int z=0;z<4;z++){
                     if(iBadBLQ){
                        s=ed->QFnc<&quant_dif_badBlock>(&q_dct[i][z<<4],&dct[i][z<<4],t,16);
                     } else {
                        s=ed->QFnc<&quant_dif_goodBlock>(&q_dct[i][z<<4],&dct[i][z<<4],t,16);
                     }
                     xcnt[z]=0;
                    // if(s){res[i]+=s;}else 
                     if(s>1){

                        //   inline  void deQN(DCT_TYPE *p, DCT_TYPE *deq_dct, const int *tab, int n)

                        //ed->deQN
                        DCT_TYPE blQ[16];memcpy(blQ,&q_dct[i][z<<4],16*(sizeof(DCT_TYPE)));
                        DCT_TYPE blDeQ[16];



                        blDeQ[0]=0;
                        int co[16];
                        int iCoCnt=0;
                        int coAdd=0;
                        int zz,zzz;
                        for(zz=1;zz<16;zz++){
                         //  if(blQ[zz]){co[iCoCnt]=zz;blDeQ[zz]=blQ[zz]*t[zz];iCoCnt++;}else blDeQ[zz]=0;
                             int qcoef = abs(blQ[zz]);
                             int coef = abs(dct[i][(z<<4)+zz]);
                             int dq   = t[zz];
                             //coAdd

                             if(qcoef){
                                //(qcoef==1 && qcoef * dq > coef)||
                                if (qcoef>1 && (qcoef * dq < coef && (coef < ((qcoef+1) * dq ))))
                                {
                                   co[iCoCnt]=zz;iCoCnt++;
                                }
                                else {coAdd++;}
                                blDeQ[zz]=blQ[zz]*t[zz];
                                
                             }else  blDeQ[zz]=0;
                        }
                        if(iCoCnt && iCoCnt<3){
                           DCT_TYPE blDeQr[16];
                           memcpy(&blDeQr[0],&blDeQ[0],16*(sizeof(DCT_TYPE)));
                           int bpdx=ed->vlc.iBitPos;
                           ed->enc1x_15_dif(&blQ[0], &xcnt[0], z);
                           int iBestDifB=ed->vlc.iBitPos-bpdx;ed->vlc.iBitPos=bpdx;
                           dct[i][z<<4]=0;
                           t_idct4_s(&dct[i][z<<4],&ccReal[0],12,1);
                        
                        t_idct4_s(&blDeQ[0],&ccRestored[0],12,1);
                        int ste=0;
                        int getBlock_SQ_4x4(unsigned char *p ,unsigned char *o, int stride);
                        int iErr=getBlock_SQ_4x4(&ccReal[0],&ccRestored[0],12);
                        int iBestV=-1;
                        int iCoefsCnt=0;
                        int iBestCCnt=iCoCnt;

                        for(zz=1;zz<(1<<iCoCnt);zz++)
                        //zz=(1<<iCoCnt)-1;
                        {
                           memcpy(blQ,&q_dct[i][z<<4],16*(sizeof(DCT_TYPE)));
                           memcpy(blDeQ,blDeQr,16*(sizeof(DCT_TYPE)));
                           iCoefsCnt=0;//iCoCnt;

                           for(zzz=0;zzz<iCoCnt;zzz++){
                              int pos=co[zzz];
                              if(zz &(1<<zzz)){
                                 int coef=blQ[pos];
                                 if(coef<0){
                                    coef++;
                                 }
                                 else coef--;
                                 if(coef){ blDeQ[pos]=coef*t[pos];iCoefsCnt++;}
                                 blQ[pos]=coef;
                              }else {iCoefsCnt++;blDeQ[pos]=blQ[pos]*t[pos];}
                           }
                           t_idct4_s(&blDeQ[0],&ccRestored[0],12,1);
                           int iE=getBlock_SQ_4x4(&ccReal[0],&ccRestored[0],12);
                           if(iE<=iErr){
                                 int bpd=ed->vlc.iBitPos;
                                 ed->enc1x_15_dif(&blQ[0], &xcnt[0], z);
                                 if(iBestDifB>ed->vlc.iBitPos-bpd){
                                    debugsi("bbb",iBestDifB-(ed->vlc.iBitPos-bpd));
                                    iErr=iE;
                                    iBestV=zz;
                                    iBestCCnt=iCoefsCnt;
                                    iBestDifB=ed->vlc.iBitPos-bpd;
                                 }
                                 ed->vlc.iBitPos=bpd;
                              
                           }
                        }
                        if(iBestV>=0){
                           //memcpy(blQ,&q_dct[i][z<<4],16*(sizeof(DCT_TYPE)));
                           //memset(&q_dct[i][z<<4],0,16*(sizeof(DCT_TYPE)));
                           zz=iBestV;
                           for(zzz=0;zzz<iCoCnt;zzz++){
                              int pos=co[zzz];
                              if(zz &(1<<zzz)){
                                 int coef=q_dct[i][(z<<4)+pos];
                                 if(coef<0){
                                    coef++;
                                 }
                                 else coef--;
                                 q_dct[i][(z<<4)+pos]=coef;
                              }
                           }
                        }

                        xcnt[z]=iBestCCnt+coAdd;
                        if(!(coAdd+iBestCCnt))s=0;
                        }
                        
                     }
                     res[i]+=s;
                  }
                  s=res[i];
#endif

                  //
                  
                  
                  //enc1x_15_dif(v+(j<<4), &xcnt[0], j);

                  // slower better
                  /*
                  if(!s && iBadBLQ){
                     s=ed->QFnc<&quant_dif_try2>(&q_dct[i][0],&dct[i][0],t,64);
                     if(s<4)s=0;
                     res[i]=s;
                  }
                  */

#else
                  for(int z=0;z<64;z+=16){
                     if(iBadBLQ)
                        s=ed->QFnc<&quant_dif_badBlock>(&q_dct[i][z],&dct[i][z],t,16);
                     else {
                        s=ed->QFnc<&quant_dif_goodBlock>(&q_dct[i][z],&dct[i][z],t,16);
                     }
                     
                     res[i]+=s;
                  }
                  s=res[i];
#endif 
#endif
                  
                 //-- if(s>5)iStartPsnr=0;
               }//3729,95
               else if(s) res[i]=s=ed->QFast<0>(&q_dct[i][0],&dct[i][0],t,64,iIsB,k,iIsB || !iMaxDC);
//if(!k && s>=MAXSC_Q_SZ && !iPic && !iIsB)return 7;
//               if(s>1 && !k && !m && !iPic && !iIsB &&  iSad*2>iMinPosSad*3+t[0] && iSad*2>iDev+100)return 7;
               //ed->iSetFlagPic &&


           
            }
            //381 92K
            //k dcq=t[0]*3
//------            
            //if((k) && s==1)s=0;//380 91K// var lietot ja ir filtrs


               if(iLowDC && s && !ed->iIsKey && s<8 && (k||iMaxQDC<2)){
                  int sk=0;
                  sk+=x264_mb_decimate_score(&q_dct[i][ 0],16);
                  if(sk<3)sk+=x264_mb_decimate_score(&q_dct[i][16],16);
                  if(sk<3)sk+=x264_mb_decimate_score(&q_dct[i][32],16);
                  if(sk<3)sk+=x264_mb_decimate_score(&q_dct[i][48],16);
                  if(sk<3){s=res[i]=0;}

               }

         
            if(s){//(s && !k) || s>1){// &&(!k || iMaxCoef>16)){//>iLimQ){
               if(s>iMaxQ)iMaxQ=s;
  //             if((s>1 && (t[0]>32 || ed->iIsReferenceFrame)) || s>2)iStartPsnr=0;// || t[0]>100

               ress+=s;
               ed->vlc.addB(1);
               if(iEncodeSeperateDC){
                  ed->enc4x_15(&q_dct[i][0],0,k,iPic==0);
                  iDecFlags[i]=ed->iDecDct4x4;
                  ed->deQ4x4_Flag<iPic>(&q_dct[i][0],&dct[i][0],t,iDecFlags[i]);
               }
               else{
                  ed->enc4x(&q_dct[i][0],0,k,iPic==0);
                  iDecFlags[i]=15;//ed->iDecDct4x4;
                  ed->deQ<iPic,0>(&q_dct[i][0],&dct[i][0],t);
               }
               iBlocksEnc++;
               static const int tf[]={0,1,1,2,
                                      1,2,2,3,
                                      1,2,2,3,
                                      2,3,3,4};
               iBlocksEnc16+=tf[iDecFlags[i]];
            }
            else {
               iDecFlags[i]=0;
               ed->vlc.addB(0);
               dct[i][0]=dct[i][16]=dct[i][32]=dct[i][48]=0;
               //if(iClearArtifacts)memset(&dct[i][0],0,128);
            }
            
         }
        LOGV(ress);
        if(!iPic &&  b && (!iHasDCs  ) && ress<2 && (k || iSad*2<iDev)){
           pEncStat->iSkipQ[k]++;
           ctx->mb->col[k].iSkip=MB16_2::eSkipQ;
           return 0;
        }
     }
// || iMaxDC*2<t[0]
     if(iPic==0 && (ed->iIsReferenceFrame==0 || !iHasDCs) && !iBlocksEnc){
        if((iLowDC || !iHasDCs)){// || (cnt==100 && iCanRestore)){
           pEncStat->iSkipQ[k]++;
           ctx->mb->col[k].iSkip=MB16_2::eSkipQ;
           return 0;
        }
        if( iCanSkipDC && iHasDCs<3  && iMaxQDC<2){
           pEncStat->iSkipQ[k]++;
           ctx->mb->col[k].iSkip=MB16_2::eSkip2;
           return 0;
        }


        if(!(dctDC[0]|dctDC[4]|dctDC[1]|dctDC[2]|dctDC[8]) && iMaxQDC<2 && iMaxDC*2<t[0] && !k){// || (cnt==100 && iCanRestore)){
           pEncStat->iSkipQ[k]++;
           ctx->mb->col[k].iSkip=MB16_2::eSkip3;
           //debugss("res2",ress,dctDC[0]);
           return 0;
        }
     }
     if(iPic==0 && !k &&  abs(dctDC[0]|dctDC[4]|dctDC[1])*iDCQ<(64+(iDCQ>>2)) && iMaxQ*t[0]<80 && iMaxQDC<2 
      //  && (b) //var lietot arii uz ne B
        && iSad<iMinPosSad && iSad*2<iDev)
     {
        int cs=((iMaxQDC|iMaxQ)*t[0]+16)>>4;
           if(analizeSkip(pCur,pRef,stride,(cs+(t[0]>>5)))){
           pEncStat->iSkip1[k]++;
           if(ed->iIsFirstPass)ctx->mb->col[k].iSkip=MB16_2::eSkip4;
           LOGT("s4");
           return 0;
           }
     }
     else if(iPic==0 && !k && !dctDC[0] && iSad*2<iDev+iDCQ && iSad<iMinPosSad+t[0]*2 && iMaxQDC<2 && iMaxQ<3){
        int cs=((iMaxQDC|iMaxQ)*t[0]+31)>>5;
           if(cs>2 && analizeSkip(pCur,pRef,stride,(cs+(t[0]>>5)))){
           pEncStat->iSkip1[k]++;
           if(ed->iIsFirstPass)ctx->mb->col[k].iSkip=MB16_2::eSkip4;
           LOGT("s41");
           return 0;
           }
     }/*
      if(iPic==0 && analizeSkipN(pCur,pRef,stride,((t[1]+40)>>6))){
         pEncStat->iSkip1[k]++;
         if(ed->iIsFirstPass)ctx->mb->col[k].iSkip=MB16_2::eSkip4;
         LOGT("s4");
         return 0;
      }
*/
#ifdef T_USE_DEC_REP_Q      
     //iMaxQ>3-(iIsB|ed->iThisWasB)*2 &&
     if(!ed->iIsReferenceFrame &&  !iPic &&!k && iRep==0 && !iMaxQ)//iMaxQ>1 && (iMaxQ>1 || ed->vlc.iBitPos-iBitPos>150-(iIsB|ed->iThisWasB)*180))
     {iRep=1;goto rep_decBits;}
     if(iRep){
        for(i=0;i<16;i++){
           //--dctDC[i]<<=1;
        }
        for(i=0;i<256;i++){dct[0][i]>>=1;}
     }
#endif
     if(ed->vlc.iCalcBitsOnly)return iHasDCs || iBlocksEnc;
     // || (!ed->iIsReferenceFrame || iBlocksEnc)
     //
        int iBitsX=ed->vlc.iBitPos-iBitPos;
     if(iPic && iBestBits){
        // iBitsX*=8;iBitsX/=10;
        getMBParams(ctx->i>>3, (ctx->j)>>3, k, ctx->w, m, iSad, iMinPosSad, iTryMode, iDev, iVecLen);
        if((iBlocksEnc || !ed->iIsReferenceFrame))
        {
           int iBitsRem=0;

           if( m ||  (b) || (!k && iSad<iMinPosSad+300 ))iBitsRem=0;else iBitsRem=iBestBits/8;


           //iBitsRem=-(iBestBits>>3)+20;
           if(iBitsRem>(iBitsX>>3))iBitsRem=(iBitsX>>3);
           if(iBitsRem<4)iBitsRem=4;
           //iBitsRem=-iBestBits/8;

           iBitsX-=iBitsRem;
           // iBitsX+=iBlocksEnc;
           //           iBitsX+=iBlocksEnc16;

           //iBitsX*=3;iBitsX>>=2;

           if((iBestBits<iBitsX )){//521 1112// && (!ed->iIsReferenceFrame || iBlocksEnc)){
              //debugsi("bb-new old------------",iBitsX+iBitsRem-iBestBits);
              return 0;
           }

//           debugsi("bb-new old======",iBitsX+iBitsRem-iBestBits);

           //if(iDev>iSad || iSad>iMinPosSad+2000)iBitsX-=(iDCBitCnt>>2);
        }
        else{ 
           if(iBestBits*2<iBitsX+5 && iSad<iDev)return 0;
           //debugss("bbb",ed->vlc.iBitPos-iBitPos,iBestBits);if(iBestBits<30)debugss("bbb, sad dev",iSad,iDev);


        }
     }
           LOGV(iBitsX);

     //if(iSQErrStart>ed->iSQQuantErrUV*(k?3:8) && (iBlocksEnc16 || !iLowDC))iStartPsnr=0;
     //iIsB=0;
     //---    if(iIsB && (iStartPsnr==0 ||!iCanRestore)&& iPic==0)return 1;
     //if(cnt==100 && )iCanRestore=0;
     //debugss("iDCBitsCnt",iDCBitsCnt,iHasDCs);

   }
   else {//dec
      int iNewBitsTest=0;
      int dcBitsOld=0;
      int iThisGain=0;
#ifdef T_USE_DEC_REP_Q      
      int iRep=0;
      if(!k && !iPic)iRep=ed->vlc.getB();
#endif
      if(iEncodeSeperateDC){
         int iPrevVal=(k?8:28);
         int dcs;
         iMaxQDC=0;
         dcs=(k?UV_DC_DEF:10)-ed->vlc.getDC();//ed->vlc.get_L_Val(2);

         //   int bpx=ed->vlc.iBitPos;
         if(dcs>16 || dcs<-1)return -2;
         if(dcs!=16)memset(&dctDC[0],0,sizeof(dctDC));
         iHasDCs=dcs;
         for(i=0;dcs>0;i++){
            if(i==16)return -15;
            //int val=ed->vlc.getDC():ed->vlc.getAC(); //ed->vlc.get_L_Val_S(((dcs+4-iIsB*2)>>2)+3);
            int val;
            //  int bpx=ed->vlc.iBitPos;
            if(iPrevVal>24)val=ed->vlc.get_L_Val_S(4);
            else if(iPrevVal>12)val=ed->vlc.get_L_Val_S(3);
            else if(iPrevVal>4)val=ed->vlc.get_L_Val_S(2);
            else  val=ed->vlc.getAC();


            if(val){
               // if(!iPic){iThisGain-=(abs(val)+2);iThisGain+=(ed->vlc.iBitPos-bpx);}
               dctDC[tabzz4x4[i]]=val;
               dcs--;
               iPrevVal=val;
               if(iPrevVal<0)iPrevVal=-iPrevVal;
               if(iMaxQDC<iPrevVal)iMaxQDC=iPrevVal;
            }
         }
         /*
         #ifdef _TEST_T_BITS
         if(iPic){
         int iDCRem=calcDCfromUL(pCur, ctx->i, ctx->j,iDCQ, stride);
         if(iDCRem && !dctDC[0])iHasDCs++;
         dctDC[0]+=iDCRem;
         }
         #endif
         */
#ifdef _TEST_T_BITS
         dcBitsOld=ed->vlc.iBitPos-iBitPos;
#endif
      }


      iBlocksEnc=0;
      iBlocksEnc16=0;
      //0 4 2 2 2 2 1 1 1 1 3 3 3 3 d2 d2
      static const int fX[]={1,2,4,8};


      int iFCBP=0;
      for(i=0;i<4;i++){

         if(ed->vlc.getB()){
            iFCBP|=fX[i];
            if(iEncodeSeperateDC){
               if(1){
                  dct[i][0]=dct[i][16]=dct[i][32]=dct[i][48]=0;
                  if(iPic){
                     int ret=ed->dec4x_15<2>(&dct[i][0],k,t);if(ret<0)return ret;
                  }
                  else{
                     int ret=ed->dec4x_15<1>(&dct[i][0],k,t);if(ret<0)return ret;
                  }
                  iDecFlags[i]=ed->iDecDct4x4;
               }
               else{
                  int ret=ed->dec4x_15<0>(&q_dct[i][0],k);
                  if(ret<0)return ret;
                  iDecFlags[i]=ed->iDecDct4x4;
                  ed->deQ4x4_Flag<iPic>(&q_dct[i][0],&dct[i][0],t,iDecFlags[i]);
               }
            }
            else{

               int iAdd=1;
               int ret=ed->dec4x(&q_dct[i][0],k,iAdd,iCoefs);if(ret<0)return ret;
               iDecFlags[i]=ed->iDecDct4x4;
               ed->deQ<iPic,0>(&q_dct[i][0],&dct[i][0],t);
            }
            iBlocksEnc++;
            static const int tf[]={0,1,1,2,
               1,2,2,3,
               1,2,2,3,
               2,3,3,4};
            iBlocksEnc16+=tf[iDecFlags[i]];
         }
         else {
            dct[i][0]=dct[i][16]=dct[i][32]=dct[i][48]=0;
//--            memset(&dct[i][0],0,128);
            iDecFlags[i]=0;
         }
      }
#ifdef T_USE_DEC_REP_Q      
      if(iRep){
//   for(i=0;i<256;i++){dct[0][i]++;dct[0][i]>>=1;}

   for(i=0;i<256;i++){dct[0][i]>>=1;}
      }
#endif
      int sc=0;

      if(ed->iSkipPutBlocks)return 0;
      if(ed->iVisDecoder){
         short sb[64];
         memset(sb,150,128);

         
         int o=((ctx->h-ctx->j-16)-ctx->j)*stride;
         int blo=iDecFlags[0]|iDecFlags[3]|iDecFlags[2]|iDecFlags[1];
         if(blo){
            ofs=0;
            dbg_pic(ed,pCur+o+ofs,&sb[0],stride,iDecFlags[2],k,iPic);
            ofs=24;
            dbg_pic(ed,pCur+o+ofs,&sb[0],stride,iDecFlags[3],k,iPic);
            ofs=stride*8;
            dbg_pic(ed,pCur+o+ofs,&sb[0],stride,iDecFlags[0],k,iPic);
            ofs=stride*8+24;
            dbg_pic(ed,pCur+o+ofs,&sb[0],stride,iDecFlags[1],k,iPic);
         }
         int c=iPic|ctx->iIsPic?235:40;
         if(k==0)o++;
         for(i=0;i<16;i++){
            pCur[o+i*3+stride*k]=c;
            pCur[o+i*3+stride*15-stride*k]=c;
            pCur[o+i*stride+k*3]=c;
            pCur[o+15*3+i*stride-k*3]=c;
         }
#if !defined(_WIN32_WCE) && !defined(__SYMBIAN32__) && !defined(ARM) && !defined(ANDROID_NDK)  && !defined(__APPLE__)
         void debugIntValue(int v, unsigned char *p, int stride);
         if(!k){
            debugIntValue(ed->vlc.iBitPos-iBitPos-iThisGain,pCur+stride*2+o+2,stride);
#ifdef _TEST_T_BITS
            debugIntValue(sc,pCur+stride*(2+6)+o+1+10*3,stride);
#endif
           // debugIntValue(ed->vlc.iBitPos-iBitPos,pCur+stride*2+o+3,stride);
         }
         else 
            debugIntValue(ed->vlc.iBitPos-iBitPos-iThisGain,pCur+stride*(2+6)+o+2,stride);
#endif

         return 0;
      }
   }




  // int iDecDif=0;
int iDCCleared=0;
   #undef _SET_DC
#define _SET_DC(_A,_B,_C) dct[_B][_C]=dctDC[_A];
   int dc0=0;
   int dcS0=dctDC[0];
   
   if(iHasDCs){
      dc0=abs(dcS0);
      //int dc1=max(abs(dctDC[1]),abs(dctDC[4]));
      

     // if(iPic)iDCQ+=(iDCQ>>4);
      //if(!k){iDCQ*=9;iDCQ&=~3;iDCQ>>=3;}
      //&& (!iPic ||k)
      //iDCQ<<=4;
      if(dc0 && iHasDCs==1 ){
         if(!iPic && !iDec && !iBlocksEnc && dc0*iDCQ<(80+(b)*128)){// || (((dc0*iDCQ+4)>>3)<((iDCQ+2)>>2)  )){
            pEncStat->iSkipQ[k]++;
            ctx->mb->col[k].iSkip=MB16_2::eSkip5;
           LOGT("skdc1");
            return 0;
         }
         iDCQ>>=2;

         //T_FIX_DC(dctDC[0],iDCQ)
        //??? idct4x4dc_s(&dctDC[0]);for(i=0;i<16;i++)dctDC[i]>>=3;
         dctDC[0]=(dctDC[0]*iDCQ+1)>>1;
         for(i=1;i<16;i++)dctDC[i]=dctDC[0];
      }
      else 
      {
         //void idwt(int *p);
         //idwt(&dctDC[0]);
            const int tma[]={
               4,4,4,4,
               4,4,4,5,
               4,4,5,5,
               4,5,5,5,
            };
            //if(!k)for(i=0;i<16;i++){dctDC[i]*=(tma[i]);}idct4x4dc_s(&dctDC[0]);int iDQ=(iDCQ>>(k?1:3));//>>1;//<<1;//>>1;
            idct4x4dc_s(&dctDC[0]);int iDQ=iDCQ>>1;
         
         

         int sh=2;while(sh && iDQ>1 && (!(iDQ&1))){iDQ>>=1;sh>>=1;}
//         if(iDQ>1 && (!(iDQ&1))){iDQ>>=1;sh>>=1;}
         
         //dctDC[0]+=sh;
      //iDCQ>>=1;
         //3
#define T_TEST_64BIT 0
         if(sh){
#if 0 && T_TEST_64BIT
            long long shll=(sh<<32)|sh;
            long long *d=(long long *)&dctDC[0];
            for(i=0;i<8;i++){d[i]*=iDQ;d[i]+=shll;d[i]&=;d[i]>>=sh;}
#else
            for(i=0;i<16;i++){
               dctDC[i]=(dctDC[i]*iDQ+sh)>>sh;//T_FIX_DC(dctDC[i],(iDQ>>sh))
            }
#endif
         }
         else{
#if T_TEST_64BIT
            long long *d=(long long *)&dctDC[0];
            for(i=0;i<8;i++)d[i]*=iDQ;
#else
        //    int tmu=t[0]>>1;
            for(i=0;i<16;i++){
               dctDC[i]=dctDC[i]*(iDQ);//T_FIX_DC(dctDC[i],iDQ)
          //     if(!k){dctDC[i]/=tmu;dctDC[i]*=tmu;}
            }
#endif
         }
//if(!k && iPic && dc0 && iHasDCs==1){dctDC[15]=(t[0]>>3)+9;iHasDCs++;}
         
      }
      //iDCQ<<=4;

    if(!iPic && !iDec &&  !iBlocksEnc && ((k && iMaxQDC<2)||(iSad<iDev && iSad<iMinPosSad+100)) && !(dc0 && iHasDCs==1)&&(!dc0 || ( dc0*iDCQ<(40*(2+((b)))))) 
         
         && (iMaxQDC<2 || iMaxQDC*iDCQ<16*(2+(b)))){ //|| (dc0 && iHasDCs==1 && dc0*5<t[0]*2)
         int iCanSkip=1;
         int fs;
        // int iFC=_GET_FC(t[1]+(iPic?(t[1]>>2):0),iDCQ);//((iDCQ+20)>>5);+Pic jo bias lielaaks
         _GET_FC(fs, t[1],(iDCQ>>iPic));
         //int iFC=_GET_FC(t[1]+(iPic?(t[1]>>1):0),(iDCQ>>iPic));//((iDCQ+20)>>5);+Pic jo bias lielaaks
        // if(iFC>200)iFC=200;
        // int fs=setFSTabVal(iFC,t[0],t[1]);
         
            const int dcL=((t[0])>>(2+(!!k)))+10+fs*16;//(t[0]+16)>>(2+(!!k));//
                       //((t[0]*9)>>(4+(!!k)*2))+10;
            //const int dcL=fs*16-4;//((t[0]*5)>>(3+(!!k)))+10;
            for(i=0;i<16;i++){
               if(dctDC[i]>dcL || dctDC[i]<-dcL){iCanSkip=0;break;}
               //if(dcthis*2>dcL*3){iCanSkip=0;break;}
            }
            if(iCanSkip){
               pEncStat->iSkipQ[k]++;
               ctx->mb->col[k].iSkip=MB16_2::eSkip8;
           LOGT("sk-dc");
               return 0;
            }
         

      }
      
//?????????????????
      //dc0*iDCQ<64*(2+b)
#if 0
    def _TEST_T_BITS
      if(!iPic && iBlocksEnc && (iHasDCs>1 || (!dcS0 && iHasDCs))  && iMaxQDC<2 && !k &&  ((!dcS0 && !dc1)|| (dc0*iDCQ<64*(2+b) && dc1*iDCQ<64*(2+b)))){
         int dcL1=(t[0]*4)>>3;
         //*iDCQ<48*(2+(b)
         const int dcL=max(dcL1,12+b*4);
         static const int tabID[]={
            0,0,1,1,
            0,0,1,1,
            2,2,3,3,
            2,2,3,3,
         };
         static const int tabFL[]={
            1,2,1,2,
            4,8,4,8,
            1,2,1,2,
            4,8,4,8,
         };
         int iClearedBlocks=0;
         int iLowDCBlocks=0;
         for(i=0;i<16;i++){
            if(dctDC[i]<dcL && dctDC[i]>-dcL){
               int iIsBorder=i<4 || !(i&3);
               if((iIsBorder ||  (i>3 && !dctDC[i-4]) ||  (i&3 && !dctDC[i-1]))&&(tabFL[i]&iDecFlags[tabID[i]])==0){
                  dctDC[i]=0;
                  iClearedBlocks++;
               }
               iLowDCBlocks++;
            }
         }
         if(iDec){
            
         //   if(iClearedBlocks){debugsi("cl",iClearedBlocks);}
           // static int iCLBL=0;if(iClearedBlocks && iLowDCBlocks==16){iDCCleared=1;iBitGainX+=iDCBitCnt;iCLBL++;debugsi("ldc----------",iCLBL);}
         }
         
      }
#endif

      /*
      iPos=0;
      _SET_DC(0,0); _SET_DC(0,16);_SET_DC(1,0); _SET_DC(1,16);
      _SET_DC(0,32); _SET_DC(0,48);_SET_DC(1,32); _SET_DC(1,48);
      _SET_DC(2,0);_SET_DC(2,16);_SET_DC(3,0); _SET_DC(3,16); 
      _SET_DC(2,32);  _SET_DC(2,48); _SET_DC(3,32);_SET_DC(3,48);
      */
      _SET_DC(0,0,0); _SET_DC(1,0,16);_SET_DC(2,1,0); _SET_DC(3,1,16);
      _SET_DC(4,0,32); _SET_DC(5,0,48);_SET_DC(6,1,32); _SET_DC(7,1,48);
      _SET_DC(8,2,0);_SET_DC(9,2,16);_SET_DC(10,3,0); _SET_DC(11,3,16); 
      _SET_DC(12,2,32);  _SET_DC(13,2,48); _SET_DC(14,3,32);_SET_DC(15,3,48);

   }

   {
#if 0
      //0,1,2=17, 1,2,3=1,
      //4,5,6=49, 5,6,7=33,
      //8,9,10=17, 9,10,11=1,
      //12,13,14=49, 12,14,15=33,
       const int ta[]={0,2,8,10};
      // int a=-(t[1]>>3);
       int a=-28;
#define T_SIG4(_C,_B,_A) {int _r=((_A+32)>>6);if(_r){_B+=(_r<0?-a:a); iDecFlags[i]|=_C;}}
       for(i=0;i<4 && iHasDCs /*&& !(iDecFlags[0]|iDecFlags[1]|iDecFlags[2]|iDecFlags[3]) && a*/;i++){
          //if(iDecFlags[i])continue;
          //iDecFlags[i]=1;
          
         const int tai=ta[i];

         if((dctDC[2+tai]>dctDC[1+tai] && dctDC[1+tai]>dctDC[0+tai]) || (dctDC[2+tai]<dctDC[1+tai] && dctDC[1+tai]<dctDC[0+tai])){
            if((iDecFlags[i]&2)==0)T_SIG4(2,dct[i][17],dctDC[1+tai]-dctDC[0+tai]);
            if((iDecFlags[i]&1)==0)T_SIG4(1,dct[i][ 1],dctDC[1+tai]-dctDC[0+tai]);
         }

         if((dctDC[6+tai]>dctDC[5+tai] && dctDC[5+tai]>dctDC[4+tai]) || (dctDC[6+tai]<dctDC[5+tai] && dctDC[5+tai]<dctDC[4+tai])){
            if((iDecFlags[i]&8)==0)T_SIG4(8,dct[i][49],dctDC[5+tai]-dctDC[4+tai]);
            if((iDecFlags[i]&4)==0)T_SIG4(4,dct[i][33],dctDC[5+tai]-dctDC[4+tai]);
         }

         if(i>2|| (dctDC[8+tai]>dctDC[4+tai] && dctDC[4+tai]>dctDC[0+tai]) || (dctDC[8+tai]<dctDC[4+tai] && dctDC[4+tai]<dctDC[0+tai])){
            if((iDecFlags[i]&4)==0)T_SIG4(4,dct[i][36],dctDC[4+tai]-dctDC[0+tai]);
            if((iDecFlags[i]&1)==0)T_SIG4(1,dct[i][ 4],dctDC[4+tai]-dctDC[0+tai]);
         }

         if(i>2 || (dctDC[9+tai]>dctDC[5+tai] && dctDC[5+tai]>dctDC[1+tai]) || (dctDC[9+tai]<dctDC[5+tai] && dctDC[5+tai]<dctDC[1+tai])){
            if((iDecFlags[i]&8)==0)T_SIG4(8,dct[i][52],dctDC[5+tai]-dctDC[1+tai]);
            if((iDecFlags[i]&2)==0)T_SIG4(2,dct[i][20],dctDC[5+tai]-dctDC[1+tai]);
         }

         //iDecFlags[i]=0xff;
       }
#endif
   }
   const int iRestoreB=0;

   ctx->iPrevDCCnt=iHasDCs+iBlocksEnc16*16;

//-------------------   //&& !k && iDev<4000
   // 
   if(!iPic && !iDec){
      //||(dc0>2 && dc0*iDCQ>12))
      //|| (dc0>1 && dc0*iDCQ>(100+(iIsB|ed->iThisWasB)*28))
      if(!k && iSad>iDev){iStartPsnr=0;}else 
      if(!k && ((iSad>t[0] || k)&& (((!k && iSad>t[0]*16+500)|| ed->iIsReferenceFrame || iMaxQDC+iMaxQ>3) ||  (k && iMaxQDC>1)
         ||(dc0 &&  dc0*iDCQ>96+t[0] )
         )))iStartPsnr=0;
      else if((!dc0 && k && iMaxQDC<2 && (iMaxQ|iMaxQDC)*t[0]<128) || (((!k && iSad<iMinPosSad) || (!k &&  !iStartPsnr && iMaxQ+iMaxQDC<3 && (iMaxQ<=iIsB || iMaxQ*t[1]<48 || !iBlocksEnc) && (iMaxQDC<=iIsB || iMaxQDC*t[0]<48) //&& iSad*2<iMinPosSad+iDCQ
         && (( iSad<iDev+100 && iSad<iMinPosSad+iDCQ+50) || !iBlocksEnc)//-- && (iMaxQ<3 || iMaxDC<16)
         )))){
            int getBlockPSNR_SQ_F(unsigned char *p ,unsigned char *o, int stride, int step, int &iDif, int &f, const int iLim);;
            if(iRStartPsnr)iStartPsnr=iRStartPsnr;else iRStartPsnr=iStartPsnr=
               k?getBlockPSNR_UV_SQ(pCur,pRef,16,16,stride,3,iSQErrStart):getBlockPSNR_SQ(pCur,pRef,16,16,stride,3,iSQErrStart);
               //getBlockPSNR_SQ_F(pCur,pRef,stride,3,iSQErrStart,iFastCheckMode,ed->iSQQuantErr4x4Y);
            if(m==100)iStartPsnr+=80;
            else if((!dc0 || ( dc0*iDCQ<(40*(2+(!!(b)))))))iStartPsnr+=40;
            if(iStartPsnr>iLastFramePsnr+100)iStartPsnr+=20;
            if(!k && iSQErrStart<ed->iSQQuantErr4x4Y){
               pEncStat->iSkipQ[k]++;
               ctx->mb->col[k].iSkip=MB16_2::eSkip7;
               return 0;
            }
            iCanRestore=1;
      }
      if((iIsB && iRestoreB==0)&& !iStartPsnr)return 1;
      //-------------------
      if(iStartPsnr){
         //if(!k)iStartPsnr=iRStartPsnr=blockQ(pCur,pRef,stride);
         if(!iIsB || iRestoreB)TDCTX::getBlock16(&saved[0],pCur,stride);
      }
      else iCanRestore=0;
   }
#if 0
    if(0&&!iPic && !k && t[0]>24 && (!dcS0 || iHasDCs>1)){
       t_idct8_s(&dct[0][0],pCur,stride,0);
       t_idct8_s(&dct[1][0],pCur+24,stride,0);
       t_idct8_s(&dct[2][0],pCur+8*stride,stride,0);
       t_idct8_s(&dct[3][0],pCur+8*stride+24,stride,0);
  
       void filter_4x4_16_a(unsigned char *p, int stride, int dc);
       filter_4x4_16_a(pCur,stride,t[0]/5+2);// (iDCQ>>4)+(t[1]>>5)+2);//(iFC>>1)+1);

dct[0][0]=dct[0][16]=dct[0][32]=dct[0][48]=0;
dct[1][0]=dct[1][16]=dct[1][32]=dct[1][48]=0;
dct[2][0]=dct[2][16]=dct[2][32]=dct[2][48]=0;
dct[3][0]=dct[3][16]=dct[3][32]=dct[3][48]=0;

       t_idct8_s(&dct[0][0],pCur,stride,iDecFlags[0]);
       t_idct8_s(&dct[1][0],pCur+24,stride,iDecFlags[1]);
       t_idct8_s(&dct[2][0],pCur+8*stride,stride,iDecFlags[2]);
       t_idct8_s(&dct[3][0],pCur+8*stride+24,stride,iDecFlags[3]);
    }
    else if(0&&!iBlocksEnc && !k &&!iPic){
       //  &&  t[0]>24 && (!dcS0 || iHasDCs>1)){//0&&!k && !iPic && !iBlocksEnc16 && (!dcS0 || iHasDCs>1)){
       unsigned char blo[256*3];
       memset(blo,128,sizeof(blo));
       t_idct8_s(&dct[0][0],&blo[0],16*3,0);
       t_idct8_s(&dct[1][0],&blo[24],16*3,0);
       t_idct8_s(&dct[2][0],&blo[48*8],16*3,0);
       t_idct8_s(&dct[3][0],&blo[48*8+24],16*3,0);
  
       void filter_4x4_16_dc(unsigned char *p, int stride, int dc);
       filter_4x4_16_dc(&blo[0],  48,t[1]>>3);// (iDCQ>>4)+(t[1]>>5)+2);//(iFC>>1)+1);
       /*
dct[0][0]=dct[0][16]=dct[0][32]=dct[0][48]=0;
dct[1][0]=dct[1][16]=dct[1][32]=dct[1][48]=0;
dct[2][0]=dct[2][16]=dct[2][32]=dct[2][48]=0;
dct[3][0]=dct[3][16]=dct[3][32]=dct[3][48]=0;

       t_idct8_s(&dct[0][0],&blo[0],16*3,iDecFlags[0]);
       t_idct8_s(&dct[1][0],&blo[24],16*3,iDecFlags[1]);
       t_idct8_s(&dct[2][0],&blo[48*8],16*3,iDecFlags[2]);
       t_idct8_s(&dct[3][0],&blo[48*8+24],16*3,iDecFlags[3]);
*/
       int iBLPos=0;
       for(i=0;i<16;i++){
          unsigned char *c=pCur+stride*i+k;
          for(int j=0;j<48;j+=3){
             
               int v=c[j]+blo[iBLPos]-128;
               if(v<0)c[j]=0;
               else if(v>255)c[j]=255;
               else  c[j]=v;
             
               iBLPos+=3;
          }
       }

    }
    else 
#endif 
   if(!iBlocksEnc16 && ((dcS0 && iHasDCs==1) || (iPic && iHasDCs==0))){
      void putDC16x16(DCT_TYPE dc_c, unsigned char *dstp, int stride);
      void addDC16x16(DCT_TYPE dc_c, unsigned char *dstp, int stride);
      if(iPic)
         putDC16x16(dct[0][0],pCur,stride);
      else 
         addDC16x16(dct[0][0],pCur,stride);

    }
    else{

      ofs=0;
      DEC_4x4(0,0);
      DEC_4x4(1,8*3);
      DEC_4x4(2,stride*8);
      DEC_4x4(3,stride*8+8*3);
    }
   int psnr=0;

   if(!iDec && 0){
      if(iMaxQ==0)pEncStat->iMaxZ[k][iPic]++;
      if(iMaxQ==1)pEncStat->iMaxQ1[k][iPic]++;
      if(iMaxQ>=1)pEncStat->iMaxQE[k][iPic]++;
   }
   
   if(!iDec && !iPic && iStartPsnr && iCanRestore){

      //iIsBigCost=;
      

//         int psnr=k?getBlockPSNR_UV(pCur,pRef,16,16,stride,3):getBlockPSNR(pCur,pRef,16,16,stride,3);
         psnr=k?getBlockPSNR_UV_SQ(pCur,pRef,16,16,stride,3,iSQErrEnd):getBlockPSNR_SQ(pCur,pRef,16,16,stride,3,iSQErrEnd);
            setPSNR_STAT(ctx->i>>4,ctx->j>>4,k,ctx->w,iRStartPsnr,psnr);
           LOGV(psnr);

         do{
            const int wb=!!(iIsB|ed->iThisWasB);
//break;
            int d=psnr-iStartPsnr;
            int dr=psnr-iRStartPsnr;
            //if(dr>200)break;
            
            int b=ed->vlc.iBitPos-iBitPos;

            iIsBigCost=b*3>d*2;
            if(!wb && !k  && b*5<d && d>80)break;
            if(!k  && b*5<d && d>t[1]*2+30)break;
            if(!k  && b<d && d>t[1]*4+60)break;
            if(b*10<d && d>30)break;
            //if(!k  && b<d && d>200-t[1] && d>t[0]*2)break;
            if(d>t[0]*4+40 && iRStartPsnr<iLastFramePsnr+100)break;
            if(((psnr>iLastFramePsnr+100 && iLastFramePsnr)|| d>300 || b*(4+wb*4)<d || (iDev>iSad+300 && d>70+wb*30))&& d>80+wb*30)break;
            /*
            
            if(dr>20 && !k && !wb && (b*2<dr+50 ) &&  dr<300 && b<120)break;
            if(b*(wb*5+(k?7:4))<dr)break;
            if(dc0 && dr>wb*50+(k?400:200))break;
            if(k && !wb && !iBlocksEnc16 && dr>200)break;
            //if(iLastFramePsnr && !k && !iIsB && iLastFramePsnr>iRStartPsnr+500 && dr>300)break;

            iIsBigCost=b*2>dr+30 && iSad>iMinPosSad+300 && iSad>iDev+500;
            int mdr=(!!iHasDCs)*50+iBlocksEnc16*(20+(!!k)*7)+wb*60;//&& dr>mdr
//if(!k && (iSad<iDev || iSad<iMinPosSad+200))mdr+=(iDev>>7);
//--if(iDev>32 && !k && (iSad*3<iDev*2+100 || iSad<iMinPosSad+300))mdr+=(int)((log((double)iDev)-4)*(iHasDCs && !iBlocksEnc16?20:10));
if(iMinPosSad>440 && !k && (iSad*3<iDev*2+100 || iSad<iMinPosSad+300))mdr+=(int)((log((double)iMinPosSad)-8)*(iHasDCs && !iBlocksEnc16?50:20));
            if(mdr<dr && (iSQErrEnd*(4+!!k)<iSQErrStart*3+5) &&
               (((b*2<dr+40 || !iBlocksEnc16 || dr>300 )&& (!k || (dr>150 && (b*3>dr || dr>300))) ) || b*6<dr)){
               if(iBlocksEnc16 &&  (!iHasDCs || (iHasDCs==1 && dc0)) && dr>iBlocksEnc16*30)break;
               if(!k && !wb && (b*5<dr))break;
               if(!k && !wb && (dr>220+iBlocksEnc16*15 || b*3<dr))break;
               if(!k && !wb && (dr>150+iBlocksEnc16*20))break;
               if(dc0>0 && dr>200+iBlocksEnc16*15)break;
               if(!iBlocksEnc16 && dr>100)break;

               if(!k&&dr>200+iBlocksEnc16*20  && b*(2+wb)<dr)break;
               if(!k && b*(6+wb*2)<dr)break;
               if(b*(15+wb*8)<dr)break;
               if(iSQErrEnd*2<iSQErrStart)break;
               if(dr>500)break;
            }
            if(!k && iSad>iDev+400 && !wb){
               if(iHada==1 || dc0>1)return 7;
            }
            if(iSQErrEnd*(4+!!k)<iSQErrStart || iSQErrEnd+32<iSQErrStart){
               if(dr>100 && iHada==1 && iHasDCs)break;
               if(dc0>1 && dc0*iDCQ>180+wb*100) break;
            }
*/
            if(1){
//          
                  //--if(!iIsB && iSad>iDev+500)return 7;
               if(!iIsB || iRestoreB)TDCTX::putBlock16(&saved[0],pCur,stride);
               pEncStat->iSkipLast[k]++;
               ctx->mb->col[k].iSkip=MB16_2::eSkipLast;
               //void debugsi(char*,int);              
            //   debugsi("msq============",k+100*(iMaxQDC*100+iMaxQ));
            
//if(!iIsB && !k)debugss("skl1",dr,b);
               return 0;
            }
         }while(0);


         ctx->iLastBlockPsnr=psnr;
   //      debugss("------psnr",psnr,iStartPsnr);
     //    debugss("------psnr",ed->vlc.iBitPos-iBitPos,k*100+iIsB);
   }
   /*
   if(!iDec){
      static int iPsnrTest[3];
      if(iResetCnt){
         debugss("psnr best encY",iPsnrTest[0],iIsB);
         debugss("psnr best encU",iPsnrTest[1],iIsB);
         debugss("psnr best encV",iPsnrTest[2],iIsB);
         iResetCnt=0;
         iPsnrTest[2]=iPsnrTest[1]=iPsnrTest[0]=1000;
         //k==0 3800
      }
      if(iStartPsnr>iPsnrTest[k])iPsnrTest[k]=iStartPsnr;
   }
   */
//   if(!iDec && k==0)
  //    debugss("psnr",iStartPsnr,psnr);
   /*
   //speedup
   if(!iDec && !iIsB && ed->iIsReferenceFrame){
      TDCTX::x_dif(NULL,pCur,pRef,stride);
      TDCTX::x_dif(NULL,pCur+24,pRef+24,stride);
      TDCTX::x_dif(NULL,pCur+24+stride*8,pRef+24+stride*8,stride);
      TDCTX::x_dif(NULL,pCur+stride*8,pRef+stride*8,stride);
   }
   */
   
   //if(!iDec && !iPic &&  k)iIsBigCost=1;else
   if(!iDec && !iPic && !k && !iIsB){
#ifdef _TI4x4
      if(!m && !iIsB && iSad*4>iDev && iSad>iMinPosSad+200 && ed->vlc.iBitPos-iBitPos>120)iIsBigCost=1;else
#endif
     // if(iDev<iSad)iIsBigCost=m==0;else
      if(m || iFastBlockType)iIsBigCost=0;// || (iTryMode==0 && iSad<iDev)
      else if(0&& iSad>iMinPosSad) iIsBigCost=1;else
      if(iHada==1){
         iIsBigCost=0;
      }
      else if(iIsBigCost==4)iIsBigCost=1;
      else if(iLastFramePsnr && iSad<iDev && iMinPosSad>6000 && iRStartPsnr+100>iLastFramePsnr)iIsBigCost=0;
      else if(iBlocksEnc16==0 && ed->vlc.iBitPos-iBitPos<34 && iHasDCs<4 && iLastFramePsnr && iSad<iDev+200 && (iSad<iDev+100 || iRStartPsnr>iLastFramePsnr || psnr>iLastFramePsnr+200))iIsBigCost=0;
      else if(!k && !iIsB){
         // m==0??????????
         if(//(iSad*2>iMinPosSad*3+200+iDCQ && iSad*3>iDev)||
            (iSad>iDev && iSad>iMinPosSad+200+iDCQ && iSad>iDCQ*2) 
            || (iSad>iMinPosSad*2+100 && iSad*2>iDev) 
            //|| (iSad*3>iMinPosSad*4+100 && iSad*2>iDev+200) 
            || (iSad>iMinPosSad+500 && iSad*2>iDev+2000))
            iIsBigCost=1;else iIsBigCost=0;
            /*
            if(!m && ((iTryMode&31)!=31) && !iIsBigCost && ((iMaxQ>2 && iMaxQ*t[1]>200) || iSad>iMinPosSad+800+iDCQ*4) && (iSad>2*iMinPosSad || iSad*3>iDev || iBlocksEnc16>11)){
               int t_dev_w_4x4_16_3(unsigned char * cur, const int stride, int iOldSad);
               int nd=t_dev_w_4x4_16_3(pRef,stride,iDev);
               if(nd<iDev){
                  if(iSad>iDev)iIsBigCost=1;
                  setMBParamDev(ctx->i>>3, ctx->j>>3,  ctx->w,iDev);
               }
            }
         */
         
      }
      //if(iMaxQ>1 && iSad*2>iMinPosSad*3 && !m)iIsBigCost=1;
     // if(!m && iSad>iDev)return 7;
#ifdef T_USE_PRED16
      if(iSad<iDev)iIsBigCost=0;
#endif
   }
   //iIsBigCost=1;
   //iIsBigCost=1;
   /*
   if(!iDec && ed->iIsReferenceFrame)
TDCTX::getBlock16(&saved[0],pRef,stride);
TDCTX::putBlock16(&saved[0],pCur,stride);
   }
   */
   ctx->iBlocksEnc16=iBlocksEnc16;
   if(!iDec && psnr && !iIsB)ctx->mb->col[k].iPrevStartPsnr=psnr;
int iDifFileterd=0;
#ifdef _TEST_T_BITS
if(0&&!g_iSkipLoop && t[0]>19 && (iDec || !iIsB || iRestoreB)){
#else
if(t[1]>48 && iDCQ>32 && (iDec || !iIsB || iRestoreB)){
#endif
//if(t[1]>24 && iDCQ>16 && (iDec || !iIsB)){
   //
   //TODO minQ t[0]>16
      void filter_4x4_16_f(unsigned char *p, int stride, int a, int *f);
      void filter_4x4_16_dc(unsigned char *p, int stride, int dc);
      void filter_4x4_16_a(unsigned char *p, int stride, int a);
      void filter_16_top(unsigned char *p, int stride, int a);
      void filter_16_left(unsigned char *p, int stride, int a);
      void filter_4x4_16_a_dcf(unsigned char *p, int stride, int a, int *f, int *dc);
      if(iFXTest){//iFAll|iIsB|ed->iThisWasB){
        
         //--int iFC=(t[1]>>4)+(iDCQ>>5);
         //--
         //--
         int fs;
        // int iFC=_GET_FC(t[1]+(iPic?(t[1]>>2):0),iDCQ);//((iDCQ+20)>>5);+Pic jo bias lielaaks
         int iFC=_GET_FC(fs, t[1],(iDCQ>>iPic));//((iDCQ+20)>>5);+Pic jo bias lielaaks
         //if((ed->iThisWasB|iIsB))iFC*=2;

         //iFC*=3;iFC+=8;iFC>>=2;
        // if(!k)debugsi("aa",iFC);
         
         //if(k){iFC*=3;iFC>>=1;}
        // if(!iPic)iFC>>=1;


         //int iFC=testFStrenght(0,t[1],0,0)+(iDCQ>>4);
         //int iFC=(((t[0]>>3)+(t[1]>>4))>>1)+(iDCQ>>5);
         
         if(iFC>200)iFC=200;
         
         //if(!iPic)iFC+=(t[0]>>5);
       //  int fs=setFSTabVal(iFC,t[0],t[1]);
         //if(iDec && k)debugsi("db-k",fs);
       //  if(iDec && !k)debugsi("db",fs);
         
         if(fs){
            //--iFC*=7;iFC+=1;iFC>>=3;
           // iFC*=3;iFC+=6;iFC>>=(2);
         
         
         //if(k)iFC+=(t[1]>>5);
//iFC=(iDCQ>>5);
           void fxMB(unsigned char *p, int a, int stride);
            //if(iIsB|ed->iThisWasB)iFC+=4;
           // if(iFC<4)iFC=4;
            //--iFC=(t[0]+8)>>2;
            //iFC=(t[1]>>4)+3;//(t[1]/3+16)>>3;
            //int iFC=(iPic?6:5)+2;
            //if((!iBlocksEnc) && ctx->i && ctx->j)fxMB(pCur,stride);else 
            if(iPic && !iBlocksEnc){
               //int iFC2=(iDCQ>>3)+1;
               //TODO fast filter if iMaxDCQ<2
               if(t[0]>24 && ((!dcS0 && iHasDCs) ||  iHasDCs>1))
                  filter_4x4_16_dc(pCur,  stride,iFC);//iDCQ/12);
            }
            else if((!dcS0 && iHasDCs) ||  iHasDCs>1 || (iBlocksEnc)){
         //      if(iDec && !k)debugsi("db fc",iFC);
              
               //void filter_4x4_16_a_dcf(unsigned char *p, int stride, int a, int *f, int *dc){
               filter_4x4_16_a_dcf(pCur,  stride, iFC,&iDecFlags[0],iPic?&dctDC[0]:NULL);
            }
        //   fxMB(pCur,iFC>>1,stride);

   #ifndef T_USE_PRED16
#ifdef _TEST_T_BITS
            if(0){
#else
            if(ed->iIsKey){// && (!k || (!ctx->i || !ctx->j))){
#endif
   #if 1
               //def T_CAN_TEST_V
            //TODO fast check if (k && ctx->i) predDC!=dc
               if(k){
                  void filter_16_topUV(unsigned char *p, int stride, int a);
                  void filter_16_leftUV(unsigned char *p, int stride, int a);
                  if(ctx->j)filter_16_topUV(pCur,  stride, iFC);
                  if(ctx->i)filter_16_leftUV(pCur,  stride,iFC);
               }else{
                  if(ctx->j)filter_16_top(pCur,  stride, iFC);
                  if(ctx->i)filter_16_left(pCur,  stride,iFC);
                  if(!ctx->j && !ctx->i){
                     //debugsi("iFC",iFC+!iDec*1000);                     debugsi("fs",fs);
                     
                  }
               }
   #else
               if(ctx->j)filter_16_top(pCur,  stride, iFC);
               if(ctx->i)filter_16_left(pCur,  stride,iFC);
   #endif
            
            }
   #endif
         }
            if(!k)iDifFileterd=1;
      }
      else if(t[0]>28 && (iDec || !ed->iThisWasB ) &&  (iPic || ed->iIsKey || ctx->iIsPic)){
            //--int iFC=t[0]/6;;
         int iFC=t[0]/5+2;;//54900 829KB
         if(!(iBlocksEnc)){
             
             if(((!dcS0 && iHasDCs) ||  iHasDCs>1) &&  iDCQ>36)filter_4x4_16_dc(pCur,  stride,iFC);// (iDCQ>>4)+(t[1]>>5)+2);//(iFC>>1)+1);
         }
         else{
            
            if((iBlocksEnc)) {
               filter_4x4_16_f(pCur,  stride, iFC,&iDecFlags[0]);
            }
         }
         if(ed->iIsKey){
            if(!k || iBlocksEnc||iHasDCs>1){
               if(ctx->j)filter_16_top(pCur,  stride, iFC);
               if(ctx->i)filter_16_left(pCur,  stride,iFC);
            }
         }
         if(!k)iDifFileterd=1;
      }else if(//!iPic && (!dcS0  || iHasDCs>1 || (iBlocksEnc))){
          (iEnableDifFilter)&& !iPic  && (!dcS0 ||  iHasDCs>1 || (iBlocksEnc))){

//if(iDec && (iIsB|ed->iThisWasB))debugss("debl-1",k*10,t[0]/5+2);
         void filter_4x4_16_dif(unsigned char *p, int stride, int a, int rem);
         if(iIsB|ed->iThisWasB)filter_4x4_16_a(pCur,  stride, t[0]/5+2);
         else filter_4x4_16_dif(pCur,  stride, (t[0]>>3),1);
         if(!k)iDifFileterd=1;
      }
   }

if(!k){
   char *getDeblFlags(int iDecz, int w, int h);
   char *dbl=getDeblFlags(iDec,ctx->w,ctx->h);
   if(dbl){
      int xc=ctx->w>>4;
      int iPos2=(ctx->i>>4)+(ctx->j>>4)*xc;
      
      //if(t[0]<16 || t[1]<48){dbl[iPos2]=64;}else
      

      if(!k)dbl[iPos2]&=~16;

      if(iDCQ<40){
         dbl[iPos2]|=64;
         if(ctx->i && (dbl[iPos2-1]&64)){dbl[iPos2]&=~(8|2);}
         if(ctx->j && (dbl[iPos2-xc]&64)){dbl[iPos2]&=~(4|1);}
      }
      else{
         dbl[iPos2]|=4|8;
         if(ctx->i+16<ctx->w)dbl[iPos2+1]|=8;
         dbl[iPos2+xc]|=4;
      }
      if(iPic)dbl[iPos2]&=~(32|16);
      else if(t[1]>48 && iDCQ>40){if(!iPic && !iDifFileterd &&  (!dcS0  || iHasDCs>1 || (iBlocksEnc))) dbl[iPos2]|=32;}
      
   }
}
LOGT("ok");
   /*

   if(iPic){
      int iBx=ed->vlc.iBitPos-iBitPos;iBx*=3;iBx/=10;
      iBitsG+=iBx;
   }
*/


   
   //if(!iDec)debugss("psnr",iRStartPsnr,t[0]);
   //if(iDec && !k)debugss("bits-Y",ed->vlc.iBitPos-iBitPos,iHasDCs+iPic*100);
   //if(iDec && k)debugss("bits-UY",ed->vlc.iBitPos-iBitPos,iHasDCs+iPic*100);
   return 1;
}


/*
*/
#if 0
template  <int iDec, int iPic>
static int encMB16_okx(ENC_BL_CTX *ctx, TDCTX *ed, unsigned char *pCur, unsigned char *pRef, int stride,int k,int  iIsB, int i_CanRestore, int &iIsBigCost, int iBestBits=0){
   int e=0;
#if 0
   if(k)return 0;
   //def T_USE_PRED16
   if(iDec){
      if(ed->vlc.getB())
         e|=encMB16_okR<iDec,iPic>(ctx,ed,pCur,pRef,stride,k,iIsB,i_CanRestore, iIsBigCost, iBestBits);
      if(ed->vlc.getB())
         e|=encMB16_okR<iDec,iPic>(ctx,ed,pCur+1,pRef+1,stride,k+1,iIsB,i_CanRestore, iIsBigCost, iBestBits);
      if(ed->vlc.getB())
         e|=encMB16_okR<iDec,iPic>(ctx,ed,pCur+2,pRef+2,stride,k+2,iIsB,i_CanRestore, iIsBigCost, iBestBits);
      return e;
   }
   int bp=ed->vlc.iBitPos;
   int iEnc=3;
   ed->vlc.addB(1);

   e=encMB16_okR<iDec,iPic>(ctx,ed,pCur,pRef,stride,k,iIsB,i_CanRestore, iIsBigCost, iBestBits);
   if(e==7)return 7;
   if(e==0 && iPic)return 0;
   iBestBits=0;

   if(e==0){
      iEnc--;
      ed->vlc.iBitPos=bp;
      ed->vlc.addB(0);
   }else  bp=ed->vlc.iBitPos;
   ed->vlc.addB(1);

   e=encMB16_okR<iDec,iPic>(ctx,ed,pCur+1,pRef+1,stride,k+1,iIsB,i_CanRestore, iIsBigCost, iBestBits);
   
   if(e==0){
      iEnc--;
      ed->vlc.iBitPos=bp;
      ed->vlc.addB(0);
   }else  bp=ed->vlc.iBitPos;

   ed->vlc.addB(1);
   e=encMB16_okR<iDec,iPic>(ctx,ed,pCur+2,pRef+2,stride,k+2,iIsB,i_CanRestore, iIsBigCost, iBestBits);
   if(e==0){
      iEnc--;
      ed->vlc.iBitPos=bp;
      ed->vlc.addB(0);
   }

   if(iEnc==0)return 0;
   e=1;

#else
   int iBitGainX1scPrev=iBitGainX1sc;
   e=encMB16_okR<iDec,iPic>(ctx,ed,pCur,pRef,stride,k,iIsB,i_CanRestore, iIsBigCost, iBestBits);
   if(e==7)iBitGainX1sc=iBitGainX1scPrev;

#endif

   return e;
}
#endif
void encDecCArt(TDCTX *ed, const int iDec,unsigned char *pCur, unsigned char *pRef, int stride, int *f, short *qd[], int q){
   const int fx[]={1,2,4,8};
   const int ofs_b[]={0,8*3,stride*8,stride*8+8*3};
   const int ofs_s[]={0,4*3,stride*4,stride*4+4*3};
   q*=8;q>>=4;
   DCT_TYPE c[4];
  // return ;
  // if(iDec)return 0;
/*
//TODO if(x && y)
0xxx
y000
y000
y000
*/
   int i, j;
   int iEncBlocks=0;
   if(iDec && !ed->vlc.getB())return;
   int iSBPos=ed->vlc.iBitPos;
   if(!iDec)ed->vlc.addB(1);
   //0000 0
   //1100 100
   //0110 101
   //0011 110
   //1001 111
   //1010 10
   //0101 11
   for(j=0;j<4;j++){
      for(i=0;i<4;i++){
         if(!(f[j]&fx[i]))continue;
         short *bl=qd[j];
         bl+=(i<<4);
         //--if(!(bl[1]|bl[2]) || !(bl[4]|bl[8]))continue;
         int a1=!!bl[1];
         int a2=!!bl[4];
         a1+=!!bl[2];
         a2+=!!bl[8];
         if(!a1 || !a2)continue;
         const int ofs=ofs_b[j]+ofs_s[i];
         void t_fdc2_4(DCT_TYPE *x);
         void t_idc2_4(DCT_TYPE *x);
         if(iDec){
#if 0           
            c[3]=!!ed->vlc.getB();
            if(!c[3])continue;
            if(ed->vlc.getB())c[3]=-c[3];
            c[1]=c[2]=c[0]=0;
#else
            
            if(ed->vlc.getB()){
               c[0]=0;//ed->vlc.getAC();//0;
               c[1]=ed->vlc.getB();if(c[1]){if(ed->vlc.getB())c[1]=-c[1];}
               c[2]=ed->vlc.getB();if(c[2]){if(ed->vlc.getB())c[2]=-c[2];}
               c[3]=ed->vlc.getB();if(c[3]){if(ed->vlc.getB())c[3]=-c[3];}
            }
            else continue;
#endif
         }
         else{

            c[0]=pRef[ofs]-pCur[ofs];
            c[1]=pRef[ofs+9]-pCur[ofs+9];
            c[2]=pRef[ofs+stride*3]-pCur[ofs+stride*3];
            c[3]=pRef[ofs+stride*3+9]-pCur[ofs+stride*3+9];
            t_fdc2_4(&c[0]);
            c[0]=0;//c[0]*16/q;
            
#if 1
            c[3]=c[3]*16/q;c[2]=c[2]*16/q;c[1]=c[1]*16/q;
            if(c[0]|c[1]|c[2]|c[3]){
               
               ed->vlc.addB(1);
//               
#define XS(_a) _a=(_a<0)?-1:(_a>1?1:0)
               XS(c[0]);XS(c[1]);XS(c[2]);XS(c[3]);
            //   ed->vlc.toAC(c[0]);
               if(c[1]){ed->vlc.addB(1);ed->vlc.addB(c[1]<0);}else ed->vlc.addB(0);
               if(c[2]){ed->vlc.addB(1);ed->vlc.addB(c[2]<0);}else ed->vlc.addB(0);
               if(c[3]){ed->vlc.addB(1);ed->vlc.addB(c[3]<0);}else ed->vlc.addB(0);
            
#undef XS   
            }
            else{ed->vlc.addB(0); continue;}
            
#else
            c[3]=c[3]*16/q;//c[1]=(c[1]+2)>>2;c[2]=(c[2]+2)>>2;c[3]=(c[3]+2)>>2;
            if(!c[3]){
               ed->vlc.addB(0);
               continue;
            }
            ed->vlc.addB(1);
            ed->vlc.addB(c[3]<0);
            c[3]=c[3]<0?-1:1;
            c[1]=c[2]=c[0]=0;
#endif
            

         }
         iEncBlocks++;
         c[0]=(c[0]*q+8)>>4;
         c[1]=(c[1]*q+8)>>4;c[2]=(c[2]*q+8)>>4;c[3]=(c[3]*q+8)>>4;
         

         t_idc2_4(&c[0]);

         pCur[ofs]+=c[0];
         pCur[ofs+9]+=c[1];
         pCur[ofs+stride*3]+=c[2];
         pCur[ofs+stride*3+9]+=c[3];

/*
         pCur[ofs]=pRef[ofs];
         pCur[ofs+9]=pRef[ofs+9];
         pCur[ofs+stride*3]=pRef[ofs+stride*3];
         pCur[ofs+stride*3+9]=pRef[ofs+stride*3+9];
  */       
      }
   }
   if(!iDec && !iEncBlocks){

      ed->vlc.iBitPos=iSBPos;
      ed->vlc.addB(0);
   }
   return ;
}
int encCalcBitsMB16(unsigned char *pCur, unsigned char *pRef, int w, int h, int stride,int k,int  iIsB)
{
   if(dctx==NULL)dctx=new TDCTX();
   TDCTX *ed=dctx;
   if(w==-1){
      memcpy(ed->tab_y,ed->nbtab_y,sizeof(ed->tab_y));
      memcpy(ed->tab_uv,ed->nbtab_uv,sizeof(ed->tab_uv));
      ed->iDCQuant=ed->tab_y[128]*2;
      ed->iDCQuantUV=ed->iDCQuant;
      return 0;
   }
   ed->iPredDC=0;
   ENC_BL_CTX ctxz;
   ENC_BL_CTX *ctx=&ctxz;
   memset(ctx,0,sizeof(ENC_BL_CTX));
   MB16_2 mmm;
   ctx->mb=&mmm;
   ctx->w=w;ctx->h=h;
   int iIsBigCost=0;
   int iBitPos=ed->vlc.iBitPos;
  // int cb=ed->vlc.iCalcBitsOnly;
  // ed->vlc.iCalcBitsOnly=1;
   int e;
   if(k){
      e=encMB16_ok<0,1>(ctx,ed,pCur,pRef,stride,0,iIsB,-2, iIsBigCost, 0);
   }
   else e=encMB16_ok<0,0>(ctx,ed,pCur,pRef,stride,0,iIsB,-2, iIsBigCost, 0);

   int b=e?(ed->vlc.iBitPos-iBitPos):0;
   //ed->vlc.iCalcBitsOnly=cb;
   ed->vlc.iBitPos=iBitPos;
   return b;
}
int encCalcBitsMB16(ENC_BL_CTX *ctx, TDCTX *ed,unsigned char *pCur, unsigned char *pRef, int stride,int k,int  iIsB)
{
   int iIsBigCost=0;
   int iBitPos=ed->vlc.iBitPos;
   int cb=ed->vlc.iCalcBitsOnly;
   ed->vlc.iCalcBitsOnly=1;
   int e=encMB16_ok<0,0>(ctx,ed,pCur,pRef,stride,k,iIsB,-1, iIsBigCost, 0);
   int b=e?(ed->vlc.iBitPos-iBitPos):0;
   ed->vlc.iCalcBitsOnly=cb;
   ed->vlc.iBitPos=iBitPos;
   return b;
}

template  <int iDec, int iPic>
int encMB16(ENC_BL_CTX *ctx, TDCTX *ed, unsigned char *pCur, unsigned char *pRef, int stride,int k,int  iIsB, int i_CanRestore, int &iIsBigCost, int iBestBits=0){
   //int iBP=ed->vlc.iBitPos;
   int e=0;
   int iUsePred16=0;
#ifdef T_USE_PRED16
   iUsePred16=1;
#endif

   if(!iPic || /*!ed->iIsKey ||*/ !iUsePred16){
      ctx->iIsPic=0;
      
         /*
      if(iPic && !k){// && ed->iIsKey){
         int m=0;
         if(!iDec){
            int iBP=ed->vlc.iBitPos;
            //iBestBits<<=2;
            int dcx=ed->iPredDC;
            int b[3]={2000,2000,2000};
            int e0=encMB16_ok<iDec,iPic>(ctx,ed,pCur,pRef,stride,k,iIsB,i_CanRestore, iIsBigCost, iBestBits);
            ed->iPredDC=dcx;
            if(e0)b[0]=ed->vlc.iBitPos-iBP;//((ed->vlc.iBitPos-iBP)*15-4)>>4;
            ed->vlc.iBitPos=iBP;
            int e2=b[m]>10?(encMB16_NonDif4x4<iDec>(ctx,ed,pCur,pRef,stride,k,0,0,iIsBigCost,iBestBits,1)+5):0;
            if(e2)b[2]=(ed->vlc.iBitPos-iBP);
            ed->vlc.iBitPos=iBP;
            if(b[2]<b[m])m=2;
           // iBestBits>>=2;

            //if(!ed->iIsKey && iBestBits && b[m]*7>iBestBits*8+10)return 0;
iBestBits=0;
            ed->vlc.addB(m?1:0);
//            if(m==2)return e2;
         }
         else m=ed->vlc.getB();//.getVlc();

         if(m==0)return encMB16_ok<iDec,iPic>(ctx,ed,pCur,pRef,stride,k,0,0,iIsBigCost,iBestBits);
//         if(m==1)return encMB16_NonDif<iDec,iPic>(ctx,ed,pCur,pRef,stride,k,0,0,iIsBigCost,iBestBits);
         return encMB16_NonDif4x4<iDec>(ctx,ed,pCur,pRef,stride,k,0,0,iIsBigCost,iBestBits);
      }
      
      */
      //389 1983
   //   if(iPic && !k)return encMB16_NonDif4x4<iDec>(ctx,ed,pCur,pRef,stride,k,0,0,iIsBigCost,iBestBits);
      /*
#if defined(_WIN32 ) && !defined(_WIN32_WCE)
      if(0&&!iDec && !iPic && !k && !iIsB){
         int t_dev_w_4x4_16_3(unsigned char * cur, const int stride, int iOldSad);
         int dev=t_dev_w_4x4_16_3(pRef,stride,50000);
         int iSad=sadInt(pRef,pCur,stride,dev+200);
         if(iSad>dev+100)return 7;
      }
#endif
      */
      int r;
#if 1
#if 1
      /*
      if(!iDec && !iPic){
         int b=ed->vlc.iBitPos;
         ed->vlc.iCalcBitsOnly=1;
         r=encMB16_ok_2x2<iDec>(ctx,ed,pCur,pRef,stride,k,iIsBigCost);
         ed->vlc.iBitPos=b;ed->vlc.iCalcBitsOnly=0;
         if(r==0 || r==7)return r;
      }
      */
      r=encMB16_ok<iDec,iPic>(ctx,ed,pCur,pRef,stride,k,iIsB,i_CanRestore, iIsBigCost, iBestBits);

#else
      
      int i4x4=iPic || k || ed->iIsB;  
      if(i4x4){
         r=encMB16_ok<iDec,iPic>(ctx,ed,pCur,pRef,stride,k,iIsB,i_CanRestore, iIsBigCost, iBestBits);;
      }
      else {
         r=encMB16_ok_2x2<iDec>(ctx,ed,pCur,pRef,stride,k,iIsBigCost);
      }
#endif
#else
      int z;
      int i4x4=iPic || k || ed->iIsB;  
      if(iDec){
         if(i4x4 || ed->vlc.getB()){
            r=encMB16_ok<iDec,iPic>(ctx,ed,pCur,pRef,stride,k,iIsB,i_CanRestore, iIsBigCost, iBestBits);;
         }
         else {
            r=encMB16_ok_2x2<iDec>(ctx,ed,pCur,pRef,stride,k,iIsBigCost);
         }
      }
      else if(i4x4){
         r=encMB16_ok<iDec,iPic>(ctx,ed,pCur,pRef,stride,k,iIsB,i_CanRestore, iIsBigCost, iBestBits);;
      }
      else{
         int z;
         int rb=0;
         int zb=1000;
         int b=ed->vlc.iBitPos;
         ed->vlc.iCalcBitsOnly=1;
         r=encMB16_ok<iDec,iPic>(ctx,ed,pCur,pRef,stride,k,iIsB,i_CanRestore, iIsBigCost, iBestBits);;
         if(r && r!=7){
            rb=ed->vlc.iBitPos-b;
            ed->vlc.iBitPos=b;
            z=encMB16_ok_2x2<iDec>(ctx,ed,pCur,pRef,stride,k,iIsBigCost);
            if(z){
               zb=ed->vlc.iBitPos-b;
if(zb<=rb+5)debugss("2b 4b",zb,rb);

               //zb*=6;zb>>=3;
            }
            else {debugss("zb",0,rb);r=0;}
         }
         ed->vlc.iCalcBitsOnly=0;
         ed->vlc.iBitPos=b;
         if(r && r!=7){
            if(zb<=rb){
               ed->vlc.addB(0);
               r=encMB16_ok_2x2<iDec>(ctx,ed,pCur,pRef,stride,k,iIsBigCost);;
               iIsBigCost=0;
            }
            else{
               ed->vlc.addB(1);
               r=encMB16_ok<iDec,iPic>(ctx,ed,pCur,pRef,stride,k,iIsB,i_CanRestore, iIsBigCost, iBestBits);;
            }
         }
      }
#endif
     // if(!iPic && !iDec)iIsBigCost=1;
     // if(r==7 && iIsB){e=1;};
      return r;
   }
#ifdef T_USE_PRED16
   
   int iBPos;//ed->vlc.iBitPos;
   int iWasPred=0;
   int iPredS=-1;
   if(k==0){
      if(iDec){
         iBPos=1;
      }
      iPredS=pred16Key<iDec>(ctx,ed,pCur,pRef, stride);

      iWasPred=1;
   }
   if(iDec && ed->vlc.getB())return 1;

   iBPos=ed->vlc.iBitPos;
   if(!iDec)ed->vlc.addB(0);
   iBestBits=0;
   ctx->iIsPic=1;
   //iPredS==0 && !iDec && iWasPred?0:
   e=encMB16_ok<iDec,0>(ctx,ed,pCur,pRef,stride,k,iIsB,iPic?-7:i_CanRestore, iIsBigCost, iBestBits);
   if(iDec)return e;

   
   if(!e){ed->vlc.iBitPos=iBPos;ed->vlc.addB(1);}
   return e?e:1;
   

#endif            


   
   return e;
}


static int iLastFrameDif=90;
void lastFrameDif(int d){
   iLastFrameDif=d;
}

static double lLastFrameSad=0;
void lastFrameSad(double d){
   lLastFrameSad=d;
}
static int iLastFrameAvgDev=4000;
void lastFrameDev(int d){
   iLastFrameAvgDev=d;
}


void setDeblockX(int iDeblock){g_iDeblock=iDeblock;}

template <int iDec>
 static int fastT_enc_dec(TDCTX *ed, unsigned char *pCur, unsigned char *pRef,int w, int h,int  iIsB){

//   int s;
   int stride=w*3;
   int i,j;//,xc,yc;
   int k,ofs;
//   int iCoefsOut,iMaxCoef;
   //xc=w/8;yc=h/8;
   //int sk=iDec?ed->vlc.getVlc():0;
   int iBitPos=ed->vlc.iBitPos;
   int iEnc=0;
   //static unsigned char *pRest=NULL;
  // if(!pRest && !iDec)pRest=new unsigned char [16000];

   iResetCnt=1;
   int iEncTmp;
   int iIsBigCost;
   int iBitsGain=0;
   int iIsKey=ed->iIsKey;
   
   int iIsHada=0;
   int iCheckNextNonDif=!iIsB;

   int id=0;
   int iHasQuant=0;
   iHasQuant=1;
   int aQ=16,bQ=32,cQ=64,uvQ=16;
   int iLossless=0;
   int iPosBeforeSkipID=0;
  
   int iCanRestore=1;
   
   if(iDec){
      ed->iDCQuant=ed->vlc.getVlc();
      iHasQuant=ed->vlc.getB();
      if(iHasQuant){
         aQ=ed->vlc.get_L_Val(3)*2;
         bQ=ed->vlc.get_L_Val(3)*2;
         cQ=ed->vlc.get_L_Val(3)*2;
         uvQ=ed->vlc.get_L_Val(2)*2;
         if(aQ>1500*2)return -3;
         if(bQ>3000*2)return -3;
         if(cQ>5000*2)return -3;
         if(uvQ>8000*2)return -3;
         //debugss("ab",aQ,bQ);
         //debugss("c-uv",cQ,uvQ);
      }
      //
      ed->iSkipId=ed->vlc.getVlc();
   }
   else{
//#if 1
      int qx;
      //qx=(((100-ed->iQValIn)*9)>>4)-6;
      //qx=42-ed->iQParam;//def
#if 0
#define TI_Q_MAX (9*6)
      int qJ=9;
      qx=qJ*7-ed->iQParam;
      int iqxMax=qJ*7-ed->iMaxQParam;
     // qx=37-ed->iQParam;
      


      //qx=12;
      //qx=(102-ed->iQVal)>>1;
      int iDec_aQcQ=0;
      ed->iPrevWasKey=0;
      static int iPrevWasKey=0;
      if(ed->iIsB || ed->iThisWasB || ed->iThisWasBX){

         if(iPrevWasKey==1)iPrevWasKey=0;
         if(iPrevWasKey==3)iPrevWasKey=4;
         if(!ed->iThisWasBX){
            iqxMax+=qJ/2;
            qx+=qJ;
         }
         if(qx<qJ)qx=qJ;
         if(qx>qJ*7.5)qx=qJ*7.5;
      }
      else  
      if(ed->iIsReferenceFrame ){
         if(iLastFrameDif>80){
         }
         else if(ed->iDecRefQ){
            qx-=1;
         }
         else{
         iDec_aQcQ=2;
         iqxMax-=2;
  
#if 1
         
         int iqxRem=qJ*3>qx?((qx)/3+1):(qJ-1);
         //if(iLastFrameDif && (ed->iFramesAfterKey>3 || iLastFrameDif>40)){iqxRem>>=1;iqxRem++;}

         if(iLastFrameDif>36)iqxRem-=4;
         if(iLastFrameDif>24)iqxRem-=3;
         else if(iLastFrameDif>12)iqxRem-=2;
         else if(iLastFrameDif>4)iqxRem-=1;
         if(iqxRem<2)iqxRem=2;
         //qx-=4;//
         qx-=iqxRem;
         
#endif
         }

         iPrevWasKey=0;
         //qx--;
         
         //qx-=4;
         if(qx<0)qx=0;
         if(qx>qJ*6)qx=qJ*6;
      }
      else if(ed->iIsKey){
         if(dctx->iMaxQParam!=100){
         iqxMax+=2;

         if(iIsUDP){
            qx+=qJ;if(iLastFrameDif>40)qx+=(iLastFrameDif/10-2);
            if(qx<16)qx=16;
         }
         else qx+=qJ/2;

         //
         iPrevWasKey=2;
         if(qx>qJ*6.5)qx=qJ*6.5;
         }

         //qx=24;
         
      }
      else if(iPrevWasKey &&  iLastFrameDif<8){

         
         if(iPrevWasKey==4 || iPrevWasKey==1){
            ed->iPrevWasKey=1;
            iPrevWasKey=1;
            iDec_aQcQ=1;
            if(qx<1)qx=1;
            iCanRestore=-1;
         }
         if(iPrevWasKey==2)iPrevWasKey=3;
      }
      else{
         if(qx<1)qx=1;
         if(qx>qJ*6.5)qx=qJ*6.5;
      }
      if(qx<iqxMax)qx=iqxMax;//rev qx=40-par;

      bQ=(24*(6-(qx%6))+(qx%6)*48)*(1<<(qx/6));//(((2<<(qx/6)))*32+qt[qx%6]*(2<<(qx/6)))*3;
//      bQ=(24*(8-(qx%8))+(qx%8)*48)*(1<<(qx/8));
#else

#undef TI_Q_MAX
#define TI_Q_MAX (42)
      int qJ=6;
      qx=TI_Q_MAX-ed->iQParam;
      int iqxMax=TI_Q_MAX-ed->iMaxQParam;
     // qx=37-ed->iQParam;
      


      //qx=12;
      //qx=(102-ed->iQVal)>>1;
      int iDec_aQcQ=0;
      ed->iPrevWasKey=0;
      static int iPrevWasKey=0;
      if(ed->iIsB || ed->iThisWasB || ed->iThisWasBX){

         if(iPrevWasKey==1)iPrevWasKey=0;
         if(iPrevWasKey==3)iPrevWasKey=4;
         if(!ed->iThisWasBX){
            iqxMax+=qJ/2;
            qx+=qJ;
         }
         if(qx<8)qx=8;
         if(qx>TI_Q_MAX+2)qx=TI_Q_MAX+2;
      }
      else  
      if(ed->iIsReferenceFrame ){
         if(iLastFrameDif>80){
         }
         else if(ed->iDecRefQ){
            qx-=1;
         }
         else{
         iDec_aQcQ=2;
         iqxMax-=2;
 
  
#if 1
         
         int iqxRem=qJ*3>qx?((qx)/3+1):(qJ-1);
         //if(iLastFrameDif && (ed->iFramesAfterKey>3 || iLastFrameDif>40)){iqxRem>>=1;iqxRem++;}

         if(iLastFrameDif>36)iqxRem-=4;
         if(iLastFrameDif>24)iqxRem-=3;
         else if(iLastFrameDif>12)iqxRem-=2;
         else if(iLastFrameDif>4)iqxRem-=1;
         if(iqxRem<2)iqxRem=2;
         //qx-=4;//
         qx-=iqxRem;
         
#endif
         }

         iPrevWasKey=0;
         //qx--;
         
         //qx-=4;
         if(qx<0)qx=0;
         if(qx>TI_Q_MAX-8)qx=TI_Q_MAX-8;
      }
      else if(ed->iIsKey){
         if(dctx->iMaxQParam!=100){
         iqxMax+=2;

         if(iIsUDP){
            qx+=qJ/2;if(iLastFrameDif>40)qx+=(iLastFrameDif/10-2);
            if(qx<16)qx=16;
         }
         else {
            qx+=qJ/2;
            //if(iLastFrameDif>40)qx+=(iLastFrameDif/10-2);
         }
         //qx-=8;

         //
         iPrevWasKey=2;
         if(qx>TI_Q_MAX-2)qx=TI_Q_MAX-2;
         }

         //qx=24;
         
      }
      else if(iPrevWasKey &&  iLastFrameDif<8){

         
         if(iPrevWasKey==4 || iPrevWasKey==1){
            ed->iPrevWasKey=1;
            iPrevWasKey=1;
            iDec_aQcQ=1;
            if(qx<1)qx=1;
            iCanRestore=-1;
         }
         if(iPrevWasKey==2)iPrevWasKey=3;
      }
      else{
         if(qx<1)qx=1;
         if(qx>TI_Q_MAX-2)qx=TI_Q_MAX-2;
      }
      if(qx<iqxMax)qx=iqxMax;//rev qx=40-par;
//qx+=6;
      bQ=(24*(6-(qx%6))+(qx%6)*48)*(1<<(qx/6));//(((2<<(qx/6)))*32+qt[qx%6]*(2<<(qx/6)))*3;

#endif
      if(dctx->iMaxQParam!=100 && ed->iIsKey && bQ<48*32)bQ=48*32;
      //----------
//
      if(0){//!iFXTest ||1){
         aQ=bQ/1.875;aQ>>=5;bQ>>=5;//104 54404
      }
      else{
         aQ=bQ/2.2;aQ>>=5;bQ>>=5;
      }
      //aQ=bQ>>1;aQ>>=5;bQ>>=5;
      //ar filtru aQ=bQ/2.235;aQ>>=5;bQ>>=5;//105 57472 sile
      //aQ=bQ>>6;bQ>>=5;
      
      //aQ=bQ;bQ=aQ*1.875;bQ>>=5;aQ>>=5;
      
      
      if(iIsB && !ed->iSkipId){
//         for(int z=0;z<42;z++)debugss("z",z,(24*(6-(z%6))+(z%6)*48)*(1<<(z/6))>>5);
            
         
      }
      
      
      
      //aQ=4;bQ=8;cQ=10;
   //   debugss("aQ1",aQ,bQ);
//#endif 
//bQ=800;
      //ed->iDCQuant=((iHasQuant?aQ:ed->tab_y[128]))>>1;
      //if(!ed->iIsKey)if(aQ>24){aQ*=7;aQ+=24;aQ>>=3;}

      if(ed->iIsB || ed->iThisWasB){
         if(ed->iThisWasB)
            aQ+=32;//48;
         else{
            aQ+=24;//32;
            //if(aQ<64)aQ=64;
            if(aQ<64){aQ+=64;aQ>>=1;}
         }
         bQ=aQ*2.229;
         bQ&=~3;
         aQ&=~3;
      }
#if 1
      //TODO if is live max q bQ=45;aQ=bQ/2.3; cQ=bQ*3;
      //TODO if is live skip frames 80 ms  after key

      
      if(ed->iIsKey && iIsUDP){
         if(bQ<168)bQ=168;
//--------
      //   bQ=128;

         aQ=bQ/2.23;
         cQ=bQ*1.8+30;
         if(cQ&1)cQ--;
#ifdef T_USE_PRED16
         aQ=bQ/2.2;
         cQ=bQ*1.8+20;
#endif
    
      }
      else if(ed->iIsKey){
         aQ=bQ/2.2;
         cQ=bQ*1.8+30;
         if(cQ&1)cQ--;
      }
     //--- if(!ed->iIsKey && !ed->iIsB && !ed->iThisWasB)cQ=bQ*1.8+16;
      //if(!ed->iThisWasB && !iIsB)aQ=bQ/2.3;
     // cQ=bQ*2.1;
      //25700,46
#endif
      if(!ed->iIsKey){
         //vp7 :) aQ=bQ/2.2;
         cQ=bQ*1.8+20;         if(ed->iThisWasBX)cQ+=20;
         //cQ=aQ*5;

      }
      //cQ=(bQ*24)>>4;      aQ=(bQ*9)>>4;
      //cQ=bQ*1.85+10;aQ=bQ/1.85;
      //aQ=(bQ*7)>>3;cQ=(bQ*9)>>3;
      

      if(aQ<2)aQ=2;
      if(bQ<4)bQ=4;
      if(cQ<22)cQ=22;

      int uvB=ed->iIsB|ed->iThisWasB;

      uvQ=24+(uvB*64); 


      if(uvQ+aQ<144+uvB*72)uvQ=144+uvB*72-aQ;
      
      //uvQ+=16;
      if(uvQ+aQ>256+uvB*96){
         uvQ=256+uvB*96-aQ;
      }
      if(uvQ<uvB*64+64)uvQ=uvB*64+64;
      uvQ*=7; uvQ+=aQ;uvQ>>=3;
      if(uvQ>100){uvQ+=100;uvQ>>=1;}
     // uvQ*=5;uvQ>>=2;
      if(ed->iIsKey && uvQ<96){uvQ+=96;uvQ>>=1;}
     // uvQ=256;
//uvQ=aQ;
     // uvQ+=16;
      uvQ=bQ;
      if(uvQ>192+uvB*96){
         uvQ+=192+uvB*96;uvQ>>=1;
      }

      //bQ=40;aQ=18;cQ=88;

      if(iHasQuant){
         if(aQ&1){
            if(bQ&1)bQ++;else bQ+=2;
         }
         else if(bQ&1){ cQ+=3;}
         aQ&=~1;cQ&=~1;bQ&=~1;
         uvQ&=~3;
      
      }
      //ed->iIsReferenceFrame
      //uvQ=0; aQ=2;bQ=4;      if(iIsB|ed->iThisWasB)aQ=4;bQ=8;
      if(aQ==2 && bQ==4)cQ=12;//LL
      else if(aQ==4 && bQ==4){aQ=2;cQ=22;}
      else if(aQ==4 && bQ==6)cQ=22;
      else if(aQ==6 && bQ==6)cQ=22;
      else if(aQ==4 && bQ==8)cQ=22;
      else if(aQ==6 && bQ==8)cQ=24;

  //--    if(ed->iIsReferenceFrame){aQ=12;bQ=26;cQ=60;}else if(ed->iIsB || ed->iThisWasB){aQ=48;bQ=105;cQ=240;}else {aQ=16;bQ=36;cQ=80;}
//      bQ=cQ=aQ;
//aQ=32;bQ=48;cQ=64;
      //aQ=32;bQ=50;cQ=68;
      //cQ=aQ=bQ;
      //aQ=2;bQ=4;cQ=20;

//aQ=8;bQ=16; cQ=32;
//(q=26),  52,  17   80,  26   80,  26  125,  41
      //aQ=52;bQ=80;cQ=125;
      //aQ=bQ*52/80;      cQ=bQ*125/80; //264
      //aQ=bQ*52/80;      cQ=bQ*125/80; //264
    //  aQ/=2;bQ/=2;cQ/=2;
//      aQ=80/2.4;bQ=80;cQ=bQ*2.5;
//bQ=aQ*1.37;cQ=aQ*1.8;
      //aQ=60;bQ=128;cQ=bQ*2.3;
      if(!ed->iIsKey){
         //to*1.5
//(t0*2+dcq)/2+128=t0,t0/2+dcq/2+128=t0, dcq=2*to-to-256
     //??--    if(iIsB){ed->iDCQuant=aQ*2-aQ-256;}else ed->iDCQuant=aQ*2;
//(t0*4+dcq)/4+128=t0*2,t0+dcq/4+128=t0*2, dcq=(to-128)*4

         //aQ=bQ/3;if(iIsB){ed->iDCQuant=aQ*4-512;}else ed->iDCQuant=aQ*4;
//(t0*4+dcq)/4+128=t0*1.5,t0+dcq/4+128=t0*1.5, dcq=(0.5to-128)*4
//--         if(iIsB){ed->iDCQuant=aQ*2-512;}else ed->iDCQuant=aQ*2;
         //iDCQ=(t[0]*4+ed->iDCQuant)/4+128 ,iDCQ=t[0]+ed->iDCQuant/4+128 
         //t0=(iDCQ*4-ed->iDCQuant-512)/4,iDCQ=t0+(t0*12+128)/4
         //--if(iIsB){ed->iDCQuant=aQ*2-512;}else ed->iDCQuant=bQ;
         //--if(iIsB){ed->iDCQuant=(aQ-12)*6;}else ed->iDCQuant=bQ;ed->iDCQuant*=2;
         if(iIsB){ed->iDCQuant=(aQ-12)*6;}else ed->iDCQuant=bQ;ed->iDCQuant*=7;ed->iDCQuant>>=2;
         //if(iIsB){ed->iDCQuant=(aQ-12)*10;}else ed->iDCQuant=aQ*6;
//(6*6-512)/4+128==6*1.5
         
         //ed->iDCQuant=aQ*12;
         if(ed->iDCQuant<12 && aQ<8)ed->iDCQuant>>=1;
        
         ed->iDCQuant-=((aQ>>2)+(aQ>>3));
         //if(ed->iDCQuant>32){ed->iDCQuant+=32;ed->iDCQuant>>=1;}
         
      }
      else{
#ifdef T_USE_PRED16
         ed->iDCQuant=(aQ*(iIsUDP?3:2))>>1;// *2;//bQ*2;//aQ*2;//var aQ*12
#else
          ed->iDCQuant=aQ*12;///12;//;
#endif
      }
      //if(!ed->iIsB && ed->iDCQuant<8)ed->iDCQuant=8;
      
      //?? if(!ed->iIsKey)ed->iDCQuant>>=1;
     //if(ed->iIsReferenceFrame)ed->iDCQuant=0;//
//??     if(!ed->iIsKey)ed->iDCQuant<<=1;
      //if(ed->iIsReferenceFrame)uvQ=16;else uvQ=32+(ed->iIsB*32);   if(uvQ+bQ<90+iIsB*60)uvQ=90+iIsB*60-bQ;
      if(ed->iDCQuant<0)ed->iDCQuant=0;

      if(ed->iIsKey){
         int dcqO=ed->iDCQuant;
         int iF=0;
         if(dcqO>128){
            int dcq;
            for(int z=0;z<18;z++){
               ed->iDCQuant=dcqO+z;
                  dcq=(aQ*3+ed->iDCQuant)>>2;
                  dcq++;dcq&=~1;
                  if((dcq&7)==0){iF=1;ed->iDCQuant=dcqO+z;break;}
               ed->iDCQuant=dcqO-z;
               if(ed->iDCQuant>=0){
                  dcq=(aQ*3+ed->iDCQuant)>>2;
                  dcq++;dcq&=~1;
                  if((dcq&7)==0){iF=1;ed->iDCQuant=dcqO-z;break;}
               }
            }
         }
         if(!iF){
            int dcq;
            for(int z=0;z<6;z++){
               ed->iDCQuant=dcqO+z;
                  dcq=(aQ*3+ed->iDCQuant)>>2;
                  dcq++;dcq&=~1;
                  if((dcq&3)==0){ed->iDCQuant=dcqO+z;iF=1;break;}
               ed->iDCQuant=dcqO-z;
               if(ed->iDCQuant>=0){
                  dcq=(aQ*3+ed->iDCQuant)>>2;
                  dcq++;dcq&=~1;
                  if((dcq&3)==0){ed->iDCQuant=dcqO-z;iF=1;break;}
               }
            }
         }

      }
      else{
         int dcqO=ed->iDCQuant;
         int dcq;
         for(int z=0;z<12;z++){
            ed->iDCQuant=dcqO+z;
            dcq=(aQ*4+ed->iDCQuant+8)>>2;
            dcq++;dcq&=~1;
            if((dcq&7)==0){ed->iDCQuant=dcqO+z;break;}
            if(ed->iDCQuant>=0){
            ed->iDCQuant=dcqO-z;
            dcq=(aQ*4+ed->iDCQuant+8)>>2;
            dcq++;dcq&=~1;
            if((dcq&7)==0){ed->iDCQuant=dcqO-z;break;}
            }
         }
      }

      if(ed->iDCQuant<0)ed->iDCQuant=0;
      ed->vlc.toVLC(ed->iDCQuant);
      ed->vlc.addB(iHasQuant);
    //  uvQ=0;

      if(iHasQuant){
         /*
         if(aQ&1){
            if(bQ&1)bQ++;else bQ+=2;
         }
         else if(bQ&1){cQ+=3;}
         aQ&=~1;cQ&=~1;bQ&=~1;
         uvQ&=~1;
         */
         //uvQ=48;
         ed->vlc.toL_Val(aQ>>1,3);
         ed->vlc.toL_Val(bQ>>1,3);
         ed->vlc.toL_Val(cQ>>1,3);
         ed->vlc.toL_Val(uvQ>>1,2);
         
      }
      //
      iPosBeforeSkipID=ed->vlc.iBitPos;
      ed->vlc.toVLC(ed->iSkipId);
     // debugss("aQ3",aQ,bQ);
   }
   //aQ=100;bQ=200;cQ=400;ed->iDCQuant=100;

   
   
   if(iHasQuant){
     //--- if(aQ<8)debugss("aQ",aQ,iHasQuant);
      initQ4x4(&ed->tab_y[0], 0 , iIsB, aQ,bQ, cQ);
      if(!ed->iIsReferenceFrame && !iDec && !ed->iIsKey)initQ4x4_SkipLast(&ed->tab_y_b[0],iIsB|ed->iThisWasB|ed->iThisWasBX, aQ,bQ, cQ);
      //--initQ4x4(&ed->tab_uv[0], 1 , iIsB, aQ+uvQ,bQ+uvQ, cQ+uvQ);
#ifdef _TEST_T_BITS

      //initQ4x4(&ed->tab_uv[0], 1 , iIsB, (aQ+(uvQ)),(bQ+uvQ*2), (cQ+(uvQ*3)));
      initQ4x4(&ed->tab_uv[0], 1 , iIsB, (aQ+(uvQ/2)),(bQ+uvQ), (cQ+(uvQ*3/2)));
#else
      initQ4x4(&ed->tab_uv[0], 1 , iIsB, (aQ+uvQ),(bQ+uvQ), (cQ+uvQ));
#endif
   }
   if(!iDec){
      if(!iIsB && ed->iSkipId==0){
         //debugss("aQ,bQ",aQ,bQ);
         //debugss("cQ,uvQ",cQ,uvQ);
      }
      if(ed->iSkipId==0){
         ed->iLastYBits=0;
      }
      ed->initTabSK();
      ed->calc4x4SQErr();
      while(ed->vlc.iBitPos&7)ed->vlc.addB(1);
   }
   else{
      ed->vlc.iBitPos+=7;ed->vlc.iBitPos>>=3;ed->vlc.iBitPos<<=3;//byteAlign
   }
   int iPosToEncodedCnt=ed->vlc.iBitPos;

   if(iDec){
      iEnc=ed->vlc.pBitBuf[iPosToEncodedCnt>>3]<<8;
      iEnc+=ed->vlc.pBitBuf[(iPosToEncodedCnt>>3)+1];
      
   }

   ed->vlc.iBitPos+=16;
   
   int iSkiped=0;
   ENC_BL_CTX ctx;
   ctx.h=h;
   ctx.w=w;
   ctx.mb=NULL;
   int iUseDct8x8=0;
   static int iUse8x8=0;
   static int iCheckPic=1;

   static int stats[3];//pic,difs,cnt

   static int iPrevWorstPsnr[3];
   if(!iDec && ed->iSkipId==0){
      //debugss("abc",aQ,bQ);      debugss("c-dc",cQ,ed->iDCQuant);
      if(!iIsB){
         iUse8x8++;
         iCheckPic=!iCheckPic;
         if(iUse8x8==3)iUse8x8=0;
         if(ed->iIsReferenceFrame){iUse8x8=0;iCheckPic=1;}
         if(ed->iIsKey){iCheckPic=1;}
      }
      ctx.iThisWorstPsnr[0]=4400;
      ctx.iThisWorstPsnr[1]=4400;
      ctx.iThisWorstPsnr[2]=4400;
      ctx.iWorstPsnr[0]=iPrevWorstPsnr[0];
      ctx.iWorstPsnr[1]=iPrevWorstPsnr[1];
      ctx.iWorstPsnr[2]=iPrevWorstPsnr[2];
   }
   int iLastNBit=0;
   const int iBlocksPerRow=w>>4;
   
//if(iDec)debugss("bp",ed->vlc.iBitPos,0);
   
   for(k=0;k<3;k++){
      //if(iDec && k)break;



      ed->iPredDC=0;
      if(iDec && ed->vlc.getB()){

         id+=(h>>4)*(w>>4);
         continue;
      }
      if(!iDec){
         
         ed->vlc.addB(0);
      }

      int iBitPosK=ed->vlc.iBitPos;

//iIsKey=1;
    //  if(!iDec)iIsHada=iLossless || (((ed->iIsReferenceFrame && iLastFrameDif<30)|| iLastFrameDif<10) && !k && !iIsKey);;
      iUseDct8x8=0;//!iIsHada && k ?iUse8x8:0;if(iLastFrameDif>70-(iIsB|ed->iThisWasB)*20){iUseDct8x8=1;iIsHada=0;}
//      iUseDct8x8=k?1:0;
      iIsHada=//(ed->iIsReferenceFrame || iIsKey) && 
             k==0;// && !iIsKey;// && iLastFrameDif<80;
      if(iIsHada && iUseDct8x8)iUseDct8x8=0;
      if(k){iUseDct8x8=2;iIsHada=0;}
#ifdef T_USE_PRED16
      if(ed->iIsKey){iIsHada=1;iUseDct8x8=0;}
#endif 
      //--??--
      if(ed->iIsReferenceFrame){iIsHada=1;}
#ifdef T_encMB16_DCTd24x4_UV
iIsHada=1;//iUseDct8x8=0;
#endif
iIsHada=1;iUseDct8x8=0;

      if(iDec)iIsHada=ed->vlc.getB();
      else ed->vlc.addB(iIsHada);

      if(iDec){
         iUseDct8x8=ed->vlc.getVlc();
         if(iUseDct8x8>2)return -5;
      }
      else ed->vlc.toVLC(iUseDct8x8);
      ctx.iIsHada=iIsHada;
      ctx.iUseDct8x8=iUseDct8x8;
      

//      int iMaxDifBitsChk=iIsHada?120:180;


      iEncTmp=iEnc;

     int idc=0;   
      for(j=0;j<h-15;j+=16){
         //ofs=j*w*3+(k?(k==2?(k+3):(k-3)):k);
         ofs=j*w*3+k;
         for(i=0;i<w-15;i+=16,ofs+=48,id++,idc++){
      //      if(idc&1)continue;
            //if(i==0 || j==0 || j+16>=h || i+16>=w)continue;
            ctx.i=i;ctx.j=j;
            ctx.iIsPic=0;
            ctx.iMeanUV=5000;
            
            if(iDec){
               if(id<ed->iSkipId)continue;
               int r;
               if(iIsKey){
                  iEnc--;
                  if(iIsHada)r=encMB16<iDec,1>(&ctx,ed,pCur+ofs,pRef+ofs, stride,k,iIsB,0,iIsBigCost);
                  else  r=encMB16_DCT<iDec,1>(&ctx,ed,pCur+ofs,pRef+ofs, stride,k,iIsB,0,iIsBigCost);
                  stats[0]++;
                  if(r<0)return r;
                  if(iEnc==0){
                     i=w;j=h;k=3;
                     break;
                  }
                  continue;
               }
               if(ed->vlc.getB())continue;

               iEnc--;
               
               if(!iIsB && ed->vlc.getB()){
                  stats[0]++;
                  if(iIsHada){
                     r=encMB16<iDec,1>(&ctx,ed,pCur+ofs,pRef+ofs, stride,k,iIsB,0,iIsBigCost);
                  //   if(k==1)encMB16<iDec,1>(ed,pCur+ofs+1,pRef+ofs+1, stride,k+1,iIsB,0,iIsBigCost);
                  }
                  else {
                     r=encMB16_DCT<iDec,1>(&ctx,ed,pCur+ofs,pRef+ofs, stride,k,iIsB,0,iIsBigCost);
                    // if(k==1)encMB16_DCT<iDec,1>(ed,pCur+ofs+1,pRef+ofs+1, stride,k+1,iIsB,0,iIsBigCost);
                  }
               }
               else{
                  stats[1]++;
                  if(iUseDct8x8==1 || (iUseDct8x8==2 && ed->vlc.getB()))
                     r=encMB16_DCT<iDec,0>(&ctx,ed,pCur+ofs,pRef+ofs, stride,k,iIsB,0,iIsBigCost);
                  else
                     r=encMB16<iDec,0>(&ctx,ed,pCur+ofs,pRef+ofs, stride,k,iIsB,0,iIsBigCost);
               }
               if(r<0)return r;

               if(iEnc==0){
                  i=w;j=h;k=3;
                  break;
               }
            }
            else {
               if(id<ed->iSkipId)  continue;

               if(ed->vlc.getBytePos()>ed->iPartLimitSize){
                  i=w;j=h;k=3;
                  ed->iSkipId=id;
                  iSkiped=1;
                  
                  break;
               }
               ctx.mb=&ed->mb16_2[idc];
               int iBPos=ed->vlc.iBitPos;
               if(iIsKey){
                  iEnc++;
                  if(iIsHada) encMB16<iDec,1>(&ctx,ed,pCur+ofs,pRef+ofs, stride,k,iIsB,0,iIsBigCost);
                  else  encMB16_DCT<iDec,1>(&ctx,ed,pCur+ofs,pRef+ofs, stride,k,iIsB,0,iIsBigCost);
if(!k)ed->iLastYBits+=(ed->vlc.iBitPos-iBPos);
                  continue;
               }
               ed->vlc.addB(0);
               
               {
                  if(!iIsB)ed->vlc.addB(0);
                  int e;
                  int iDev=-1;
                  int iUVMode=5;
                  ctx.iHasUVMode=0;
                  
                  //ctx.iIsHada
                  if(0&&k){//iUseDct8x8==2 && k){
                     iUVMode=getUVMode(&ctx,ed, pCur+ofs, pRef+ofs, stride, k, iIsB);
                     if(iIsB && iUVMode==3)iUVMode=1;
                     if(iUseDct8x8!=2 && iUVMode==2 && iIsHada)iUVMode=1;
                     //if(iUVMode==0)iUVMode=iIsB?0:3;
                  }
                  else if( iUseDct8x8==2){
                     iDev=getMBParamDev(i>>3, j>>3, w);
                  }
                  if(iUVMode!=5){
                     int iPrevUVM=iUVMode;
                     
                     if(iUVMode==4){
                        //pRest[idc]=0;
                        ctx.mb->col[k].iType=MB16_2::eDif4x4;
                        pEncStat->iBlocksDifSent[k]++;
                        iEnc++;
                        iLastNBit=ed->vlc.iBitPos;
                        ctx.mb->col[k].iSkip=MB16_2::eNotSkiped;
                        setSkip_STAT(ctx.i>>4,ctx.j>>4,k,ctx.w,ctx.mb->col[k].iSkip);
                        continue;
                     }
                     if(iUVMode==1){
                        if(iUseDct8x8==2)ed->vlc.addB(0);//iUseDct8x8
                        e=encMB16<iDec,0>(&ctx,ed,pCur+ofs,pRef+ofs, stride,k,iIsB,1,iIsBigCost);
                        ctx.iMeanUV=1000;
                       // debugss("muv1",k,e);
                        if(e==0)iUVMode=0;//iIsB?0:3;
                        else if(e==7 && !iIsB)iUVMode=3;
                        else{
                           ctx.mb->col[k].iType=MB16_2::eDif4x4;
                           pEncStat->iBlocksDifSent[k]++;
                        }
                     }
                     else if(iUVMode==2){
                        if(iUseDct8x8==2)ed->vlc.addB(1);//iUseDct8x8
                        e=encMB16_DCT<iDec,0>(&ctx,ed,pCur+ofs,pRef+ofs, stride,k,iIsB,1,iIsBigCost);
                   //     debugss("muv2",k,e);
                        if(e==0)iUVMode=0;
                        else if(e==7)iUVMode=3;
                        else{
                           pEncStat->iBlocksDifSent[k]++;
                           ctx.mb->col[k].iType=MB16_2::eDif4x4;
                        }
                     }
                     if(iUVMode==3 && !iIsB){
                     //   debugss("muv3",k,e);
                        ed->vlc.iBitPos=iBPos+1;
//                        int tmp=ed->vlc.iBitPos;
                        ed->vlc.addB(1);
                        if(iIsHada) e=encMB16<iDec,1>(&ctx,ed,pCur+ofs,pRef+ofs, stride,k,iIsB,0,iIsBigCost,0);
                        else  e=encMB16_DCT<iDec,1>(&ctx,ed,pCur+ofs,pRef+ofs, stride,k,iIsB,0,iIsBigCost,0);
                        ctx.mb->col[k].iType=MB16_2::ePic4x4;
                        pEncStat->iBlocksPicSent[k]++;
                     }
                     if(iUVMode==0){
                        //debugss("muv0",k,e);
                        ed->vlc.iBitPos=iBPos;
                        
                        int iTr2=0;
                        /*
                        if((ctx.iHasUVMode && ctx.iDCDifAbs>2+iIsB) && iPrevUVM==1) {
                           ed->vlc.addB(0);
                           if(!iIsB)ed->vlc.addB(0);
                           iTr2=tryEncDCOnly(ctx.iDCDif,&ctx,ed,pCur+ofs, pRef+ofs,stride,k,iIsB);
                           if(iTr2==0)ed->vlc.iBitPos=iBPos;
                        }
                        */
                        if(iTr2==0){
                           ed->vlc.addB(1);
                           iCheckNextNonDif=0;
                           if(ctx.mb->col[k].iSkip==MB16_2::eNotSkiped)ctx.mb->col[k].iSkip=MB16_2::eSkipPsnr;
                           setSkip_STAT(ctx.i>>4,ctx.j>>4,k,ctx.w,ctx.mb->col[k].iSkip);
                           continue;
                        }
                     }
                     iEnc++;
                     //pRest[idc]=0;
                     iLastNBit=ed->vlc.iBitPos;
                     ctx.mb->col[k].iSkip=MB16_2::eNotSkiped;
                     setSkip_STAT(ctx.i>>4,ctx.j>>4,k,ctx.w,ctx.mb->col[k].iSkip);
                     continue;
                  }
                  //
                  if(iUseDct8x8==1 || (iDev!=-1 && iDev<(k?16000:4000))){
                     if(iUseDct8x8==2)ed->vlc.addB(1);
                     e=encMB16_DCT<iDec,0>(&ctx,ed,pCur+ofs,pRef+ofs, stride,k,iIsB,1,iIsBigCost);
                  }
                  else{
                     ctx.iUVPsnr=0;
                     if(iUseDct8x8==2)ed->vlc.addB(0);
                     e=encMB16<iDec,0>(&ctx,ed,pCur+ofs,pRef+ofs, stride,k,iIsB,iCanRestore, iIsBigCost);
                     /*
                     if(e==0 && (!ed->iIsB || ed->iThisWasB)){
                        if(ctx.iUVPsnr && (iLastFrameDif && ctx.iUVPsnr<::iLastFrameDif-ed->iThisWasB*200-200))
                           e=7;
                     }
                     */
                  }
                //  if(k==1)pRest[id]=e;
                  if(!e){
                     ed->vlc.iBitPos=iBPos;
                     ed->vlc.addB(1);
                     //if(k==0)pRest[idc]=5;
                     //else if(k==1 && pRest[idc]==5)pRest[idc]=6;
                     //else pRest[idc]=0;
                     iCheckNextNonDif=0;
                     if(ctx.mb->col[k].iSkip==MB16_2::eNotSkiped)ctx.mb->col[k].iSkip=MB16_2::eSkipPsnr;
                  }
                  else {
                     ctx.mb->col[k].iSkip=MB16_2::eNotSkiped;
                     ctx.mb->col[k].iType=MB16_2::eDif4x4;
                     int iUV=k?1:0;
                     //pRest[idc]=0;
                     iEnc++;
                     int iDifBits=ed->vlc.iBitPos-iBPos;
                     static int iAvgDifBits16[2];
                     static int iAvgPicBits2[2];
                     if(e==7){
                        
                        ed->vlc.iBitPos=iBPos+1;
                        int tmp=ed->vlc.iBitPos;
                        ed->vlc.addB(1);
                        if(iIsHada) e=encMB16<iDec,1>(&ctx,ed,pCur+ofs,pRef+ofs, stride,k,iIsB,0,iIsBigCost,0);
                        else  e=encMB16_DCT<iDec,1>(&ctx,ed,pCur+ofs,pRef+ofs, stride,k,iIsB,0,iIsBigCost,0);
                        pEncStat->iBlocksPicSent[k]++;
                        ctx.mb->col[k].iType=MB16_2::ePic4x4;
                        iCheckNextNonDif=1;
                        int iPicBits=ed->vlc.iBitPos-tmp;
                        iDifBits=iPicBits;
                        iAvgPicBits2[iUV]*=7;iAvgPicBits2[iUV]+=iPicBits;iAvgPicBits2[iUV]>>=3;
                        if(iAvgDifBits16[iUV]>iPicBits)iAvgDifBits16[iUV]=iPicBits;
                     }
                     else{
                        pEncStat->iBlocksDifSent[k]++;
                        if(!iCheckNextNonDif && idc>=iBlocksPerRow && ctx.mb[-iBlocksPerRow].col[k].iType==MB16_2::ePic4x4)iCheckNextNonDif=1;
                        if((ed->iIsFirstPass  && !iIsB && (iIsBigCost || (k && iCheckNextNonDif)))){
                           int tmp=ed->vlc.iBitPos;
                           //e=encMB16_DCT<iDec,1>(ed,pCur+ofs,pRef+ofs, stride,k,iIsB,0,iIsBigCost);
                           //debugss("test pic",k*10000+iDifBits,ctx.mb[0].col[k].iStartPsnr);
                           if(iIsHada){
                              int sz=iDifBits;//((iDifBits*14+ed->iIsReferenceFrame*8)>>4)+(ed->iIsReferenceFrame?(k?15:40):8);
                              //if(iIsBigCost)sz+=(k?8:25);
                              //if(iDifBits>sz+60)sz=iDifBits+60;
                              e=encMB16<iDec,1>(&ctx,ed,pCur+ofs,pRef+ofs, stride,k,iIsB,0,iIsBigCost,sz);

                           }else  e=encMB16_DCT<iDec,1>(&ctx,ed,pCur+ofs,pRef+ofs, stride,k,iIsB,0,iIsBigCost,((iDifBits*3+ed->iIsReferenceFrame+iUseDct8x8*4)>>3)+8);
                           iCheckNextNonDif=0;
                           if(e>0){
                              int iPicBits=ed->vlc.iBitPos-tmp;
                              if(iAvgDifBits16[iUV]>iPicBits)iAvgDifBits16[iUV]=iPicBits;
                              iAvgPicBits2[iUV]+=iPicBits;iAvgPicBits2[iUV]>>=1;
                              iCheckNextNonDif=iPicBits<(iDifBits+20);
                              ed->vlc.iBitPos=iBPos+1;
                              ed->vlc.addB(1);
                              
                              //if(!k)debugss("bits-Y",iPicBits,iDifBits);          else debugss("bits-UV",iPicBits,iDifBits);
                              ctx.mb->col[k].iType=MB16_2::ePic4x4;
                              /// TODO vlc.addBFrom(int pos);
                              //for(int z=0;z<iPicBits;z++){ed->vlc.addB(ed->vlc.showBit(tmp));tmp++;}
                              //for(int z=0;z<iPicBits;z+=24){int l=iPicBits-z;if(l>24)l=24;int b=ed->vlc.showNBitsC(l,tmp);ed->vlc.addXBits(b,l);tmp+=l;}
                              ed->vlc.copyBits(ed->vlc.pBitBuf,tmp,iPicBits);
                              

                              iDifBits=iPicBits;
                              pEncStat->iBlocksPicSent[k]++;
                              pEncStat->iBlocksDifSent[k]--;
                           }
                           else ed->vlc.iBitPos=tmp;
                        }
                        if(ctx.mb->col[k].iType!=MB16_2::ePic4x4){
                           iAvgDifBits16[iUV]*=15;iAvgDifBits16[iUV]+=iDifBits+8;iAvgDifBits16[iUV]>>=4;
                        }
                     }
                     pEncStat->iAvgSize[k]+=iDifBits;
                     if(!k)ed->iLastYBits+=iDifBits;

                     iLastNBit=ed->vlc.iBitPos;

                        

                  }
                  if(!iDec){
                     setSkip_STAT(ctx.i>>4,ctx.j>>4,k,ctx.w,ctx.mb->col[k].iSkip);
                  }
               }
               
            }
            
         }
      }
      if(!iDec && iEncTmp==iEnc){
         ed->vlc.iBitPos=iBitPosK-1;
         ed->vlc.addB(1);
      }
      if(!iDec){
         //debugss("encC",k,(ed->vlc.iBitPos-iBitPosK+7)>>3);
      //   if(iBitsGain>0)debugss("gain -----",(iBitsGain+7)>>3,0);
         iBitsGain=0;
      }
   }
#if 0
   //def _TEST_T_BITS

      if(!iDec && !iSkiped && iEnc && !ed->iIsKey){
         int idsz=w*h>>8;
         for(k=0;k<3;k++){
         int g1=2;
         int g2=2;
         int g3=2;

         int iRleCnt=0;
        //int encAritm(unsigned char *out , int *in ,int iCnt);
         for(i=0;i<idsz;i++){
            //ids[i]=ed->mb16_2[i].col[0].iSkip==MB16_2::eNotSkiped;
            if(ed->mb16_2[i].col[k].iSkip!=MB16_2::eNotSkiped)iRleCnt++;else {while(iRleCnt>2047){iRleCnt>>=2;g1+=4;};g1+=ed->vlc.bitsLen[iRleCnt];iRleCnt=0;}
         }
         iRleCnt=0;
         for(i=0;i<idsz;i++){
            //ids[i]=ed->mb16_2[i].col[0].iSkip==MB16_2::eNotSkiped;
            if(ed->mb16_2[i].col[k].iSkip==MB16_2::eNotSkiped)iRleCnt++;else {while(iRleCnt>2047){iRleCnt>>=2;g2+=4;};g2+=ed->vlc.bitsLen[iRleCnt];iRleCnt=0;}
         }
         iRleCnt=0;
         int tr=0;
         for(i=0;i<idsz;i++){
            if((tr && ed->mb16_2[i].col[k].iSkip==MB16_2::eNotSkiped)
               || (!tr &&  ed->mb16_2[i].col[k].iSkip!=MB16_2::eNotSkiped))iRleCnt++;
            else {while(iRleCnt>2047){iRleCnt>>=2;g3+=4;};g3+=ed->vlc.bitsLen[iRleCnt];iRleCnt=0;tr=!tr;}
         }
         //g+=ed->vlc.bitsLen[iRleCnt];
         /*
         unsigned char bt[1024*16];
         int g1=encAritm(&bt[0],&ids[0],idsz);
         int g2=encAritm2(&bt[0],&ids[0],idsz);
         */
         int g=min(min(g1,g2),g3);
         if(g>2  || ed->mb16_2[0].col[k].iSkip!=MB16_2::eNotSkiped){
         if(g<idsz)iBitGainXNZ+=((idsz-g));
         else iBitGainXNZ--;
         }
         //debugss("grle",g>>3,idsz>>3);
         }
         //ed->mb16_2[idc]

      }
#endif   
   if(!iDec && !iEnc){ed->vlc.iBitPos=iBitPos;ed->iSkipId=0;}
   if(!iDec){
      if(iEnc){
         ed->vlc.pBitBuf[iPosToEncodedCnt>>3]=(iEnc>>8);
         ed->vlc.pBitBuf[(iPosToEncodedCnt>>3)+1]=iEnc-((iEnc>>8)<<8);


         if(iLastNBit && iLastNBit<ed->vlc.iBitPos)ed->vlc.iBitPos=iLastNBit;

         while(ed->vlc.iBitPos&7){
            ed->vlc.addB(1);
         }
      }


      /*
      if(iLastNBit){
         ed->vlc.addB(1);ed->vlc.addB(1);ed->vlc.addB(1);ed->vlc.addB(1);ed->vlc.addB(1);ed->vlc.addB(1);ed->vlc.addB(1);
         ed->vlc.iBitPos=((iLastNBit+7)>>3)<<3;
      }
      */

      if(!iSkiped )ed->iSkipId=-1;;
      iBitsGain=0;
      if(!iIsB){iPrevWorstPsnr[0]=ctx.iWorstPsnr[0];iPrevWorstPsnr[1]=ctx.iWorstPsnr[1];iPrevWorstPsnr[2]=ctx.iWorstPsnr[2];}
   }
   if(!iDec && ed->iSkipId==-1){
      debugT(pEncStat,0);
      debugT(pEncStat,1);
      debugT(pEncStat,2);
   }
   if(g_iDeblock && !iDec && (!iIsB && !ed->iThisWasB)  && (ed->iSkipId==-1)){// || ed->iSkipId>3*(w*h>>8))-8) {
      void deblock_yuv(unsigned char *p ,int w, int h, int stride, int iEnc, int iB);
      deblock_yuv(pCur,w,h,stride, !iDec,!!iIsB);
   }
   if(iDec){int sts=stats[0]+stats[1];if(sts)debugss("stats",stats[0]*1000/sts,stats[1]*1000/sts);}

   return ed->vlc.getBytePos();


}

#define BL_TYPE_SK 0
#define BL_TYPE_DIF 1
#define BL_TYPE_PIC 2

int encBlockType(TDCTX *ed,int iBlockStride, int ofs, unsigned char *t, int iCnt, int iPics, int iDifs, int iSkips){
   

   if(ofs==-1 || (!iPics && !iDifs && !ed->iIsKey)){
      ed->vlc.addB(1);
      return 0;
   }
   ed->vlc.addB(0);
   t+=ofs;
   while(t[0]==BL_TYPE_SK && iSkips>0){t++;ofs++;iSkips--;iCnt--;}

   ed->vlc.toVLC_X(ofs,2);

   int i;
   ed->vlc.toVLC_X(iPics,2);
   if(ed->iIsKey){
      return 0;
   }
   ed->vlc.toVLC_X(iDifs,2);

   if(!iPics && !iDifs)return 0;

   while(t[iCnt-1]==BL_TYPE_SK && iSkips>0){iSkips--;iCnt--;}

   iCnt=iSkips+iDifs+iPics;
   int iClearBlocks=iBlockStride;

   if(ofs<iClearBlocks)iClearBlocks=ofs;
   if(iClearBlocks)memset(&t[-iClearBlocks],BL_TYPE_SK,iClearBlocks);


  // iBitGainX1+=8*100;//(iDifs+iPics);

   ed->vlc.toVLC_X(iSkips,2);

#define a_CHECK_POSIB_CH \
   {\
      if(*iP>*iD && *iP>*iS){iS=&iPics;iD=&iDifs;iP=&iSkips; iSk_type=BL_TYPE_PIC;iSk_typeD=BL_TYPE_DIF;iSk_typeP=BL_TYPE_SK;}else \
      if(*iD>*iP && *iD>*iS){iS=&iDifs;iP=&iPics;iD=&iSkips; iSk_type=BL_TYPE_DIF;iSk_typeD=BL_TYPE_SK;iSk_typeP=BL_TYPE_PIC;}\
      /*else if(*iS>*iP && *iS>*iD){iS=&iSkips;iP=&iPics;iD=&iDifs; iSk_type=BL_TYPE_SK;iSk_typeD=BL_TYPE_DIF;iSk_typeP=BL_TYPE_PIC;}*/\
   }
#define _CHECK_POSIB_CH \
   {\
      if(iPics>iDifs && iPics>iSkips){iS=&iPics;iD=&iDifs;iP=&iSkips; iSk_type=BL_TYPE_PIC;iSk_typeD=BL_TYPE_DIF;iSk_typeP=BL_TYPE_SK;}else \
      if(iDifs>iPics && iDifs>iSkips){iS=&iDifs;iP=&iPics;iD=&iSkips; iSk_type=BL_TYPE_DIF;iSk_typeD=BL_TYPE_SK;iSk_typeP=BL_TYPE_PIC;}else \
      if(iSkips>iPics && iSkips>iDifs){iS=&iSkips;iP=&iPics;iD=&iDifs; iSk_type=BL_TYPE_SK;iSk_typeD=BL_TYPE_DIF;iSk_typeP=BL_TYPE_PIC;}\
   }

#if 0
   int sk=0;
   
   for(i=0;i<iCnt && (iPics || iDifs);i++){
#if 0
      if(t[i]==BL_TYPE_SK){if(iSkips){ed->vlc.addB(0);iSkips--;}}
      else {
         if(iSkips)ed->vlc.addB(1);
         if(iPics && iDifs){
            if(t[i]==BL_TYPE_PIC){
               iPics--;
               ed->vlc.addB(1);
            }
            else{
               iDifs--;
               ed->vlc.addB(0);
            }
         }
         else if(iPics){iPics--;}
         else if(iDifs){iDifs--;}
      }
#else
      
      if(t[i]==BL_TYPE_SK){sk++;}
      else {
         if(i && iSkips && (iDifs||iPics)){ed->vlc.toVLC(sk);iSkips-=sk;}
         if(iPics && iDifs){
            if(t[i]==BL_TYPE_DIF){ed->vlc.addB(1);iDifs--;}
            else if(t[i]==BL_TYPE_PIC){ed->vlc.addB(0);iPics--;}
         }
         else if(iPics){iPics--;}
         else if(iDifs){iDifs--;}
         sk=0;
      }
#endif      
   }
#else
   int *iS=&iSkips;
   int *iP=&iPics;
   int *iD=&iDifs;
   int iSk_type=BL_TYPE_SK;
   int iSk_typeD=BL_TYPE_DIF;
   int iSk_typeP=BL_TYPE_PIC;

   

   //_CHECK_POSIB_CH

   int sk=0;
   int pic_difs=0;
   //if(iSk_type!=BL_TYPE_SK)ed->vlc.toVLC(sk);
//   int iBlockStride=22;
   
   for(i=0;i<iCnt && (iPics || iDifs);i++){
      if(pic_difs<=0 && t[i]==iSk_type){sk++;}
      else {
         if((i) && iS[0] && pic_difs<=0 ){ed->vlc.toVLC(sk);iS[0]-=sk;}//_CHECK_POSIB_CH
         pic_difs--;
         
         if(iP[0] && iD[0]){
            if(t[i]==iSk_typeD){ed->vlc.addB(1);iD[0]--;}
            else if(t[i]==iSk_typeP){ed->vlc.addB(0);iP[0]--;}
         }
         else if(iP[0]){iP[0]--;}
         else if(iD[0]){iD[0]--;}

         if(pic_difs<=0 && iS[0] &&  iP[0]+iD[0]>iS[0] 
         && (ofs+i<iBlockStride || (t[i-iBlockStride+2]!=iSk_type && t[i-iBlockStride+1]!=iSk_type && t[i-iBlockStride]!=iSk_type))){
            pic_difs=0;
            for(int z=i+1;z<iCnt && t[z]!=iSk_type;z++)pic_difs++;
            ed->vlc.toVLC(pic_difs);
            if(pic_difs==0){i++;iS[0]--;}
            //_CHECK_POSIB_CH;
         }
         sk=0;

       //  if(i==0)_CHECK_POSIB_CH;
   
        
      }
   }
#endif
   //if(iLast)      ed->vlc.toVLC(sk);

   return 0;
}
int decBlockType(TDCTX *ed, int iBlockStride, int &ofs, unsigned char *t, int &iCnt, int &iPicsOut, int &iDifsOut, int &iSkipsOut){
 
   if(ed->vlc.getB()){
      ofs=-1;
      iPicsOut=0;
      iDifsOut=0;
      iSkipsOut=0;
      return 0;
   }
   int iPics,iDifs,iSkips;

   ofs=ed->vlc.getVlcX(2);
   iPics=ed->vlc.getVlcX(2);
   if(ed->iIsKey){
      iPicsOut=iPics;
      iDifsOut=0;
      iSkipsOut=0;
      iCnt=iPics;
      return 0;
   }
   iDifs=ed->vlc.getVlcX(2);
   iPicsOut=iPics;
   iDifsOut=iDifs;

   if(!iPics && !iDifs){iCnt=0;iSkipsOut=0;return 0;}

   iSkips=ed->vlc.getVlcX(2);
   iSkipsOut=iSkips;
   
   iCnt=iSkips+iPics+iDifs;

   memset(t,BL_TYPE_SK,iCnt+ofs);t+=ofs;
   //t+=ofs;memset(t,BL_TYPE_SK,iCnt);

   
   int i;
   int sk=0;//iSkips?ed->vlc.getVlc():0;
#if 0
   for(i=0;i<iCnt && (iPics || iDifs);i++){
#if 1
      //if(sk>0){sk--;iSkips--;}
      {
         if(iPics && iDifs){
            if(ed->vlc.getB()){
               t[i]=BL_TYPE_DIF;             iDifs--;
            }
            else{
               t[i]=BL_TYPE_PIC;             iPics--;
            }
         }
         else if(iPics){t[i]=BL_TYPE_PIC;             iPics--;}
         else if(iDifs){t[i]=BL_TYPE_DIF;             iDifs--;}
         if(iSkips && (iDifs||iPics)){sk=ed->vlc.getVlc();i+=sk;iSkips-=sk;}
         
         
        // sk=0;
      }
#else
      if(!iSkips || ed->vlc.getB()){
         if(iPics && iDifs){
            if(ed->vlc.getB()){
               iPics--;
               t[i]=BL_TYPE_PIC;
            }
            else{
               iDifs--;
               t[i]=BL_TYPE_DIF;
            }
         }
         else if(iPics){t[i]=BL_TYPE_PIC;             iPics--;}
         else if(iDifs){t[i]=BL_TYPE_DIF;             iDifs--;}
      }
      else iSkips--;
#endif
     // else t[i]=BL_TYPE_SK;
   }
#else
   int *iS=&iSkips;
   int *iP=&iPics;
   int *iD=&iDifs;
   int iSk_type=BL_TYPE_SK;
   int iSk_typeD=BL_TYPE_DIF;
   int iSk_typeP=BL_TYPE_PIC;
   int pic_difs=0;

//    if(iSk_type!=BL_TYPE_SK)memset(t,iSk_type,iCnt);
   

   for(i=0;i<iCnt && (iPics || iDifs);i++){

      if(iP[0] && iD[0]){
         if(ed->vlc.getB()){
            t[i]=iSk_typeD;             iD[0]--;
         }
         else{
            t[i]=iSk_typeP;             iP[0]--;
         }
      }
      else if(iP[0]){t[i]=iSk_typeP;             iP[0]--;}
      else if(iD[0]){t[i]=iSk_typeD;             iD[0]--;}

      if(pic_difs<=0 && iS[0] && iP[0]+iD[0]>iS[0] && 
         (ofs+i<iBlockStride || (t[i-iBlockStride+2]!=iSk_type &&  t[i-iBlockStride+1]!=iSk_type && t[i-iBlockStride]!=iSk_type))){
         pic_difs=ed->vlc.getVlc();
         if(pic_difs==0){i++;iS[0]--;}
         //_CHECK_POSIB_CH;
   
      }
  
     // if(i==0)    _CHECK_POSIB_CH;
      if(pic_difs<=0 && iS[0] && (iDifs||iPics)){
         sk=ed->vlc.getVlc();
         if(sk){
            memset(t+i+1,iSk_type,sk);
            i+=sk;iS[0]-=sk;
         }
      }
      pic_difs--;
     
   }

#endif
   return 0;
}


template <int iDec>
 static int fastT_enc_dec_n(TDCTX *ed, unsigned char *pCur, unsigned char *pRef,int w, int h,int  iIsB){

//   int s;
   int stride=w*3;
   int i,j;//,xc,yc;
   int k,ofs;
   int iBitPos=ed->vlc.iBitPos;
   int iEnc=0;
   //static unsigned char *pRest=NULL;
  // if(!pRest && !iDec)pRest=new unsigned char [16000];

   iResetCnt=1;
   int iEncTmp;
   int iIsBigCost;
   int iBitsGain=0;
   
   int iIsHada=0;
   int iCheckNextNonDif=!iIsB;

   int id=0;
   int iHasQuant=0;
   iHasQuant=1;
   int aQ=16,bQ=32,cQ=64,uvQ=16;
   int aQUV=16,bQUV=32,cQUV=64;
   int iLossless=0;
   int iPosBeforeSkipID=0;
  
   int iCanRestore=1;

   if(!iDec)ed->vlc.addB(!!ed->iIsKey);else ed->iIsKey=ed->vlc.getB();
//   if(!iDec)ed->vlc.addB(!!ed->iIsB);else ed->iIsB=iIsB=ed->vlc.getB();
   int iIsKey=ed->iIsKey;
   
   
   if(iDec){
      /*
      ed->iDCQuant=ed->vlc.getVlc();
      iHasQuant=ed->vlc.getB();
      if(iHasQuant){
         aQ=ed->vlc.get_L_Val(3)*2;
         bQ=ed->vlc.get_L_Val(3)*2;
         cQ=ed->vlc.get_L_Val(3)*2;
         uvQ=ed->vlc.get_L_Val(2)*2;
         if(aQ>1500)return -3;
         if(bQ>3000)return -3;
         if(cQ>5000)return -3;
         if(uvQ>8000)return -3;
         //debugss("ab",aQ,bQ);
         //debugss("c-uv",cQ,uvQ);
      }
      //
      ed->iSkipId=ed->vlc.getVlc();
      */
      iHasQuant=1;
      //debugsi("bp",ed->vlc.iBitPos);

      aQ=ed->vlc.getVlc_PN(7);
      //ed->vlc.toVLC_PN(aQ,5);
//dc=(x+a/2)*4
      ed->iDCQuant=(ed->vlc.getDC()+(aQ>>1))*4;
      //ed->iDCQuant=(ed->vlc.getDC()*4+(aQ<<1));
      //ed->vlc.toDC((ed->iDCQuant>>2)-(((aQ*3)&~3)>>2));
      bQ=ed->vlc.getDC()+((aQ*285)>>7);
      cQ=ed->vlc.getDC()+((bQ*285)>>7);


      aQUV=ed->vlc.getDC()+aQ*3;
    //  aQUV=ed->vlc.getDC()+aQ*3;

      {
         //x=dc/2-au;dc/2=(x+au);dc=(x+au)*2
         //ed->iDCQuantUV=(ed->vlc.getDC()+aQUV)*2;
//         ed->iDCQuantUV=(ed->vlc.getDC()+(aQUV>>1))*4;
         ed->iDCQuantUV=(ed->vlc.getDC()+(aQUV>>2))*4;
         bQUV=ed->vlc.getDC()+((aQUV*285)>>7);
         cQUV=ed->vlc.getDC()+((bQUV*51)>>5);
      }
     // debugsi("bp",ed->vlc.iBitPos);

//max 1000,2229,5000
      if(aQ>1500)
         return -3;
      if(bQ>4500)
         return -3;
      if(cQ>8000)
         return -3;
      if(aQUV>2500)
         return -3;
      if(bQUV>7500)
         return -3;
      if(cQUV>12000)
         return -3;
      if(ed->iDCQuantUV>4000)
         return -3;
      if(ed->iDCQuant>4000)
         return -3;

      if(aQ<2)
         return -3;
      if(bQ<2)
         return -3;
      if(cQ<2)
         return -3;
      if(aQUV<2)
         return -3;
      if(bQUV<2)
         return -3;
      if(cQUV<5)
         return -3;

      if(ed->iDCQuantUV<4)
         return -3;
      if(ed->iDCQuant<4)
         return -3;

      /*
      cQ*=9;cQ>>=3;
      bQ*=9;bQ>>=3;
      aQ*=9;aQ>>=3;
      ed->iDCQuantUV*=9;ed->iDCQuantUV>>=3;
*/
    //  ed->iDCQuant*=5;ed->iDCQuant>>=2;
//      ed->iSkipId=ed->vlc.getVlcX(4);


   }
   else{
//#if 1
      int qx;
      //qx=(((100-ed->iQValIn)*9)>>4)-6;
      //qx=42-ed->iQParam;//def
#undef TI_Q_MAX
#define TI_Q_MAX (42)
      /*
#define TI_Q_MAXB (TI_Q_MAX+6)
#define TI_Q_MAXP (TI_Q_MAX)
#define TI_Q_MAXR (TI_Q_MAX-4)
#define TI_Q_MAXI (TI_Q_MAX)
*/
      /*
#define TI_Q_MAXB (TI_Q_MAX+3-3)
#define TI_Q_MAXP (TI_Q_MAX-3)
#define TI_Q_MAXR (TI_Q_MAX-2-5)
#define TI_Q_MAXI (TI_Q_MAX-3+2)
*/
#define TI_Q_MAXB (TI_Q_MAX+2)
#define TI_Q_MAXP (TI_Q_MAX)
#define TI_Q_MAXR (TI_Q_MAX-4)
#define TI_Q_MAXI (TI_Q_MAX-1)
      int qJ=6;
      
      qx=TI_Q_MAX-ed->iQParam;
      int iqxMax=TI_Q_MAX-ed->iMaxQParam;
      //if(iqxMax<6)iqxMax=6;
     // qx=37-ed->iQParam;
      //qx=34;ed->iMaxQParam=100;//jpg  q=32 psnr 330 //keys ir ok
      //qx=28;ed->iMaxQParam=100;//jpg q=72, psnr 360
      //qx=22;ed->iMaxQParam=100;//jpg q=88, psnr 433
//qx=32;
      //qx=20;//1400
      //qx=16;///1900
      //qx=26;//700
      //qx=28;//569
      //qx=29;//518
      //qx=12;
      //qx=(102-ed->iQVal)>>1;
      
      int iDec_aQcQ=0;
      ed->iPrevWasKey=0;
      static int iPrevWasKey=0;
      static int iPrevQxNonB=5;
      static int iPrevPrevQxNonB=5;
      if(ed->iIsB || ed->iThisWasB || ed->iThisWasBX){

         if(iPrevWasKey==1)iPrevWasKey=0;
         if(iPrevWasKey==3)iPrevWasKey=4;
         /*
         if(!ed->iThisWasBX){
            qx+=2;
         }
         */
         iqxMax+=qJ/2;

//         qx+=qJ;//(qJ+1);
         qx=(iPrevQxNonB+iPrevPrevQxNonB+5)>>1;//(qJ+2)
         //qx=(iPrevQxNonB+iPrevPrevQxNonB+4)>>1;
         if(qx<iPrevPrevQxNonB+2)qx=iPrevPrevQxNonB+2;
         if(qx<iPrevQxNonB+2)qx=iPrevQxNonB+2;
         
         if(qx<20)qx=20;
         if(qx>TI_Q_MAXB)qx=TI_Q_MAXB;
         //if(qx<8)qx=8;
      }
      else  
      if(ed->iIsReferenceFrame ){
         if(iLastFrameDif>80){
         }
         else if(ed->iDecRefQ){
            qx-=1;
         }
         else{
         iDec_aQcQ=2;
         
 
  
#if 1
         
         int iqxRem=qJ;// *3>qx?((qx)/3+1):(qJ-1);
         //if(iLastFrameDif && (ed->iFramesAfterKey>3 || iLastFrameDif>40)){iqxRem>>=1;iqxRem++;}

         if(iLastFrameDif>36)iqxRem-=4;
         if(iLastFrameDif>24)iqxRem-=3;
         else if(iLastFrameDif>12)iqxRem-=2;
         else if(iLastFrameDif>4)iqxRem-=1;
         if(iqxRem<2)iqxRem=2;
         //qx-=4;//
         qx-=iqxRem;
//         qx=iPrevQxNonB-3;
         
#endif
         }
      
         iqxMax-=qJ/2;

         iPrevWasKey=0;
         //qx--;
         //qx-=4;
         if(qx<1)qx=1;
         if(qx>TI_Q_MAXR)qx=TI_Q_MAXR;
      }
      else if(ed->iIsKey){
         
         if(dctx->iMaxQParam!=100){
         iqxMax+=2;

//         qx+=qJ/2;
         if(iIsUDP){
            qx+=qJ/2;
            if(iLastFrameDif>40)qx+=(iLastFrameDif/10-2);
            if(qx<25)qx=25;
         }
         //else qx--;


         //qx-=6;
         
         
         //qx-=8;

         //
         iPrevWasKey=2;
         }
         
         //else qx-=qJ;//, dc fix, if q is const
         
         if(qx>TI_Q_MAXI)qx=TI_Q_MAXI;
         //qx=48;

         //qx=40;
         if(qx<8)qx=8;
         //qx-=6;
         
      }
      else if(iPrevWasKey &&  iLastFrameDif<8){

         
         if(iPrevWasKey==4 || iPrevWasKey==1){
            ed->iPrevWasKey=1;
            iPrevWasKey=1;
            iDec_aQcQ=1;
            iCanRestore=-1;
         }
         if(iPrevWasKey==2)iPrevWasKey=3;

         if(qx<2)qx=2;
      }
      else{
         if(qx<2)qx=2;
         if(qx>TI_Q_MAXP)qx=TI_Q_MAXP;
      }
      if(qx<iqxMax)qx=iqxMax;//rev qx=40-par;

      //qx+=6;
      /*
      if(ed->iIsB || ed->iThisWasB|| ed->iThisWasBX)qx=5;
      else if(ed->iIsReferenceFrame)qx=0;
      else qx=1;
      */

//max      qx=46;
      //if(ed->iIsReferenceFrame){qx-=6;if(qx<0)qx=0;}

//qx=1;

if(qx<1)qx=1;
//qx=6;
qx+=2;

//debugsi("iIsUDP",iIsUDP);

//qx=46;
      bQ=(24*(qJ-(qx%qJ))+(qx%qJ)*48)*(1<<(qx/qJ));//(((2<<(qx/6)))*32+qt[qx%6]*(2<<(qx/6)))*3;
     
      /*
      for(int qt=0;ed->iSkipId==0 && qt<42;qt++){
         void debugsi(char*,int);
         int qa=qt;
         int qr=((24*(6-(qa%6))+(qa%6)*48)*(1<<(qa/6)));
         int a,c,b;
         a=((qr*171)>>(9+5));
         b=qr>>5;
         c=b<<1;
         char bufq[32];sprintf(bufq,"(%d,%d,%d)",a,b,c);
         debugsi(&bufq[0],qt);
      }
      */
      if((ed->iIsB || ed->iThisWasB || ed->iThisWasBX)){if(bQ<48*32){bQ+=48*32;bQ>>=1;}}else {iPrevPrevQxNonB=iPrevQxNonB;iPrevQxNonB=qx+(ed->iIsReferenceFrame?6:0);}

      if(dctx->iMaxQParam!=100 && ed->iIsKey && bQ<48*32)bQ=48*32;
      //----------
//
int iSkK=0;
#define _QMDA 222
#define _QMDC 223
//#define _QMDA 222
//#define _QMDC 223
//      bQ*=4;bQ/=6;
       
      if(ed->iIsKey && iIsUDP){
         if(bQ<168*32){bQ=168*32;iSkK=0;}
      }
      if(ed->iIsB || ed->iThisWasB|| ed->iThisWasBX){
         if(bQ>1024*32)bQ=1024*32;
      }
      else {
         if(bQ>800*32)bQ=800*32;
      }
//if(bQ<72*32)bQ=72*32;if(bQ>288*32)bQ=288*32;
       aQ=(bQ*100)/(_QMDA);cQ=(bQ*(_QMDC)+50)/100;
       int iFixDiv=1;
       if(ed->iIsKey){
          //bQ=(aQ+cQ)>>1;
          
          //aQ=bQ*100/236;cQ=bQ*210/100;
          aQ=bQ*100/230;cQ=bQ*210/100;
          //cQ=bQ*230/100;
          
         // 100*3 500*5 2800
          iFixDiv=0;
       }
       bQ>>=5;
       cQ>>=5;
       aQ>>=5;
     // bQ=444;if(ed->iIsB || ed->iThisWasB|| ed->iThisWasBX){bQ*=3;bQ>>=1;} else if(ed->iIsReferenceFrame){bQ/=2;}\
      aQ=(bQ*100)/(_QMDA);cQ=(bQ*(_QMDC)+50)/100;


      //if(ed->iIsKey){aQ=bQ/2.8;iFixDiv=0;}




       if(iFixDiv){
          int n;
          int iBFixed=0;
          for(n=0;aQ*(223)>bQ*100 && aQ>2 && n<8;n++){if(n&1){bQ++;iBFixed=1;}else aQ--;}
          for(n=0;bQ*(222)<cQ*100 && n<8;n++){if(n&1 && !iBFixed){bQ++;iBFixed=1;}else cQ--;}
       }
//aQ=bQ/1.5;cQ=bQ*1.5;
       //if(aQ>256){aQ+=256*3;aQ>>=2;}
      
       /*
       //aQ=bQ/2.2;
     if(1){//0&&bQ>528*32){// good if psnr <35.6
         //aQ=(bQ*10/25)>>5;
         //aQ=(bQ/4)>>5;
         aQ=((bQ*171)>>(9+5));
         //cQ=bQ>>4;//>>4;//
         //cQ=(bQ*286)>>(7+5);
         cQ=(bQ*243)>>(7+5);//cQ=(bQ*19/10)>>5;
         bQ>>=5;
         iSkK=1;
      }
      else{
          aQ=(bQ*229)>>(9+5);
          cQ=(bQ*286)>>(7+5);//sqrt(5)*bQ
          bQ>>=5;
      }

      if(ed->iIsKey && iIsUDP){
         if(bQ<168){bQ=168;iSkK=0;}
      }
      if(!iSkK && bQ>15 && ed->iIsKey){
         aQ=bQ/2.9;
         cQ=bQ*2;
      }
      */
      /*
      if(1){
         aQ=(24*(6-(qx%6))+(qx%6)*24*2)*(1<<(qx/6));
         bQ=(53*(6-(qx%6))+(qx%6)*53*2)*(1<<(qx/6));
         cQ=(119*(6-(qx%6))+(qx%6)*119*2)*(1<<(qx/6));
         aQ>>=5;
         bQ>>=5;
         cQ>>=5;
      }
      */

       //cQ=((bQ*72)>>5);

       //cQ=(bQ*243)>>7;//1.9*bQ
       //cQ=(204*bQ)>>7;
       //if(ed->iIsB || ed->iThisWasB|| ed->iThisWasBX)cQ+=10;
#if 1
      //TODO if is live max q bQ=45;aQ=bQ/2.3; cQ=bQ*3;
      //TODO if is live skip frames 80 ms  after key

      
     //--- if(!ed->iIsKey && !ed->iIsB && !ed->iThisWasB)cQ=bQ*1.8+16;
      //if(!ed->iThisWasB && !iIsB)aQ=bQ/2.3;
     // cQ=bQ*2.1;
      //25700,46
#endif

      
      iHasQuant=1;
      //aQ=16;bQ=80;cQ=400;      if(ed->iIsB || ed->iThisWasB)aQ*=2;bQ*=2;cQ*=2;

      //--bQ=aQ*2.23;cQ=bQ*2.23;
      //--if(ed->iIsKey){aQ=(bQ*25)>>6;cQ=((bQ*40)>>4);}
//aQ=bQ=cQ=1;
         //aQ=4;bQ=7;cQ=10;//590 1800
       //aQ=4;bQ=8;cQ=12;//583 psnr 1800
//        aQ=5;bQ=10;cQ=15;//550 1400
       //aQ=6;bQ=12;cQ=18;//539 1200
        //aQ=8;bQ=12;cQ=16;//533 1200
       //aQ=8;bQ=16;cQ=32;//516 865
         //aQ=5;bQ=15;cQ=30;//524 1000
         //aQ=9;bQ=14;cQ=19;//520 1000
         //aQ=9;bQ=14;cQ=19;
         //aQ=1;bQ=4;cQ=16;//672 2500
         //aQ=2;bQ=8;cQ=32;//557 1700
         //aQ=6;bQ=24;cQ=96;//484 736
           //aQ=7;bQ=21;cQ=84;//490 694 KB
           //aQ=8;bQ=25;cQ=100;//480 624
        //  aQ=8;bQ=32;cQ=128;466,599KB
//          aQ=7;bQ=28;cQ=112;//475 617KB

       //aQ=10;bQ=16;cQ=28;//511,833
       //aQ=30;bQ=50;cQ=83;//438 305
       //aQ=60;bQ=100;cQ=166;//392,168
       //aQ=120;bQ=200;cQ=166*2;//344,88
      // bQ=222;//news 167 qmd=167
       //105 221
       //if(cQ<200){cQ+=200;cQ>>=1;}

       //aQ=2;bQ=5;cQ=11;       if(ed->iIsB || ed->iThisWasB|| ed->iThisWasBX){aQ=8;bQ=20;cQ=50;}
       //aQ=3;bQ=5;cQ=11;//614 3002
       //aQ=3;bQ=9;cQ=15;//571 2300
       //aQ=7;bQ=7;cQ=25;///555 2100
//       aQ=3;bQ=11;cQ=23;//553 1900
        //aQ=5;bQ=11;cQ=19;//552 1800
       //aQ=7;bQ=9;cQ=23;//550 1800
       //aQ=5;bQ=11;cQ=23;//550 1700
       //aQ=11;bQ=11;cQ=23;//530 1600
//       aQ=9;bQ=11;cQ=15;//543 1900
       //aQ=7;bQ=15;cQ=21;//533 1440
       //aQ=4;bQ=11;cQ=17;//556 2000

      //if(cQ<25)cQ=(25+cQ)>>1;
      //if(ed->iIsKey){aQ=bQ/4;cQ=bQ*4;}
      //bQ=aQ/3.34;cQ=bQ*3.34;
       //if(cQ>800){cQ+=800;cQ>>=1;bQ=(aQ*3+cQ)>>2;}
  

      //aQ=96;bQ=220;cQ=480;
      //aQ=48;bQ=108;cQ=240;
      //aQ=24;bQ=54;cQ=120;
      //aQ=12;bQ=27;cQ=60;
      //if(ed->iIsB || ed->iThisWasB){aQ*=2;bQ*=2;cQ*=2;}f

       //aQ=6;bQ=13;cQ=30;
      //aQ=5;bQ=11;cQ=25;
      //aQ=4;bQ=9;cQ=20;
      //aQ=3;bQ=7;cQ=15;
     // aQ=2;bQ=5;cQ=11;//592,1400
      //bQ=aQ*1.1;cQ=bQ*1.1;
      //bQ=cQ=aQ;
//if(ed->iIsB || ed->iThisWasB)aQ*=2;
/*
      ed->iDCQuant=((aQ*2));
      if(ed->iIsKey)ed->iDCQuant=((aQ*9)>>1);
      else{+--
      }
      */
      if(cQ<21){cQ+=21;cQ>>=1;}
      //aQ=bQ=cQ=2;
     // aQ=3;bQ=7;cQ=17;
       if(cQ<11)cQ=11;if(bQ<5)bQ=5;if(aQ<3)aQ=3;
//      if(ed->iIsKey)ed->iDCQuant=(aQ*53)>>4;else {ed->iDCQuant=aQ*2;}//if(ed->iDCQuant>1000){ed->iDCQuant+=1000;ed->iDCQuant>>=1;}}
      if(ed->iIsKey)ed->iDCQuant=aQ*4;else {ed->iDCQuant=aQ*2;}//if(ed->iDCQuant>1000){ed->iDCQuant+=1000;ed->iDCQuant>>=1;}}
//if(ed->iIsB || ed->iThisWasB|| ed->iThisWasBX)ed->iDCQuant=(ed->iDCQuant*3)>>2;
     // if(ed->iDCQuant>512){ed->iDCQuant+=512;ed->iDCQuant>>=1;}
      //--if(ed->iDCQuant>1024){ed->iDCQuant*=3;ed->iDCQuant+=1024;ed->iDCQuant>>=2;}
    //  ed->iDCQuant=3;
      //ed->iDCQuant=(qx*8+aQ*2)>>1;
      
      //ed->iDCQuant=12;
//ed->iDCQuant>>=1;
//aQ>=2;bQ>>=2;cQ>>=2;
      /*
      bQ=200;
      cQ=bQ*2.7;
      aQ=bQ/2.7;
      ed->iDCQuant=cQ;
*/
      //ed->iDCQuant=aQ*2;      if(ed->iIsKey)ed->iDCQuant=aQ*4;
//      if((ed->iIsB || ed->iThisWasB || ed->iThisWasBX)){ed->iDCQuant*=3;ed->iDCQuant>>=2;}

      //
      //if(!ed->iIsKey){ed->iDCQuant*=3;ed->iDCQuant>>=1;}
      if(ed->iDCQuant>150){
         ed->iDCQuant&=~7;
      }
      else{
         ed->iDCQuant+=3;
         ed->iDCQuant&=~3;
      }
      
if(ed->iDCQuant<4)ed->iDCQuant=4;
//ed->iDCQuant=8;
      //x=dc/2-au;dc/2=(x+au);dc=(x+au)*2;
//x=dc/4-a/2 dc=(x+a/2)*4
     // if(ed->iIsKey){aQ*=9;aQ>>=3;}
      ed->vlc.toVLC_PN(aQ,7);
      ed->vlc.toDC((ed->iDCQuant>>2)-(aQ>>1));
      //ed->vlc.toDC(bQ-((aQ*286)>>7));
      ed->vlc.toDC(bQ-((aQ*285)>>7));
      ed->vlc.toDC(cQ-((bQ*285)>>7));
      //ed->iDCQuant=aQ*4;
      //--aQUV=(aQ*4+128)>>1;
  //    aQUV=aQ;
#if 1

      //bQUV=((aQUV*96)>>5);
      //cQUV=((bQUV*51)>>5);

      if(1|| iSkK ){
         //aQUV=(aQ)*4;//ed->iIsKey?bQ:aQ;//aQ*2;
//if(ed->iIsKey)aQUV<<=1;//bez 410 509KB
         //if(ed->iIsReferenceFrame)ed->iIsKeyUV=1;
         if(!iIsB && iLastFrameDif>70)ed->iIsKeyUV=1;
         else if(ed->iIsReferenceFrame && iLastFrameDif>50)ed->iIsKeyUV=1;


         ed->iDCQuantUV=aQ*3;//(ed->iDCQuant*3+16)>>1;//aQ*4;
//ed->iDCQuantUV=256;
         if(ed->iDCQuantUV>768){ed->iDCQuantUV+=768*3;ed->iDCQuantUV>>=2;}
         if(ed->iIsKey || ed->iIsKeyUV){ed->iDCQuantUV*=7;ed->iDCQuantUV>>=2;}
         //if(ed->iIsKey || ed->iIsKeyUV){ed->iDCQuantUV*=2;}
         aQUV=aQ*3;//ed->iDCQuantUV;//aQ*2;//(ed->iDCQuantUV*3+8)>>2;
         if(aQUV<96){aQUV*=3;aQUV+=96;aQUV>>=2;}
         if(ed->iDCQuantUV<32){ed->iDCQuantUV+=32;ed->iDCQuantUV>>=1;}//ed->iDCQuantUV*=3;

         ed->iDCQuantUV+=7;ed->iDCQuantUV&=~7;
         //if(ed->iDCQuantUV<24){ed->iDCQuantUV+=24;ed->iDCQuantUV>>=1;ed->iDCQuantUV+=7;ed->iDCQuantUV&=~7;}

         //--aQUV=ed->iDCQuantUV>>1;//((ed->iDCQuantUV*3)>>2);
         //aQUV=ed->iDCQuantUV;
         //if(ed->iDCQuantUV>1024){ed->iDCQuantUV+=1024;ed->iDCQuantUV>>=1;}
         //if(ed->iDCQuantUV>1500){ed->iDCQuantUV+=1500*3;ed->iDCQuantUV>>=2;}
         //aQUV=ed->iDCQuantUV>>1;
         //ed->iDCQuantUV=ed->iDCQuant;
         //aQUV=aQ;
         //ed->iDCQuantUV=ed->iDCQuant;
         bQUV=((aQUV*285)>>7);
         cQUV=((bQUV*51)>>5);
         //bQUV<<1;
        // if(ed->iIsKey)ed->iDCQuantUV>>=1;
         //if(ed->iIsKey)ed->iDCQuantUV=cQUV;

      }
#endif
      //x=au-a*2;au=x+a*2
      //ed->vlc.toDC(aQUV-aQ*3);
     
      //ed->iDCQuantUV=(ed->vlc.getDC()+(bQ>>2))<<2;

      ed->vlc.toDC(aQUV-aQ*3);

      {
         //x=dc/2-au;dc/2=(x+au);dc=(x+au)*2
         ed->vlc.toDC((ed->iDCQuantUV>>2)-(aQUV>>2));   
         ed->vlc.toDC(bQUV-((aQUV*285)>>7));
         ed->vlc.toDC(cQUV-((bQUV*51)>>5));
      }
      


      iPosBeforeSkipID=ed->vlc.iBitPos;
//---      ed->vlc.toVLC_X(ed->iSkipId,4);
     // debugss("aQ3",aQ,bQ);
   }
   //aQ=100;bQ=200;cQ=400;ed->iDCQuant=100;
//if(iDec)return 0;
   

   if(iHasQuant){
     //--- if(aQ<8)debugss("aQ",aQ,iHasQuant);
      initQ4x4(&ed->tab_y[0], 0 , iIsB|ed->iThisWasB|ed->iThisWasBX, aQ,bQ, cQ);
      if(!ed->iIsReferenceFrame && !iDec && !ed->iIsKey)initQ4x4_SkipLast(&ed->tab_y_b[0],iIsB|ed->iThisWasB|ed->iThisWasBX, aQ,bQ, cQ);
//      initQ4x4(&ed->tab_uv[0], 1 , iIsB, (aQ+(uvQ/2)),(bQ+uvQ), (cQ+(uvQ*3/2)));
      initQ4x4(&ed->tab_uv[0], 1 , iIsB|ed->iThisWasB|ed->iThisWasBX, aQUV,bQUV, cQUV);
   }
   ed->iLowHiQCode=ed->tab_y[0]>150?1:2;
   if(!iDec){
      ed->initTabSK();
      ed->calc4x4SQErr();
      if(ed->iSkipId==0){
         ed->iLastYBits=0;
        // debugsi("aQ",aQ);
      }
      if(!iIsB && !ed->iThisWasBX && !ed->iThisWasB){
         memcpy(ed->nbtab_y,ed->tab_y,sizeof(ed->tab_y));
         memcpy(ed->nbtab_uv,ed->tab_uv,sizeof(ed->tab_uv));
      }
      while(ed->vlc.iBitPos&7)ed->vlc.addB(1);
   }
   else{
      ed->vlc.iBitPos+=7;ed->vlc.iBitPos>>=3;ed->vlc.iBitPos<<=3;//byteAlign
   }
   int iPosToEncodedCnt=ed->vlc.iBitPos;

   if(iDec){
      iEnc=ed->vlc.pBitBuf[iPosToEncodedCnt>>3]<<8;
      iEnc+=ed->vlc.pBitBuf[(iPosToEncodedCnt>>3)+1];
      
   }

   ed->vlc.iBitPos+=16;
   
   int iSkiped=0;
   ENC_BL_CTX ctx;
   ctx.h=h;
   ctx.w=w;
   ctx.m=0;
   ctx.mb=NULL;
   int iUseDct8x8=0;
   static int iUse8x8=0;
   static int iCheckPic=1;

   static int stats[3];//pic,difs,cnt

   int iLastNBit=0;
   const int iBlocksPerRow=w>>4;
   
   int iNewBLT=0;

#if 1
   static unsigned char *bl_type=NULL;if(!bl_type)bl_type=new unsigned char[18000*3];
   int iEncTrys[3]={0,0,0};
   int iEncFrom[3]={-1,-1,-1};
   int iEncType[3][3]={{0,0,0},{0,0,0},{0,0,0}};
   int iLastEncBit=ed->vlc.iBitPos;
   if(iDec){
      int bp=ed->vlc.iBitPos;
      ed->vlc.iBitPos=iEnc*8;
      for(k=0;k<3;k++){
#ifdef T_USE_PRED16
         //--if(k)break;
#endif
         decBlockType(ed,w>>4,iEncFrom[k],&bl_type[k*(w>>4)*(h>>4)],iEncTrys[k],iEncType[k][BL_TYPE_PIC],iEncType[k][BL_TYPE_DIF],iEncType[k][BL_TYPE_SK]);
         if(iEncType[k][BL_TYPE_PIC]+iEncType[k][BL_TYPE_DIF]+iEncType[k][BL_TYPE_SK]>(w>>4)*(h>>4)
            || iEncFrom[k]+iEncTrys[k]>(w>>4)*(h>>4))
            return -7;
      }
      iLastEncBit=ed->vlc.iBitPos;
      ed->vlc.iBitPos=bp;

   }

   iNewBLT=1;

   for(k=0;k<3;k++){
      //if(iDec && k)break;


#ifdef T_USE_PRED16
      //--if(k)break;
#endif
      ed->iPredDC=0;
      iIsHada=1;iUseDct8x8=0;

      ctx.iIsHada=iIsHada;
      ctx.iUseDct8x8=iUseDct8x8;

      if(iDec && iEncTrys[k]==0){
         id+=(h>>4)*(w>>4);
         continue;
      }

      iEncTmp=iEnc;

     int idc=0;
     int idcEnc=iEncType[k][BL_TYPE_PIC]+iEncType[k][BL_TYPE_DIF];
      for(j=0;j<h-15;j+=16){
         //ofs=j*w*3+(k?(k==2?(k+3):(k-3)):k);
         //id=(h>>4)*(w>>4)*k;
         ofs=j*w*3+k;
         ed->iPredDC=0;

         for(i=0;i<w-15;i+=16,ofs+=48,id++,idc++){
      //      if(idc&1)continue;
            //if(i==0 || j==0 || j+16>=h || i+16>=w)continue;
            
            ctx.i=i;ctx.j=j;
            ctx.iIsPic=0;
            ctx.iMeanUV=5000;
            
            if(iDec){
               id=idc+(h>>4)*(w>>4)*k;
               if(idcEnc<=0){i=w;j=h;break;}
               if(!iIsKey && bl_type[id]==BL_TYPE_SK)continue;
//               if(id<ed->iSkipId)continue;
               if(idc<iEncFrom[k])continue;
               
               idcEnc--;

               int r;
               if(iIsKey){
                  iEnc--;
                  r=encMB16<iDec,1>(&ctx,ed,pCur+ofs,pRef+ofs, stride,k,iIsB,0,iIsBigCost);
                  stats[0]++;
                  if(r<0)
                     return r;
                  continue;
               }

               iEnc--;
               
               if(bl_type[id]==BL_TYPE_PIC){
                  stats[0]++;
                 r=encMB16<iDec,1>(&ctx,ed,pCur+ofs,pRef+ofs, stride,k,iIsB,0,iIsBigCost);
               }
               else{
                  stats[1]++;
                  r=encMB16<iDec,0>(&ctx,ed,pCur+ofs,pRef+ofs, stride,k,iIsB,0,iIsBigCost);
               }
               if(r<0)
                  return r;
            }
            else {
               if(id<ed->iSkipId){  continue;}

               if(ed->vlc.getBytePos()>ed->iPartLimitSize){
                  i=w;j=h;k=3;
                  ed->iSkipId=id;
                  iSkiped=1;
                  
                  break;
               }
               if(iEncFrom[k]==-1)iEncFrom[k]=idc;
               iEncTrys[k]++;

               ctx.mb=&ed->mb16_2[idc];
               int iBPos=ed->vlc.iBitPos;
               if(iIsKey){
                  iEncType[k][BL_TYPE_PIC]++;
                  bl_type[id]=BL_TYPE_PIC;
                  iEnc++;
                  encMB16<iDec,1>(&ctx,ed,pCur+ofs,pRef+ofs, stride,k,iIsB,0,iIsBigCost);
if(!k)ed->iLastYBits+=(ed->vlc.iBitPos-iBPos);
                  continue;
               }
               
               {
                  int e;
                  int iDev=-1;
                  int iUVMode=5;
                  ctx.iHasUVMode=0;
                  
                  //ctx.iIsHada
#if 0
                  if(0&&k){//iUseDct8x8==2 && k){
                     iUVMode=getUVMode(&ctx,ed, pCur+ofs, pRef+ofs, stride, k, iIsB);
                     if(iIsB && iUVMode==3)iUVMode=1;
                   //  if(iUseDct8x8!=2 && iUVMode==2 && iIsHada)iUVMode=1;
                     //if(iUVMode==0)iUVMode=iIsB?0:3;
                  }
                  if(iUVMode!=5){
                     int iPrevUVM=iUVMode;
                     
                     if(iUVMode==4){
                        //iUVMode=0;
                        
                        //pRest[idc]=0;
                        //int sz=ed->vlc.iBitPos-iBPos-1-(!iIsB);
                        //ed->vlc.iBitPos=iBPos;
   
                        //ed->vlc.copyBits(ed->vlc.pBitBuf,iBPos+1+,sz);

                        bl_type[id]=BL_TYPE_DIF;iEncType[k][bl_type[id]]++;
                        ctx.mb->col[k].iType=MB16_2::eDif4x4;
                        pEncStat->iBlocksDifSent[k]++;
                        iEnc++;
                        iLastNBit=ed->vlc.iBitPos;
                        ctx.mb->col[k].iSkip=MB16_2::eNotSkiped;
                        setSkip_STAT(ctx.i>>4,ctx.j>>4,k,ctx.w,ctx.mb->col[k].iSkip);
                        continue;
                     }
                     if(iUVMode==1){
                        
                        e=encMB16<iDec,0>(&ctx,ed,pCur+ofs,pRef+ofs, stride,k,iIsB,1,iIsBigCost);
                        ctx.iMeanUV=1000;
                       // debugss("muv1",k,e);
                        if(e==0)iUVMode=0;//iIsB?0:3;
                        else if(e==7 && !iIsB)iUVMode=3;
                        else{
                           ctx.mb->col[k].iType=MB16_2::eDif4x4;
                           pEncStat->iBlocksDifSent[k]++;
                           bl_type[id]=BL_TYPE_DIF;iEncType[k][bl_type[id]]++;
                        }
                     }
                     if(iUVMode==3 && !iIsB){
                     //   debugss("muv3",k,e);
                        ed->vlc.iBitPos=iBPos;
//                        int tmp=ed->vlc.iBitPos;
                         e=encMB16<iDec,1>(&ctx,ed,pCur+ofs,pRef+ofs, stride,k,iIsB,0,iIsBigCost,0);
                        ctx.mb->col[k].iType=MB16_2::ePic4x4;
                        pEncStat->iBlocksPicSent[k]++;
                        bl_type[id]=BL_TYPE_PIC;iEncType[k][bl_type[id]]++;
                     }
                     if(iUVMode==0){
                        ed->vlc.iBitPos=iBPos;
                        
                        bl_type[id]=BL_TYPE_SK;iEncType[k][bl_type[id]]++;
                        iCheckNextNonDif=0;
                        if(ctx.mb->col[k].iSkip==MB16_2::eNotSkiped)ctx.mb->col[k].iSkip=MB16_2::eSkipPsnr;
                        ctx.mb->col[k].iType=MB16_2::eSkiped;
                        setSkip_STAT(ctx.i>>4,ctx.j>>4,k,ctx.w,ctx.mb->col[k].iSkip);
                        continue;
                     }
                     iEnc++;
                     //pRest[idc]=0;
                     iLastNBit=ed->vlc.iBitPos;
                     ctx.mb->col[k].iSkip=MB16_2::eNotSkiped;
                     setSkip_STAT(ctx.i>>4,ctx.j>>4,k,ctx.w,ctx.mb->col[k].iSkip);
                     continue;
                  }
#endif
                  //
bl_type[id]=BL_TYPE_DIF;
                  ctx.iUVPsnr=0;
                  //if(k==1 && !iIsB && (((j>>4)&1)))e=7;else 
                //  if(k==0 && !iIsB && !(((j>>4)&1)))e=7;else 
                  //else if(!k)
                  int dcPr=ed->iPredDC;

                    e=(k && ed->iIsKeyUV)?7:encMB16<iDec,0>(&ctx,ed,pCur+ofs,pRef+ofs, stride,k,iIsB,iCanRestore, iIsBigCost);
                  //else e=0;
                //  if(k==1)pRest[id]=e;
                  if(!e){
                     ed->vlc.iBitPos=iBPos;
                     bl_type[id]=BL_TYPE_SK;
                     ctx.mb->col[k].iType=MB16_2::eSkiped;
                     
//if(k==0)pRest[idc]=5;
                     //else if(k==1 && pRest[idc]==5)pRest[idc]=6;
                     //else pRest[idc]=0;
                     iCheckNextNonDif=0;
                     if(ctx.mb->col[k].iSkip==MB16_2::eNotSkiped)ctx.mb->col[k].iSkip=MB16_2::eSkipPsnr;
                  }
                  else {
                     ctx.mb->col[k].iSkip=MB16_2::eNotSkiped;
                     ctx.mb->col[k].iType=MB16_2::eDif4x4;
                     int iUV=!!k;
                     //pRest[idc]=0;
                     iEnc++;
                     int iDifBits=ed->vlc.iBitPos-iBPos;
                     static int iAvgDifBits16[2];
                     static int iAvgPicBits2[2];
                     if(e==7){
                        bl_type[id]=BL_TYPE_PIC;   
                        ed->vlc.iBitPos=iBPos;
                        int tmp=ed->vlc.iBitPos;
                        e=encMB16<iDec,1>(&ctx,ed,pCur+ofs,pRef+ofs, stride,k,iIsB,0,iIsBigCost,0);
                        pEncStat->iBlocksPicSent[k]++;
                        ctx.mb->col[k].iType=MB16_2::ePic4x4;
                        iCheckNextNonDif=1;
                        int iPicBits=ed->vlc.iBitPos-tmp;
                        iDifBits=iPicBits;
                        iAvgPicBits2[iUV]*=7;iAvgPicBits2[iUV]+=iPicBits;iAvgPicBits2[iUV]>>=3;
                        if(iAvgDifBits16[iUV]>iPicBits)iAvgDifBits16[iUV]=iPicBits;
                     }
                     else{
                        pEncStat->iBlocksDifSent[k]++;
//                        int iPrevISPic=idc>=iBlocksPerRow && ctx.mb[-iBlocksPerRow].col[k].iType==MB16_2::ePic4x4;
                        int iPrevISPic=idc && ctx.mb[-1].col[k].iType==MB16_2::ePic4x4;
                        if((k && (iDifBits>2 || iPrevISPic)) || iDifBits*8>iAvgPicBits2[iUV]*7)iIsBigCost=3;
                        if(!iCheckNextNonDif && iPrevISPic)iCheckNextNonDif=1;
                        if(!ctx.m && (!useFastBlockType()|| (iIsBigCost==3)) && (ed->iIsFirstPass  && !iIsB && (iIsBigCost || (k && iCheckNextNonDif)))){
                           int bpDE=ed->vlc.iBitPos;
                           ed->vlc.iBitPos+=100;
                           int tmp=ed->vlc.iBitPos;
                           //e=encMB16_DCT<iDec,1>(ed,pCur+ofs,pRef+ofs, stride,k,iIsB,0,iIsBigCost);
                           //debugss("test pic",k*10000+iDifBits,ctx.mb[0].col[k].iStartPsnr);
                              int sz=iDifBits-(!pEncStat->iBlocksPicSent[k])*2+iPrevISPic*3;//((iDifBits*14+ed->iIsReferenceFrame*8)>>4)+(ed->iIsReferenceFrame?(k?15:40):8);
                              if(k&& ctx.mb->col[0].iType==MB16_2::ePic4x4)sz+=3;
                              if(sz<4)sz=4;
                              //if(iIsBigCost)sz+=(k?8:25);
                              //if(iDifBits>sz+60)sz=iDifBits+60;
                              e=encMB16<iDec,1>(&ctx,ed,pCur+ofs,pRef+ofs, stride,k,iIsB,0,iIsBigCost,sz);

                           iCheckNextNonDif=0;
                           if(e>0){
                              int iPicBits=ed->vlc.iBitPos-tmp;
                              if(iAvgDifBits16[iUV]>iPicBits)iAvgDifBits16[iUV]=iPicBits;
                              iAvgPicBits2[iUV]+=iPicBits;iAvgPicBits2[iUV]>>=1;
                              iCheckNextNonDif=iPicBits<(iDifBits+20);
                              ed->vlc.iBitPos=iBPos;

                              bl_type[id]=BL_TYPE_PIC;
                              ctx.mb->col[k].iType=MB16_2::ePic4x4;
                              ed->vlc.copyBits(ed->vlc.pBitBuf,tmp,iPicBits);
                              

                              iDifBits=iPicBits;
                              pEncStat->iBlocksPicSent[k]++;
                              pEncStat->iBlocksDifSent[k]--;
                           }
                           else ed->vlc.iBitPos=bpDE;
                        }
                        if(ctx.mb->col[k].iType!=MB16_2::ePic4x4){
                           iAvgDifBits16[iUV]*=15;iAvgDifBits16[iUV]+=iDifBits+8;iAvgDifBits16[iUV]>>=4;
                        }
                     }
                     pEncStat->iAvgSize[k]+=iDifBits;
                     if(!k)ed->iLastYBits+=iDifBits;

                     iLastNBit=ed->vlc.iBitPos;

                     if(!iDec && bl_type[id]!=BL_TYPE_PIC){
                        ed->iPredDC=dcPr;
                     }

                        

                  }
                  if(!iDec){
                     iEncType[k][bl_type[id]]++;
                     setSkip_STAT(ctx.i>>4,ctx.j>>4,k,ctx.w,ctx.mb->col[k].iSkip);
                  }
               }
               
            }
            
         }
      }
   }
   if(iDec){
      ed->vlc.iBitPos=iLastEncBit;
   }
   else if(!iDec && iEnc){
      if(ed->vlc.iBitPos&7)ed->vlc.addXBits(0xff,8-(ed->vlc.iBitPos&7));
      int iPosE=ed->vlc.iBitPos>>3;
      ed->vlc.pBitBuf[iPosToEncodedCnt>>3]=(iPosE>>8);
      ed->vlc.pBitBuf[(iPosToEncodedCnt>>3)+1]=iPosE-((iPosE>>8)<<8);
      int iBPDB=ed->vlc.iBitPos;
      for(k=0;k<3;k++){
#ifdef T_USE_PRED16
         //--if(k)break;
#endif
         encBlockType(ed,w>>4,iEncFrom[k],&bl_type[k*(w>>4)*(h>>4)],iEncTrys[k],iEncType[k][BL_TYPE_PIC],iEncType[k][BL_TYPE_DIF],iEncType[k][BL_TYPE_SK]);
         if(!k)ed->iLastYBits+=(ed->vlc.iBitPos-iBPDB);
      }
      iLastNBit=ed->vlc.iBitPos;
   }
#endif
 
   if(!iDec && !iEnc){ed->vlc.iBitPos=iBitPos;ed->iSkipId=0;}
   if(!iDec){
      if(iEnc){
         if(!iNewBLT){
            ed->vlc.pBitBuf[iPosToEncodedCnt>>3]=(iEnc>>8);
            ed->vlc.pBitBuf[(iPosToEncodedCnt>>3)+1]=iEnc-((iEnc>>8)<<8);


            if(iLastNBit && iLastNBit<ed->vlc.iBitPos)ed->vlc.iBitPos=iLastNBit;
         }
         while(ed->vlc.iBitPos&7){
            ed->vlc.addB(1);
         }
      }


      /*
      if(iLastNBit){
         ed->vlc.addB(1);ed->vlc.addB(1);ed->vlc.addB(1);ed->vlc.addB(1);ed->vlc.addB(1);ed->vlc.addB(1);ed->vlc.addB(1);
         ed->vlc.iBitPos=((iLastNBit+7)>>3)<<3;
      }
      */

      if(!iSkiped )ed->iSkipId=-1;;
      iBitsGain=0;
   }
   if(!iDec && ed->iSkipId==-1){
      debugT(pEncStat,0);
      debugT(pEncStat,1);
      debugT(pEncStat,2);
   }
   if(g_iDeblock && !iDec && (!iIsB && !ed->iThisWasB && !ed->iThisWasBX)  && (ed->iSkipId==-1)){// || ed->iSkipId>3*(w*h>>8))-8) {
      void deblock_yuv(unsigned char *p ,int w, int h, int stride, int iEnc, int iB);
      deblock_yuv(pCur,w,h,stride, !iDec,!!iIsB);
   }
   //if(iDec){int sts=stats[0]+stats[1];if(sts)debugss("stats",stats[0]*1000/sts,stats[1]*1000/sts);}

   return ed->vlc.getBytePos();


}
#ifdef T_CAN_TEST_V
//ndef _WIN32_WCE
//#pragma comment(lib, "vcomp")
//#include <omp.h>
#endif
void deblock_yuv(unsigned char *pCur ,int w, int h, int stride, int iEnc, int iB){
//  return;
      //debugss("fi",iDec,0);
   TDCTX *ed=iEnc?dctx:dctDec;
   
   if(!ed || ed->iVisDecoder || (g_iSkipLoop && !ed->iFilter))return;

  
   int iIsKey=!iB &&ed->iIsKey;
#ifdef T_USE_PRED16
   if(iIsKey)iIsKey++;
#endif
   const int iIsB=(ed->iIsB|ed->iThisWasB|iB);
   const int t0=ed->tab_y[128]>>3;//((ed->tab_y[128]+8)>>3);

   //==const int iFC=((ed->tab_y[129]>>4)+ed->tab_y[128]/9+1)>>1;//(((ed->tab_y[129]*5)>>6));
   //==const int iFC_UV=((ed->tab_uv[129]>>4)+ed->tab_uv[128]/9+1)>>1;//(((ed->tab_uv[129]*5)>>6));
   //126,82 ->24
   //84,30->6
   //62,40->8
   //if(iEnc)debugss("a",getDCQuant4x4<0>(ed,0,0),ed->tab_y[128]);
   //getDCQuant4x4<0>(ed,0,0)/7
#ifdef _TEST_T_BITS
  // if(ed->iIsKey)return;
   if(iIsKey==1)iIsKey=2;
//   if(ed->tab_y[129]<24 || ed->tab_y[128]<16)return;
   int fs=0;
//   int iFC=(((ed->iDCQuant+ed->tab_y[129])*6)>>7)+4;//(ed->iDCQuant*((!!iIsKey) +1)+ed->tab_y[129]+48)>>4;//
   int iFC=(((ed->iDCQuant+ed->tab_y[129])*7)>>7)+4;//(ed->iDCQuant*((!!iIsKey) +1)+ed->tab_y[129]+48)>>4;//
   if(iIsKey){iFC*=3;iFC>>=2;}
  // _GET_FC(fs,ed->tab_y[129],ed->iDCQuant);//+(ed->iDCQuant>>(3+iIsKey));//testFStrenght(0,ed->tab_y[129],0,0)+(ed->iDCQuant>>4)+(ed->tab_y[128]>>4);;//(ed->tab_y[128]>>3)+(ed->iDCQuant>>4);
   if(iFC>199)iFC=199;
   int iFC_UV=0;
   fs=setFTabA(ed->tab_y[128],!!iIsKey);
  // debugsi("iFC",iFC);
   

  // void tfimg(unsigned char *p,int w,int h, int st, int sh);
  // int shStr=fs>>2;
  // if(shStr>1)tfimg(pCur,w,h, shStr-1,0);

   if(fs<1 || ed->tab_y[128]<16)iFC=0;
   //debugsi("fs-Y",fs);

   //iFC_UV=testFStrenght(0,0,ed->tab_y[128],0)+(ed->tab_uv[128]>>4)+(ed->iDCQuantUV>>4);
//   iFC_UV=(4+((ed->iDCQuantUV+ed->tab_uv[129])*6)>>7);//(ed->iDCQuantUV*((!!iIsKey) +1)+ed->tab_uv[129]+48)>>4;//
   iFC_UV=(((ed->iDCQuantUV+ed->tab_uv[129])*5)>>7)+4;//(ed->iDCQuantUV*((!!iIsKey) +1)+ed->tab_uv[129]+48)>>4;//
   _GET_FC(fs,ed->tab_uv[129],ed->iDCQuantUV);//+(ed->iDCQuantUV>>(3+iIsKey));//testFStrenght(0,0,ed->tab_uv[128],0)+(ed->iDCQuantUV>>4)+(ed->tab_y[128]>>4);//(ed->tab_uv[128]>>3)+
   if(iIsKey){iFC_UV*=3;iFC_UV>>=2;}
   if(iFC_UV>200)iFC_UV=200;
   if(fs<1 || ed->tab_uv[128]<16)iFC_UV=0;
//   if(iFC_UV)iFC_UV+=(ed->tab_uv[128]>>4);
  // if(iFC)iFC+=(ed->tab_y[128]>>4);
   //debugsi("iFC",iFC+iEnc*1000+iB*1000000);
   
    //int iFC=(((ed->tab_y[128]>>3)+(ed->tab_y[129]>>4))>>1)+(ed->iDCQuant>>5);
//    int iFC_UV=(((ed->tab_uv[128]>>3)+(ed->tab_uv[129]>>4))>>1)+(ed->iDCQuantUV>>5);

#else
   if(ed->tab_y[129]<32 || ed->tab_y[128]<16)return;
   int iFC=getDCQuant4x4<0>(ed,0,iIsB)<48?0:(iIsB?(ed->tab_y[128]>>2):((ed->tab_y[128]+6)/5));//((ed->tab_y[129]+8)>>4)+(getDCQuant4x4<0>(ed,0,0)>>4)*(1+(!!ed->iIsB)*2)+4;//(ed->tab_y[128]>>3);
   //const int iFC=((ed->tab_y[128])>>3)+(getDCQuant4x4<0>(ed,0,0)>>4)*(1+(!!ed->iIsB)*2)+2;
   int iFC_UV=getDCQuant4x4<0>(ed,1,iIsB)<48?0:
      (iIsKey?((ed->tab_uv[3]>>3)+2):(ed->tab_uv[128]>>2));//+(ed->tab_uv[128]>>3);

#endif
//   pCur[0]=235; if(iEnc)pCur[3]=235;else pCur[6]=235;
//   int getLoopIDX(int idx);
   //if(iIsB){iFC*=2;iFC_UV*=2;}
  // const int idxY=ed->tab_y[129]>32?getLoopIDX(iFC):0;
  // const int idxUV=ed->tab_uv[129]>32?getLoopIDX(iFC_UV):0;
   //if(idxY<1 && idxUV<1)return;
   if(iFC<3 && iFC_UV<3)return;
   char *getDeblFlags(int iDec, int w, int h);
   void filter_16_top(unsigned char *p, int stride, int a);
   void filter_16_left(unsigned char *p, int stride, int a);
   void filter_16_topUV(unsigned char *p, int stride, int a);
   void filter_16_leftUV(unsigned char *p, int stride, int a);
   void filter_8x8_16_ab(unsigned char *p, int stride, int a);
   void filter_8x8_16_v(unsigned char *p, int stride, int a);
   void filter_4x4_16_a(unsigned char *p, int stride, int a);
#ifdef T_CAN_TEST_V
   int z;
//#undef _OMPAPI
      char *dblx=getDeblFlags(!iEnc,w,h);
//omp_set_num_threads( omp_get_num_procs() );
//debugsi("proc cnt",omp_get_num_procs());
//#pragma omp parallel
//#pragma omp parallel for
   for(z=0;z<2;z++)
//omp_set_num_threads(2);
//#pragma omp parallel num_threads(2)
//#pragma omp parallel num_threads(omp_get_num_procs())
   {
  //    int z = omp_get_thread_num();
      //debugsi("tid",z);

      

      //int stj=z<2?0:((h>>5)<<4);
     // int enj=z<2?((h>>5)<<4):h;
      //dbl+=((stj>>4)*(w>>4));
      int xc=w>>4,yc=h>>4;
#ifdef _OMPAPI
#pragma omp parallel for
#endif
      for(int j=0;j<yc;j++){
     // int m = omp_get_thread_num();
      //debugsi("tid",m);
     
         char *dbl=dblx+xc*j;
         for(int i=0;i<xc;i++,dbl++){
            int ofs=(j*16*stride+i*48);
            /*
            if(1){
               int T=z==1 && j;
               int L=z==0 && i;
               ofs=(j*4*stride+i*12);
               if(T)filter_16_top(pCur+ofs,  stride, iFC);
               if(L)filter_16_left(pCur+ofs,  stride,iFC);
               if(T)filter_16_topUV(pCur+ofs+1,  stride, iFC_UV);
               if(L)filter_16_leftUV(pCur+ofs+1,  stride,iFC_UV);
               if(T)filter_16_topUV(pCur+ofs+2,  stride, iFC_UV);
               if(L)filter_16_leftUV(pCur+ofs+2,  stride,iFC_UV);
               continue;
            }
            */
            int T=z==1 && j && (iIsKey || (dbl[0]&(1|4)));
            int L=z==0 && i && (iIsKey || (dbl[0]&(2|8)));

            //if(z==0 && !iIsKey && (dbl[0]&16) && iFC>2)filter_8x8_16_v(pCur+ofs,stride,iFC);
            if(!iIsKey && (dbl[0]&16) && iFC>2){
               
void filter_4x4_16_a_dcf(unsigned char *p, int stride, int a, int *f, int *dc);
//if(!z)filter_4x4_16_a_dcf(pCur,  stride, iFC,NULL,NULL);
               if(z==1){filter_16_top(pCur+ofs+stride*8,  stride, iFC);dbl[0]&=~16;}
               else if(z==0)filter_16_left(pCur+ofs+24,  stride,iFC);
               /*
               if(T)filter_16_top(pCur+ofs+stride*4,  stride, iFC);
               if(L)filter_16_left(pCur+ofs+12,  stride,iFC);
               if(T)filter_16_top(pCur+ofs+stride*12,  stride, iFC);
               if(L)filter_16_left(pCur+ofs+36,  stride,iFC);
               */
            }

            if(iIsKey!=1 && iFC>2){
               if(T)filter_16_top(pCur+ofs,  stride, iFC);
               if(L)filter_16_left(pCur+ofs,  stride,iFC);
            }

            if(iFC_UV>2 && iIsKey!=1){
               if(T)filter_16_topUV(pCur+ofs+1,  stride, iFC_UV);
               if(L)filter_16_leftUV(pCur+ofs+1,  stride,iFC_UV);
               if(T)filter_16_topUV(pCur+ofs+2,  stride, iFC_UV);
               if(L)filter_16_leftUV(pCur+ofs+2,  stride,iFC_UV);
            }
         }
      }
   }
#else
   char *dbl=getDeblFlags(!iEnc,w,h);
   int i,j,ofs;
   for(j=0;j<h-15;j+=16){
      ofs=j*stride;
      for(i=0;i<w-15;i+=16,ofs+=48,dbl++){
#if 1
         int T=j && (iIsKey || (dbl[0]&(1|4)));
         int L=i && (iIsKey || (dbl[0]&(2|8)));
#ifndef T_CAN_TEST_V
         if(iIsB && dbl[0]&32 && t0>4){
            void filter_4x4_16_dif(unsigned char *p, int stride, int a, int rem);
            filter_4x4_16_dif(pCur+ofs,  stride, t0,1);
         }
         else 
#endif
          if(//iIsB && 
            !iIsKey && (dbl[0]&16) && t0>4){
               filter_8x8_16_v(pCur+ofs,stride,t0);
               //filter_4x4_16_dif(pCur+ofs,  stride, iFC,ed->iIsB?100:0);
         }

         if(iIsKey!=1 && iFC>2){
            if(T)filter_16_top(pCur+ofs,  stride, iFC);
            if(L)filter_16_left(pCur+ofs,  stride,iFC);
         }

         if(iFC_UV>2 && iIsKey!=1){
#ifdef T_CAN_TEST_V
//            if((j && (dbl[0]&4)))T|=2;
  //          if((i && (dbl[0]&8)))L|=2;
            if(T)filter_16_topUV(pCur+ofs+1,  stride, iFC_UV);
            if(L)filter_16_leftUV(pCur+ofs+1,  stride,iFC_UV);
            if(T)filter_16_topUV(pCur+ofs+2,  stride, iFC_UV);
            if(L)filter_16_leftUV(pCur+ofs+2,  stride,iFC_UV);
#else
            if(T)filter_16_top(pCur+ofs+1,  stride, iFC_UV);
            if(L)filter_16_left(pCur+ofs+1,  stride,iFC_UV);
            if(T)filter_16_top(pCur+ofs+2,  stride, iFC_UV);
            if(L)filter_16_left(pCur+ofs+2,  stride,iFC_UV);
#endif

            //TODO fast if dc only

         }
         if(iIsKey && !iFXTest){
            filter_8x8_16_ab(pCur+ofs+1,stride,iFC_UV);
            filter_8x8_16_ab(pCur+ofs+2,stride,iFC_UV);
         }
#endif
      }
   }
#endif
   //shStr--;if(shStr>0)tfimg(pCur,w,h, shStr,1);

}

template <int iDec>
int enc_decMB_X(TDCTX *ed, unsigned char *pCur, unsigned char *pRef,int w, int h, int *iHada, int *dc){
   int iIsKey=ed->iIsKey;
   int  iIsB=ed->iIsKey;
   int iBitPos=ed->vlc.iBitPos;
   int iIsBigCost,iBitPosCol;
   int iEnc=0;
   int klim[]={180,30,30};


   int stride=w*3;
   int iSendAsPic=iIsKey;

   if(!iDec && !iSendAsPic)ed->vlc.addB(0);


   int k;
   for(k=0;k<3;k++){
      if(iDec){
         
         if(iSendAsPic){
            ed->iPredDC=dc[k];
            if(iHada[k]) encMB16<iDec,1>(ed,pCur+k,pRef+k, stride,k,iIsB,0,iIsBigCost,0);
            else  encMB16_DCT<iDec,1>(ed,pCur+k,pRef+k, stride,k,iIsB,0,iIsBigCost,0);
            dc[k]=ed->iPredDC;
            continue;
         }
         
         if(ed->vlc.getB())continue;
         if(iIsB || ed->vlc.getB()){
            encMB16<iDec,0>(ed,pCur+k,pRef+k, stride,k,iIsB,0, iIsBigCost);
            continue;
         }
         
         ed->iPredDC=dc[k];
         if(iHada[k]) encMB16<iDec,1>(ed,pCur+k,pRef+k, stride,k,iIsB,0,iIsBigCost,0);
         else  encMB16_DCT<iDec,1>(ed,pCur+k,pRef+k, stride,k,iIsB,0,iIsBigCost,0);
         dc[k]=ed->iPredDC;
         iSendAsPic=1;
         
         continue;
      }
      else if(iSendAsPic){
         ed->iPredDC=dc[k];
         if(iHada[k])encMB16<iDec,1>(ed,pCur+k,pRef+k, stride,k,iIsB,0,iIsBigCost,0);
         else  encMB16_DCT<iDec,1>(ed,pCur+k,pRef+k, stride,k,iIsB,0,iIsBigCost,0);
         dc[k]=ed->iPredDC;
         iEnc++;
      }else{
         iBitPosCol=ed->vlc.iBitPos;
         ed->vlc.addB(0);
         if(!iIsB)ed->vlc.addB(1);
         int e=encMB16<iDec,0>(ed,pCur+k,pRef+k, stride,k,iIsB,1, iIsBigCost);

         if(e){
            iEnc++;
            int iDifBits=ed->vlc.iBitPos-iBitPosCol;
            if(!iIsB && iIsBigCost && klim[k]<iDifBits){
               int tmp=ed->vlc.iBitPos;
               ed->iPredDC=dc[k];
               if(iHada[k]) e=encMB16<iDec,1>(ed,pCur+k,pRef+k, stride,k,iIsB,0,iIsBigCost,((iDifBits*9)>>3)+(ed->iIsReferenceFrame?20:0));
               else  e=encMB16_DCT<iDec,1>(ed,pCur+k,pRef+k, stride,k,iIsB,0,iIsBigCost,iDifBits+(ed->iIsReferenceFrame?20:0));
               int iPicBits=ed->vlc.iBitPos-tmp;
               if(e>0){
                  dc[k]=ed->iPredDC;
                  ed->vlc.iBitPos=iBitPosCol+1;
                  ed->vlc.addB(0);
                  int z=0;
                  if(!k)debugss("bits-Y",iPicBits,iDifBits);
                  for(z=0;z<iPicBits;z++){ed->vlc.addB(ed->vlc.showBit(tmp));tmp++;}
                  iDifBits=iPicBits;
                  iSendAsPic=1;
               }
               else ed->vlc.iBitPos=tmp;
            }
         }
         else {
            ed->vlc.iBitPos=iBitPosCol;
            ed->vlc.addB(1);
         }
      }
   }

   if(!iDec && iEnc==0 && iSendAsPic==0){
      ed->vlc.iBitPos=iBitPos;
      ed->vlc.addB(1);
      return 0;
   }
   return 1;
}
#if 0
template <int iDec>
static int fastT_enc_dec2(TDCTX *ed, unsigned char *pCur, unsigned char *pRef,int w, int h,int  iIsB){
   /*
   T_ALIGN_64(DCT_TYPE,dct,64);
   T_ALIGN_64(DCT_TYPE,q_dct,64);
   T_ALIGN_64(DCT_TYPE,dct_p,64);
   T_ALIGN_64(DCT_TYPE,q_dct_p,64);
   */
//   int s;
   int stride=w*3;
   int i,j;//,xc,yc;
   int k,ofs;
//   int iCoefsOut,iMaxCoef;
   //xc=w/8;yc=h/8;
   //int sk=iDec?ed->vlc.getVlc():0;
   int iBitPos=ed->vlc.iBitPos;
   int iEnc=0;
   //static unsigned char *pRest=new unsigned char [16000];

   iResetCnt=1;
   int iEncTmp;
   int iIsBigCost;
   int iBitsGain=0;
   int iIsKey=ed->iIsKey;
   
   int iIsHada[]={0,0,0};

   int id=0;
   if(iDec){
      ed->iDCQuant=ed->vlc.getVlc();
      ed->iSkipId=ed->vlc.getVlc();
   }
   else{
      ed->iDCQuant=4;
      ed->vlc.toVLC(ed->iDCQuant);
      ed->vlc.toVLC(ed->iSkipId);

   }
   if(!iDec){
      while(ed->vlc.iBitPos&7)ed->vlc.addB(1);
   }
   else{
      ed->vlc.iBitPos+=7;ed->vlc.iBitPos>>=3;ed->vlc.iBitPos<<=3;//byteAlign
   }
   int iPosToEncodedCnt=ed->vlc.iBitPos;

   if(iDec){
      iEnc=ed->vlc.pBitBuf[iPosToEncodedCnt>>3]<<8;
      iEnc+=ed->vlc.pBitBuf[(iPosToEncodedCnt>>3)+1];
   }
   ed->vlc.iBitPos+=16;
   
   int iSkiped=0;
   int iPredDC[3]={0,0,0};

   if(iDec){
      iIsHada[0]=ed->vlc.getB();
      iIsHada[1]=ed->vlc.getB();
      iIsHada[2]=ed->vlc.getB();
   }
   else{
      ed->vlc.addB(iIsHada[0]);
      ed->vlc.addB(iIsHada[1]);
      ed->vlc.addB(iIsHada[2]);
   }

      ed->iPredDC=0;

      
   for(j=0;j<h-15;j+=16){
      ofs=j*stride;
      for(i=0;i<w-15;i+=16,ofs+=48,id++){
         if(iDec){
            if(id<ed->iSkipId)continue;
            if(!iIsKey && ed->vlc.getB())continue;
            enc_decMB_X<iDec>(ed,pCur+ofs, pRef+ofs, w,h, &iIsHada[0], &iPredDC[0]);
            iEnc--;
            if(iEnc==0){
               i=w;j=h;
               break;
            }
         }
         else{
            if(id<ed->iSkipId)  continue;

            if(ed->vlc.getBytePos()>900){
               i=w;j=h;
               ed->iSkipId=id;
               iSkiped=1;
               break;
            }
            int r=enc_decMB_X<iDec>(ed,pCur+ofs, pRef+ofs, w,h, &iIsHada[0], &iPredDC[0]);
            if(r)
               iEnc++;
         }
      }
   }
            
   
   if(!iDec && !iEnc){ed->vlc.iBitPos=iBitPos;ed->iSkipId=0;}
   if(!iDec){
      ed->vlc.pBitBuf[iPosToEncodedCnt>>3]=(iEnc>>8);
      ed->vlc.pBitBuf[(iPosToEncodedCnt>>3)+1]=iEnc-((iEnc>>8)<<8);
      debugss("enc",iEnc,(ed->vlc.iBitPos-iBitPos+7)>>3);
      if(iBitsGain>0)debugss("gain -----",(iBitsGain+7)>>3,0);
      if(!iSkiped && iEnc)ed->iSkipId=-1;;
      iBitsGain=0;
   }

   return ed->vlc.getBytePos();


}


#endif
int fastT_dec(TDCTX *ed, unsigned char *pCur, unsigned char *pRef,int w, int h,int  iIsB){
#ifdef _TEST_T_BITS
   return fastT_enc_dec_n<1>(ed, pCur, pRef, w,  h,  iIsB);
#else
   return fastT_enc_dec<1>(ed, pCur, pRef, w,  h,  iIsB);
#endif
}
int fastT_enc(TDCTX *ed, unsigned char *pCur, unsigned char *pRef,int w, int h,int  iIsB){
#ifdef _TEST_T_BITS
   return fastT_enc_dec_n<0>(ed, pCur, pRef, w,  h,  iIsB);
#else
   return fastT_enc_dec<0>(ed, pCur, pRef, w,  h,  iIsB);
#endif
}

int tt(unsigned char *pD, unsigned char *pCur, unsigned char *pRef,int w, int h,int q ,int iIsB){

   
   
   dctx->iIsB=iIsB;
   dctx->init(w,h,q, 0);
   dctx->vlc.reset();
   dctx->vlc.toAC(100);
   dctx->vlc.pBitBuf=pD;
   fastT_enc_dec<0>(dctx, pCur, pRef, w,  h,  iIsB);
   return dctx->vlc.getBytePos();
   
}

const int tM_TS[]={

//100,117,143


   7,10,8,10,
   10,12,11,12,
   8,11,8,11,
   10,12,11,12,

};
const int tM_TS_B[]={


   /*
   6,6,6,7,
   6,12,12,20,
   6,12,10,12,
   7,20,12,20,
   */
   7,9,8,9,
   9,11,15,16,
   8,15,12,15,
   9,16,15,20,
/*

   9,12,10,12,
   12,15,12,18,
   10,12,10,12,
   12,18,12,18,
   */
};
const int tM_POW[]={
   7,6,5,3,
   6,5,3,2,
   5,3,2,1,
   3,2,1,1,
};
const int tM_POW_B[]={
   6,4,3,1,
   4,3,1,0,
   3,1,0,0,
   1,0,0,0,
};

int encTestCanSkip8( unsigned char *pCur, unsigned char *pRef,int stride, int iIsB){
   if(!dctx)return 0;
   TDCTX *ed=dctx;
   T_ALIGN_64(int ,dct,16);
   void trHada(unsigned char *src,unsigned char *src2, int stride, int *d);
   const int *tabx=&ed->tab_y_b[0+iIsB*16];
   int t_ofs[]={
      0,4, 
      0+stride*4 ,4+stride*4,  
   };
   int i,j;
   const int *t_m=iIsB?&tM_TS_B[0]:&tM_TS[0];
#define MT(_V) (((tabx[_V]*t_m[_V])>>3)+4)
   const int tab[]={
      MT(0),MT(1),MT(2),MT(3),
      MT(4),MT(5),MT(6),MT(7),
      MT(8),MT(9),MT(10),MT(11),
      MT(12),MT(13),MT(14),MT(15),
   };
#undef MT

   

         
   int iNoSkip=0;
   for(i=0;i<4;i++){
      trHada(pRef+t_ofs[i],pCur+t_ofs[i],stride,dct);


      for(j=0;j<16;j++){
         int v=dct[j];
         if(v<0)v=-v;
         //if(v<(tab[j]*5)>>2)continue;
         if(v<tab[j])continue;
         if(v<11)continue;
        // if(v<(tab[j]))continue;
         return 300;
      }   
   }

   return 0;
}
int getDCQ(int iIsB){return dctx?dctx->tab_y_b[iIsB<<4]:(64<<iIsB);}
static const int oi[]={
   0,15,3,12,
   1,7,14,8,
   2,11,13,4,
   5,6,9,10,

   /*
   0,1,2,3,
   4,5,6,7,
   8,9,10,11,
   12,13,14,15,
   */
};


int encTestCanSkipF( unsigned char *pCur, unsigned char *pRef,int stride, int iIsB, int iResetTabs,  unsigned char *pRef2){
   if(!dctx)return 100;
   ///return 2001;

   TDCTX *ed=dctx;
   DECLARE_ALIGNED(int  dct[16],128);

//   T_ALIGN_64(int ,dct,16);
   void trHada(unsigned char *src,unsigned char *src2, int stride, int *d);
   const int *tabx=&ed->tab_y_b[0+iIsB*16];
   /*
   const int t_ofs[]={
      0,12+stride*12, 0+stride*12,12,
      4 ,4+stride*8,  8+stride*8 ,12+stride*8,
      0+stride*4 ,4+stride*4,  8+stride*4 ,12+stride*4,
      0+stride*8,4+stride*12, 8+stride*12,8,
   };
   */
   static const int Fsk[]={
      0,3,2,1,
      0,2,3,3,
      0,0,1,1,
      2,2,3,1,
   };
   int i,j;
   const int *t_m=iIsB?&tM_TS_B[0]:&tM_TS[0];
//   const int *t_p=iIsB?&tM_POW_B[0]:&tM_POW[0];
#define MT(_V) (((tabx[_V]*t_m[_V])>>3)+4)
//#define MT(_V) (((tabx[_V]*3)>>2)+4)
//#define MT(_V) (tabx[_V]+12)
//--   int dc0Sk=((tabx[0]*(3-(!!iIsB))+4)>>2)+((!!iIsB)*20);
      static int dc0Sk=((ed->tab_y_b[0]*(6+(2)*(!!iIsB))+8)>>3)+((!!iIsB)*20);
   //int dc0Sk=((tabx[0]*(7-(!!iIsB)*3)+8)>>3)+((!!iIsB)*20);
             //(iIsB)?(((tabx[0]*3)>>2)+16):((tabx[0]>>1)+12);//max(tabx[0]>>1,20);
   //http://home.comcast.net/~fbui/intel_a.html#fabs
   static int tab[]={
     // ((tabx[0]+16)>>1),MT(1),MT(2),MT(3),
       //MT(0)
      dc0Sk,MT(1),MT(2),MT(3),
      MT(4),MT(5),MT(6),MT(7),
      MT(8),MT(9),MT(10),MT(11),
      MT(12),MT(13),MT(14),MT(15),
   };
   static int tab_b_ref2[16];
   static int tab_m2_ref2[16];
   if(iResetTabs){
      dc0Sk=((ed->tab_y_b[0]*(5+(3)*(!!iIsB))+8)>>3)+(iIsB?24:8);
//      if(dc0Sk>192+(!!iIsB)*96)dc0Sk=192+(!!iIsB)*96;
      if(dc0Sk>128+(!!iIsB)*32)dc0Sk=128+(!!iIsB)*32;
      static const int mt[]={
         8,11,8,11,
         11,25,11,25,
         8,11,8,11,
         11,25,11,25,
      };
      tab[0]=dc0Sk;
      for(i=1;i<16;i++){
         tab[i]=MT(i);        
         
        // tab[i]
         if(iIsB){
            //--tab[i]+=(ed->tab_y_b[i]>>1);
            tab[i]=(ed->tab_y_b[i]<<1);
            if(tab[i]<tabx[i])tab[i]=tabx[i];
         }
         else{
            if(tab[i]<mt[i])tab[i]=mt[i];
         }
         tab_b_ref2[i]=ed->tab_y_b[i]*3;//tabx[i]*2;//+(ed->tab_y_b[i]>>1);
         if(tab_b_ref2[i]<tabx[i]+8)tab_b_ref2[i]=tabx[i]+8;
         //if(iIsB)tab[i]*=4;
      }
      tab_b_ref2[0]=(tab[0]*3)>>1;
      if(tab_b_ref2[0]<20)tab_b_ref2[0]=20;
     // if(tab[0]<mt[0]+iIsB*4)tab[0]=mt[0]+iIsB*4;
      for(i=0;i<16;i++){
         tab_b_ref2[i]*=2;tab_b_ref2[i]+5;
         tab_m2_ref2[i]=tab[i]*2+5;
      }
      
   }
#undef MT
   void trHada2r(unsigned char *src,unsigned char *src2,unsigned char *src3, int stride, int *d);

  // int iDCF=0;
   int ret=0;
   int iHT=0;
   //const int iHada1=max(16,(tabx[0]));
   //int fskC[]={0,0,0,0,};
   int idc=0;
#define TEST_SK_DC 0
   int dcc[16];
   for(i=0;i<16;i++){
      const int ii=oi[i];
      int of=stride*((ii>>2)<<2)+((ii&3)<<2);//t_ofs[i]
      if(pRef2){
         trHada2r(pCur+of,pRef+of,pRef2+of,stride,dct);
      }else{ 
         trHada(pCur+of,pRef+of,stride,dct);
      }
#if TEST_SK_DC
         dcc[i]=dct[0];
#endif
      if(pRef2 && iIsB){
         for(j=TEST_SK_DC;j<16;j++){
            int v=abs(dct[j]);
            if(v<tab_b_ref2[j]){continue;}
            return 300;
         }
      } else if(pRef2){
         for(j=TEST_SK_DC;j<16;j++){
            int v=abs(dct[j]);
            if(v<tab_m2_ref2[j]){continue;}
            return 300;
         }
      }else{
//   int j0_dcl=max(((tab[0]*(5+(!!pRef2)))>>2),20+(!!iIsB)*8);
  // j0_dcl=min(j0_dcl,96+(!!iIsB +!!pRef2)*32); 

         for(j=TEST_SK_DC;j<16;j++){
            int v=abs(dct[j]);
            //         if(v<0)v=-v;
            // int s=v>>31;v^=s;
            if(v<tab[j]){continue;}
            //if(j==0 && idc<3 && v<j0_dcl){idc++;continue;}
#if !TEST_SK_DC
           //  if(j==0 && idc<3 && v<j0_dcl){idc++;continue;}
#endif
            return 300;
         }
      }
//TODO
      /*
static tab[0]|(tab[1]<<16)|(tab[1]<<32)|(tab[2]<<48)....
__m128i _mm_cmpgt_epi16 (__m128i a, __m128i b);
r0 := (a0 > b0) ? 0xffff : 0x0
r1 := (a1 > b1) ? 0xffff : 0x0
...
r7 := (a7 > b7) ? 0xffff : 0x0
//abs_shortX8,abs_shortX8
//cmp_shortX8,abs_shortX8
//if(res)return 300;
         */
   }
#if TEST_SK_DC
   void fdct4x4dc_s( int *d);
   fdct4x4dc_s(&dcc[0]);
   const int dcL=tab[0]*2;//j0_dcl*2;
   for(j=0;j<16;j++){
      int v=abs(dcc[j]);
      if(v>j0_dcl)return 300;
   }
#endif
   //if(!iDCF)return 0;
   //if(iDCF)debugss("fc=dct",iDCF,iIsB);

   return ret;
}

int encTestCanSkip( unsigned char *pCur, unsigned char *pRef,int stride, int iIsB){
   if(!dctx)return 100;
   ///return 2001;
   TDCTX *ed=dctx;
   T_ALIGN_64(int ,dct,16);
   void trHada(unsigned char *src,unsigned char *src2, int stride, int *d);
   const int *tabx=&ed->tab_y_b[0+iIsB*16];
   /*
   const int t_ofs[]={
      0,12+stride*12, 0+stride*12,12,
      4 ,4+stride*8,  8+stride*8 ,12+stride*8,
      0+stride*4 ,4+stride*4,  8+stride*4 ,12+stride*4,
      0+stride*8,4+stride*12, 8+stride*12,8,
   };
   */
   int i,j;
   const int *t_m=iIsB?&tM_TS_B[0]:&tM_TS[0];
//   const int *t_p=iIsB?&tM_POW_B[0]:&tM_POW[0];
#define MT(_V) (((tabx[_V]*t_m[_V])>>3)+4)
   int dc0Sk=(iIsB)?(tabx[0]+8):((tabx[0]>>1)+12);//max(tabx[0]>>1,20);
   
   const int tab[]={
     // ((tabx[0]+16)>>1),MT(1),MT(2),MT(3),
       //MT(0)
      dc0Sk,MT(1),MT(2),MT(3),
      MT(4),MT(5),MT(6),MT(7),
      MT(8),MT(9),MT(10),MT(11),
      MT(12),MT(13),MT(14),MT(15),
   };
#undef MT

   int iDCF=0;
int iCoefs=0;
   const int iHada1=tabx[0]+16;//max(32,(tabx[0]*2));
   
   int iNoSkip=0;
   for(i=0;i<16;i++){
      const int ii=oi[i];
      int of=stride*((ii>>2)<<2)+((ii&3)<<2);//t_ofs[i]
      trHada(pRef+of,pCur+of,stride,dct);


      for(j=0;j<16;j++){
         int v=dct[j];
         if(v<0)v=-v;
         //if(v<(tab[j]*5)>>2)continue;
         if(v<tab[j]){
           // if(v>=tabx[j]){iCoefs++;if(iCoefs>2)return 100;}
            continue;
         }
         if(v<12)continue;

         if(!j){
           iDCF++;
           //--if(v<tabx[0]*2)continue;
           if(v<iHada1)continue;
           //if(v<32)continue;
         }
        // if(v<(tab[j]))continue;
         return 300;
      }
   }
   //if(iDCF)debugss("fc=dct",iDCF,iIsB);

   return iDCF?1:0;
}
int encTestCanSkipBl( short *block,int stride, int iIsB){
   if(!dctx)return 100;
   TDCTX *ed=dctx;
   T_ALIGN_64(int ,dct,16);
   const int *tabx=&ed->tab_y_b[0+iIsB*16];
   
   /*
   const int t_ofs[]={
      0,0+stride*12, 12+stride*12,12,
      4 ,4+stride*8,  8+stride*8 ,12+stride*8,
      0+stride*4 ,4+stride*4,  8+stride*4 ,12+stride*4,
      0+stride*8,4+stride*12, 8+stride*12,8,
   };
*/
   int i,j;
   const int *t_m=iIsB?&tM_TS_B[0]:&tM_TS[0];
//   const int *t_p=iIsB?&tM_POW_B[0]:&tM_POW[0];
#define MT(_V) (((tabx[_V]*t_m[_V])>>3)+8)
   const int tab[]={
      MT(0),MT(1),MT(2),MT(3),
      MT(4),MT(5),MT(6),MT(7),
      MT(8),MT(9),MT(10),MT(11),
      MT(12),MT(13),MT(14),MT(15),
   };
#undef MT


         
//   int iNoSkip=0;
   for(i=0;i<16;i++){
      const int ii=oi[i];
      int of=stride*((ii>>2)<<2)+((ii&3)<<2);//t_ofs[i]
//      trHada(pRef+of,pCur+of,stride,dct);
    void trHadaBL(short *bl, int stride, int *d);
      
    //  trHadaBL(&block[t_ofs[i]],16,dct);
      trHadaBL(&block[of],16,dct);


      for(j=0;j<16;j++){
         int v=abs(dct[j]);
         if(v<tab[j])continue;
         return 300;
      }
   }

   return 0;
}

//void (*calcChanel_fnc)(short *bl, int sz)=calcChanel;
#if defined(_WIN32 ) && !defined(_WIN32_WCE)
static int cntACCoefs02(unsigned char *pCur, unsigned char *pRef, int w, int h,TDCTX *ed, int b, int &iHadaSkCntProc)
{
   iHadaSkCntProc=0;
   int i,j,z;
   int iCnt=0;
   DCT_TYPE dct[64];
   const int stride=w*3;
   void t_fdct8_s_d(unsigned char *src,unsigned char *src2, int stride, DCT_TYPE *d );
   void t_fdct8_s(unsigned char *src, int stride, DCT_TYPE *d );;

   static unsigned char *ac1=new unsigned char[4096*2*2];
   unsigned char *acOfs1=ac1+4096*2;
   static unsigned char *ac2=new unsigned char[4096*2*2];
   unsigned char *acOfs2=ac2+4096*2;
   static unsigned char *ac3=new unsigned char[4096*2*2];
   unsigned char *acOfs3=ac3+4096*2;

   const int q0=ed->tab_y_b[0];
   const int bias=q0+200;//b==2?100:500;
   static int iInitOk=0;
   if(!iInitOk){
      for(i=0;i<4095*2;i++){
#if 1
         /*
         acOfs1[i]=acOfs1[-i]=ed->vlc.bitsLenAC[(i+2)>>3]-1;
         acOfs2[i]=acOfs2[-i]=ed->vlc.bitsLenAC[(i+3)>>4]-1;
         acOfs3[i]=acOfs3[-i]=ed->vlc.bitsLenAC[i>46?((i-20)>>5):0]-1;
         */
//         acOfs1[i]=acOfs1[-i]=ed->vlc.bitsLenAC[(i+4)>>3]+ed->vlc.bitsLenAC[(i+2)>>2]-2;
  //       acOfs2[i]=acOfs2[-i]=ed->vlc.bitsLenAC[(i+16)>>5]+ed->vlc.bitsLenAC[(i+12)>>7]-2;
    //     acOfs3[i]=acOfs3[-i]=ed->vlc.bitsLenAC[(i+32)>>6];//+ed->vlc.bitsLenAC[(i>>8)]-2;
         acOfs1[i]=acOfs1[-i]=ed->vlc.bitsLenAC[i/9];
         acOfs2[i]=acOfs2[-i]=ed->vlc.bitsLenAC[i/21];
         acOfs3[i]=acOfs3[-i]=ed->vlc.bitsLenAC[i/46];//+ed->vlc.bitsLenAC[(i>>8)]-2;
#else
         
         acOfs1[i]=acOfs1[-i]=ed->vlc.bitsLenAC[(i+4)>>4]-1;
         acOfs2[i]=acOfs2[-i]=ed->vlc.bitsLenAC[(i+12)>>5]-1;
         acOfs3[i]=acOfs3[-i]=ed->vlc.bitsLenAC[i>46?((i)>>6):0]-1;
#endif
      }
      iInitOk=1;
   }
   //1,2,1,2,
   //2,3,2,3,
   const int xc=w>>4;
   int iHadaSkipCnt=0;
   int iBlocks=0;
   int iDev=0;
   int dcPred=0;
   int iDevSum=0;
   int iKeyCnt=0;
   for(j=4;j<h-8;j+=16){
      int iCntR=0;
      for(i=4;i<w-8;i+=16){
         iCntR=0;
         iBlocks++;
         int ofs=stride*j+i*3;
         int id=(j>>4)*xc+(i>>4);
         int iPic=0;
         if(b>=3){
            iPic=2;
            mst[id].iHada=-1;
            t_fdct8_s(pRef+ofs,stride,&dct[0]);
         }
         else{
#ifndef _T_DIS_DBG
            int iSad=mst[id].iSad;
            iDev=mst[id].iDev;
         
            if(b!=2 && (!mst[id].iHada || iSad*8<q0)){iHadaSkipCnt++;iDevSum+=(iDev>>4);continue;}
            
            if(mst[id].iHada<0 && iSad>mst[id].iMinPosSad && (iSad>iDev+bias || iSad>mst[id].iMinPosSad*2+bias+200) ){
                 iPic=2;
            iDevSum+=iDev;
                // iKeyCnt++;
   //              iDevSum+=iDev;
               t_fdct8_s(pRef+ofs,stride,&dct[0]);
            }
            else 
#endif
            {
               iDevSum+=iDev>>1;

               t_fdct8_s_d(pRef+ofs,pCur+ofs,stride,&dct[0]);
            }
         }
         if(mst[id].iHada==1){
               iCntR+=acOfs1[dct[0]];
               iCntR+=acOfs1[dct[16]];
               iCntR+=acOfs1[dct[32]];
               iCntR+=acOfs1[dct[48]];
         }
         else{
      //      int dcA=(dct[0]+dct[16]+dct[32]+dct[48]+2)>>2;
            if(iPic){
               int dcA=(dct[0]+dct[16]+dct[32]+dct[48]+2)>>2;
                //dct[0]=dct[16]=dct[32]=dct[48]=0;iCntR+=20;
                dct[0]-=dcPred;dct[16]-=dcPred;dct[32]-=dcPred;dct[48]-=dcPred;dcPred=dcA;
            }
        //    

            for(z=0;z<64;z+=8){
               iCntR+=acOfs3[dct[z+5]];
               iCntR+=acOfs3[dct[z+7]];
               iCntR+=acOfs2[dct[z+1]];
               iCntR+=acOfs2[dct[z+3]];
               iCntR+=acOfs2[dct[z+4]];
               iCntR+=acOfs2[dct[z+6]];

               iCntR+=acOfs1[dct[z+2]];
               iCntR+=acOfs1[dct[z+0]];//>>iPic;


            }
            //if(iCntR<64+(q0>>2))iCntR>>=(1);
  //          iCnt+=(iDev>>4);
         }
         iCnt+=iCntR;//if(iPic)iCnt+=(iCntR>>4);
      }
      
   }
   //iKeyCnt
//   if(b<3)iCnt+=(iDevSum>>3)/(iKeyCnt+1);//(iCnt*3+(iDevSum>>5))>>2;}
   if(b<3){iCnt=(iCnt*3+(iDevSum>>5))>>2;}
//   if(b<3){iCnt=(iCnt*3+(iDevSum>>5))>>2;}
   int iAvgSize=iCnt/(iBlocks-iHadaSkipCnt+1);iCnt+=iHadaSkipCnt*(1+(iAvgSize>>6));
   iHadaSkCntProc=iHadaSkipCnt*16/iBlocks;
   iCnt+=iBlocks;
  // delete ac;
   return iCnt+1;
}

#else
static int cntACCoefs02(unsigned char *pCur, unsigned char *pRef, int w, int h,TDCTX *ed, int b, int &iHadaSkCntProc){return 0;}
void sleepAfterKey(int k){}
#endif
typedef struct{
   enum{RC_key,RC_dif};
   double iPrevQ;
   int iPrevPredSZ;
   int iPrevRealSizeNeed;
   int iPrevRealSize;
   int iPrevRealSizeUV;
   int qLimitMax;
   int qLimitMin;
}RC;

static RC rcStruct[4];
int rc(unsigned char *pCur, unsigned char *pRef, int w, int h,int sz, int b=3){
   
   int id=b>=3?RC::RC_key:RC::RC_dif;
   int q=16;
if(sz<=1){
   rcStruct[id+2].iPrevPredSZ*=2;rcStruct[id+2].iPrevPredSZ/=3;
   rcStruct[id+2].iPrevRealSize*=2;rcStruct[id+2].iPrevRealSize/=3;

   q=rcStruct[id].iPrevQ-2;
   rcStruct[id].iPrevQ=q;
   if(q<0)q=0;
   return q;
}
int iHadaSkCnt=0;
   int iCoefCntX=cntACCoefs02(pCur, pRef,  w,  h,dctx,b, iHadaSkCnt);//-(w*h>>6);
   int iCoefX=iCoefCntX;
   static int i_PrevRes[2]={12,14};
   int &iPrevRes=i_PrevRes[id];
   static int iInitOK[2]={0,0};
 //  sz=(RC::RC_key==id)?3000:1000;
   if(iInitOK[id] && (rcStruct[id+2].iPrevRealSize>((w*h)>>10) || rcStruct[id].iPrevRealSize>((w*h)>>10))){
      static int iPrevIsKey=0;
      q=rcStruct[id].iPrevQ;
      if(iPrevIsKey){q*=3;q+=rcStruct[RC::RC_key].iPrevQ;q>>=2;}
      double di;
      if(rcStruct[id].iPrevRealSize>((w*h)>>8) && rcStruct[id].iPrevPredSZ){
         if(rcStruct[id].iPrevPredSZ && rcStruct[id].iPrevRealSize){
      //      di=((double)(rcStruct[id].iPrevPredSZ+rcStruct[id+2].iPrevPredSZ))/(double)((rcStruct[id].iPrevRealSize+rcStruct[id+2].iPrevRealSize));
            rcStruct[id+2].iPrevQ*=3;
            rcStruct[id+2].iPrevQ+=rcStruct[id].iPrevQ+0.5;
            rcStruct[id+2].iPrevQ/=4;

            rcStruct[id+2].iPrevPredSZ*=3;
            rcStruct[id+2].iPrevPredSZ+=rcStruct[id].iPrevPredSZ;
            rcStruct[id+2].iPrevPredSZ>>=2;
            rcStruct[id+2].iPrevRealSize*=3;
            rcStruct[id+2].iPrevRealSize+=rcStruct[id].iPrevRealSize;
            rcStruct[id+2].iPrevRealSize>>=2;
           // q=((double)rcStruct[id].iPrevQ+0.5+rcStruct[id+2].iPrevQ)/2;
         }
         else {
            rcStruct[id+2].iPrevQ=rcStruct[id].iPrevQ;
            rcStruct[id+2].iPrevPredSZ=rcStruct[id].iPrevPredSZ; 
            rcStruct[id+2].iPrevRealSize=rcStruct[id].iPrevRealSize;
        //    di=((double)(rcStruct[id].iPrevPredSZ+rcStruct[id+2].iPrevPredSZ))/(double)((rcStruct[id].iPrevRealSize+rcStruct[id+2].iPrevRealSize));
         }
         di=(double)rcStruct[id].iPrevPredSZ/(double)((rcStruct[id].iPrevRealSize));
      }
      else
      {
         q=rcStruct[id+2].iPrevQ;
         if(!rcStruct[id+2].iPrevRealSize){
            if(id==RC::RC_key){
               q=10;
               di=10;//(double)(176*144)/(double)(19760);
            }
            else{
               q=12;
               di=16;//(double)(176*144)/(double)(19760);
            }
         }
         else di=(double)rcStruct[id+2].iPrevPredSZ/(double)((rcStruct[id+2].iPrevRealSize));
      }
int qs=q;
      {

         iCoefX/=di;
         if(iCoefX<1)iCoefX=1;
/*
         if(iCoefX>sz*1.18){
            while(iCoefX>sz*1.90 && q>4){
               q-=4;iCoefX>>=1;
            }
            while(iCoefX>sz*1.18 && q>-1){
               q--;iCoefX/=1.16;
            }
         }
         else if(sz>iCoefX*1.25){
            while(sz>iCoefX*1.90  && q<35){
               q+=4;iCoefX<<=1;
            }
            while(sz>iCoefX*1.25 && q<39){
               q++;iCoefX*=1.2;
            }
         }
         */
         if(iCoefX>sz*1.18){
            while(iCoefX>sz*1.90 && q>5){
               q-=5;iCoefX>>=1;
            }
            while(iCoefX>sz*1.15 && q>-1){
               q--;iCoefX/=1.15;
            }
         }
         else if(sz>iCoefX*1.2){
            while(sz>iCoefX*1.90  && q<35){
               q+=5;iCoefX<<=1;
            }
            while(sz>iCoefX*1.15 && q<39){
               q++;iCoefX*=1.15;
            }
         }
      }
      if(b==0){
         static int iHadSkipCntPrev;
         if(q>qs && iHadaSkCnt>3){
            if(iHadSkipCntPrev<iHadaSkCnt+2){
            int qx=q;
            //iHadaSkCnt+=8;
            q=(qs*(iHadaSkCnt+8)+q*(16-iHadaSkCnt+8)+16)>>5;
            //if(qx!=q)debugsi("qn",qx-q);
            }
         }
         iHadSkipCntPrev=iHadaSkCnt;
         //q*=iHadaSkCnt
      }
      if(q>rcStruct[id].qLimitMax)q=rcStruct[id].qLimitMax+1;
      if(q<rcStruct[id].qLimitMin)q=rcStruct[id].qLimitMin-1;

      if(q<-2)q=-2;else if(q>40)q=40;
      //------------if(q<10)q=10;else if (q>18)q=18;
      //else q=q*sz/(iCoefX);

      iPrevIsKey=id==RC::RC_key;
   rcStruct[id].iPrevPredSZ=iCoefCntX;
   rcStruct[id].iPrevQ=q;
   rcStruct[id].iPrevRealSizeNeed=sz;
  // debugss("q=",q,iCoefCntX);
         //debugsi("q",q);debugsi("co",iCoefCntX);
return q;

   }else{
      rcStruct[id].qLimitMax=18;
      rcStruct[id].qLimitMin=5;

      //sz=5000;
      /*
         q=16;
         double di=5;//(double)(176*144)/(double)(19760);
         q*=sz;
         iCoefX/=di;
         if(iCoefX<1)iCoefX=1;
         q/=iCoefX;
*/

         double di;
         if(id==RC::RC_key){
            q=10;//8;//iIsUDP?6:10;
            di=10;//12;//(double)(176*144)/(double)(19760);
         }
         else{
            q=12;//9;
            di=16;//15;//(double)(176*144)/(double)(19760);
         }
         iCoefX/=di;

         if(iCoefX>sz*1.25){
            while(iCoefX>sz*1.90 && q>4){
               q-=5;iCoefX>>=1;
            }
            while(iCoefX>sz*1.2 && q>-1){
               q--;iCoefX/=1.16;
            }
         }
         else if(sz>iCoefX*1.25){
            while(sz>iCoefX*1.90  && q<35){
               q+=5;iCoefX<<=1;
            }
            while(sz>iCoefX*1.2 && q<39){
               q++;iCoefX*=1.16;
            }
         }
     

         if(q>20)q=20;

        // if(iInitOK[id]==0)q=10;
         iInitOK[id]=1;
         rcStruct[id].iPrevRealSizeUV=0;
         rcStruct[id].iPrevRealSize=0;
   
   }
   //q++;
/*
   //iCoefCntX/=4;  q=18;
   if(iCoefX<1)iCoefX=1;
   double d=((double)sz)/((double)((iCoefX)+1));//18;//int q=21;
   if(d<0.01)d=0.01;
   //if(d>2)d=2;
   if(d<0.88){
     // d=rr[(int)(d*26)]-q;
      //d=-(1/(d));q+=(int)(d);
      d=-((1/(d))-1)*2;q+=(int)(d+0.5);
     // q=rr[(int)(d*(-1+sizeof(rr)/sizeof(int)))];
   }else if(d>6)q+=8;else if(d>1.15){q+=(int)(1.5*(d-1)+0.5);}
  */


   //debugss("q=",q,iCoefCntX);
   rcStruct[id].iPrevPredSZ=iCoefCntX;
   rcStruct[id].iPrevQ=q;
   rcStruct[id].iPrevRealSizeNeed=sz;
//   rcStruct[id].iPrevRealSizeUV=sz

iPrevRes=q;
  // return (int)(32+d+0.5);
   return q;
}

int decodeDctX2N(unsigned char *pBin, int iLen, unsigned char *pCur, int iIsB, int iKey, int w, int h, int iFilter){

   if(dctDec==NULL)dctDec=new TDCTX();
   if(dctDec==NULL){
      memcpy(pCur,pBin,iLen);
      return 0;
   }
   //iKey=1;iIsB=0;
   //iIsB=0;
   dctDec->iThisWasB=iIsB && !iKey;

#ifdef _TEST_T_BITS
   dctDec->iFilter=iFilter;
   dctDec->iIsKey=iKey;

//   dctDec->w=w;
  // dctDec->w=h;
   int q=10;
   dctDec->init(w,h,q,1);
   dctDec->vlc.reset();
   dctDec->vlc.pBitBuf=(unsigned char *)&pBin[0];
#if !defined(__SYMBIAN32__) && !defined(_WIN32_WCE) && !defined(ARM) && !defined(ANDROID_NDK) && !defined(__APPLE__)
   dctDec->iVisDecoder=*(int*)pCur==0xaa99aa99;
   dctDec->iSkipPutBlocks=*(int*)pCur==0xaa88aa99;
#endif
 //rci();

   int l=fastT_dec(dctDec,pCur,NULL,w,h, iIsB && !iKey);

   //int mainzz(unsigned char *r, int SIZE, unsigned char *b);
   /*
   unsigned char bbbt[128000];
   int l2=mainzz(dctDec->vlc.pBitBuf,iLen*8,&bbbt[0]);

//int iEncBits=rce()*8;iBitGainX1sc-=iEncBits;
debugsi("aao",iLen);
debugsi("aan",l2);
*/
#else
   
   int l=dctDec->decode(pBin,iLen,pCur);
#endif
   return l;
}


int getQUV(int b, TDCTX *d){
   int qpm=d->iQParam;
   if(qpm>d->iMaxQParam){qpm=(qpm*3+d->iMaxQParam)>>2;}

   if(b==2){qpm+=8;}

   if(qpm>39)qpm=39;
   if(qpm<0)qpm=0;
      static const int qTabsb0[]={
         4,8,12,16,20,
         24,28,28,32,32,
         36,36,40,40,44,
         48,48,52,52,56,
         56,60,64,64,68,
         68,72,72,76,80,
         80,84,84,88,88,
         88,92,92,92,96,
      };

   return qTabsb0[qpm];
}
static int iMaxQval=22;
static int iMinQval=3;
void setMinMaxQval(int mi, int ma){
   iMaxQval=ma;
   iMinQval=mi;
}

static int iBytesEncoded=0;//
static int iLastVecSize=50;
void setLastFrameSize(int iL){iBytesEncoded+=iL;}
void setLastVecSize(int iL){iLastVecSize=iL;}
static int iVideoKbps=0;
static int iResetKBPS=0;
void setVideoKbps(int l){if(l!=iVideoKbps)iResetKBPS=1;iVideoKbps=l;}
int testDctX2K(unsigned char *pCur, unsigned char *pRef, int w, int h, int q, unsigned char *pOut,int b=3){

   //b=3;
  // if(b!=1)b=3;//351,938
//if(b==1)b=0;
   //b=4;
   
   static int iFramesAfterKey=8;
   if(dctx==NULL)dctx=new TDCTX();
   dctx->iPartLimitSize=iIsUDP?(w*h>640*480?(dctx->iIsKey?20000:8000):850):50000;//850;
   memset(pOut,0,dctx->iPartLimitSize+200);
   setStatSZ(w,h,-1);

   if(iLastFrameDif>50 && b==2){b=0;dctx->iIsReferenceFrame=0;}

   dctx->iIsKey=b==3 || b==4;
   dctx->iIsReferenceFrame=b==2;dctx->iIsB=b==1;
   dctx->iMaxQParam=(iIsUDP?20:24); // *TI_Q_MAX/36;

//   q=(q*10)/27;
   int str=1;
//--
#if 1
#define _FR_CNT 12
//#define _FR_CNT 300
   //120
   //5014
   //5015
   int szR=(90*(w+h)/(320+240))/3;
//#define T_GAIN_FIX 48
#define T_GAIN_FIX 0
#else
#define _FR_CNT 300
   int szR=(90*(w+h)/(320+240))/3;
#define T_GAIN_FIX 0
   str=0;
   iVideoKbps=0;
#endif
//   int iBytesNeeded=iVideoKbps?((3*iVideoKbps*1137/3)>>3):((str?szR:18000)*1024);//_FR_CNT*iAvgFrSize;//(_FR_CNT)*iAvgFrSize;//4000;
//   int iBytesNeeded=1024*200;//_FR_CNT*iAvgFrSize;//(_FR_CNT)*iAvgFrSize;//4000;
int fps=30;
   //---
   int iBytesNeeded=iVideoKbps?(((1024+T_GAIN_FIX)*_FR_CNT*iVideoKbps/fps)>>3):((str?(szR*1024):90259));//_FR_CNT*iAvgFrSize;//(_FR_CNT)*iAvgFrSize;//4000;
   int iAvgFrSize=iBytesNeeded/_FR_CNT;
   static int iBytes=0;
   iBytes=iBytesEncoded;
   static int iFramesLeft=_FR_CNT;
//stream   
   if(str){
      if(dctx->iSkipId==0 && ((b!=1 && iFramesLeft<=((_FR_CNT>>2)&~1)) || iFramesAfterKey==4 || iResetKBPS)){
         int e=iBytesEncoded-iAvgFrSize*(_FR_CNT-iFramesLeft);
         iFramesLeft=_FR_CNT;
         static int iPrevE[4]={0,0,0,0};
         if(iResetKBPS){
            e=0;
            iPrevE[3]=iPrevE[2]=iPrevE[1]=iPrevE[0]=0;
            iResetKBPS=0;
         }
#if 0
         iBytesEncoded=iBytes=iLastVecSize+(e>>3)+(iPrevE[0]>>3)+(iPrevE[1]>>4)+(iPrevE[2]>>5)+(iPrevE[3]>>6);
         iPrevE[3]=iPrevE[2];
         iPrevE[2]=iPrevE[1];
         iPrevE[1]=iPrevE[0];
         iPrevE[0]=e;
#else
         iBytesEncoded=iBytes=iLastVecSize+(e>>3)+(iPrevE[0]>>3);
         iPrevE[0]-=(iPrevE[0]>>3);
         iPrevE[0]+=(e-(e>>3));
#endif
      }
   }
   else{
      if(iFramesLeft<8)iBytesNeeded+=iAvgFrSize*2+512;
      if(iFramesLeft<4)iBytesNeeded+=iAvgFrSize*4+2048;
   }
   if(!iFramesLeft)return 0;


   static int iPrevQ=12;
   

   //if()
   int szReq=((iBytesNeeded-iBytes)/(iFramesLeft));//*(b>1?4:1);
//   szReq*=3;szReq+=iAvgFrSize;szReq>>=2;

   //if(iFramesLeft<4 && szReq<iAvgFrSize)szReq=iAvgFrSize;
   int szReqd5=(szReq*2)/10;// *2/10;//11 delj key
if(b>2)iLastVecSize=0;
static int prevIsB=1;
//1 
   static int iFramesAfterB;
   int kmult=(::iIsUDP?3:8);
   if(iFramesAfterB<5){
//      if(b==0){if(prevIsB){szReq=szReqd5*9;szReq-=(szReqd5>>3);}}   else if(b==1){szReq=szReqd5;}
      if(b==0){if(prevIsB){szReq=(szReq*2)-(szReq>>2);szReq-=(szReqd5>>3);}}else if(b==1){szReq=szReq>>2;}//
      else if(b>2 &&  iFramesAfterKey>6){
         if(iAvgFrSize<szReq)szReq=iAvgFrSize*kmult;
         else szReq*=kmult;
         //szReq=rcStruct[kid].iPrevRealSize*
      }
      else if(b>2 && iFramesAfterKey<3)szReq*=3;else szReq*=4;
   }
   else{
      if(b==0){szReq-=(szReqd5>>4);}else  if(b>2 &&  iFramesAfterKey>6)szReq*=kmult;else if(b>2 && iFramesAfterKey<3)szReq*=3;else szReq*=4;
   }
   if(b==0 && szReq*2>iAvgFrSize*5)szReq=iAvgFrSize*5/2;//if has b
   else if(b>2 && szReq>iAvgFrSize*kmult && iFramesAfterKey>8){
      szReq=iAvgFrSize*kmult;
   }
   if(b==0 && szReq*3<iAvgFrSize*2)szReq=iAvgFrSize*2/3;
   if(b>3 && szReq*6>w*h)szReq=w*h/6;


   szReq-=(iLastVecSize+rcStruct[b>2?RC::RC_key:RC::RC_dif].iPrevRealSizeUV);
   dctx->iFramesAfterKey=iFramesAfterKey;
   static int iFramesAfterRef=0;
   if(dctx->iSkipId==0){
      if(b==0 )iFramesAfterRef++;
      else if(b>=2 && iFramesAfterRef>1){iFramesAfterRef=0;}
      if(b==1)iFramesAfterB=0;else iFramesAfterB++;
   }
   
//szReq=6000;
#if 1
   //ndef T_CAN_TEST_V
   dctx->iQParam=iPrevQ;
   if(dctx->iSkipId==0 && (b!=1 && b!=2)){

      int iFramesAfterRefLim=iFramesAfterRef;//+(_FR_CNT+iFramesLeft)/2;
      if(iFramesAfterRefLim>_FR_CNT)iFramesAfterRefLim=_FR_CNT;
      iFramesAfterRefLim=_FR_CNT-iFramesAfterRefLim;
      iFramesAfterRefLim*=3; iFramesAfterRefLim+=iFramesLeft;iFramesAfterRefLim>>=2;

    //  debugsi("szReq",szReq);

      iFramesAfterRefLim-=_FR_CNT/2+2;
      if(iFramesAfterRef>70)iFramesAfterRefLim>>=2;
      else if(iFramesAfterRef>50)iFramesAfterRefLim>>=1;
      

      szReq*=(_FR_CNT*3+iFramesAfterRefLim);szReq/=(_FR_CNT*3-iFramesAfterRefLim);
      if(szReq>0 && iFramesLeft>(_FR_CNT>>1)&& b==0 && iFramesAfterRef<(_FR_CNT>>2)){szReq+=iAvgFrSize*3;szReq>>=2;}
      
      /*
   void debugsi(char *c, int a);
   if(dctx->iSkipId==0){
debugsi("av1",iAvgFrSize);
debugsi("av2",szReq);
   }
*/
   //   szReq=(iAvgFrSize+(iBytesNeeded-iBytes)/(iFramesLeft))>>1;if(b>=3)szReq*=5;\
   szReq-=(iLastVecSize+rcStruct[b>2?RC::RC_key:RC::RC_dif].iPrevRealSizeUV);
      //debugsi("szReq",szReq);
//szReq=1600;
      if(szReq*2<iAvgFrSize)szReq=iAvgFrSize>>1;
//---      int qn=rc(pCur,pRef,w,h,szReq-(b>2?0:(szReq*((iFramesAfterRef<20)?iFramesAfterRef:20)/200)),b);
      //szReq=b>2?4000:2000;
      //szReq=4000;
      int qn=rc(pCur,pRef,w,h,szReq,b);
      dctx->iAvgBlockBits=szReq*8/((w*h)>>8);
      dctx->iReqBits=szReq*7;
    //  debugsi("ed->iAvgBlockBits",dctx->iAvgBlockBits);

   if(b>3 && iFramesAfterKey>2 && qn>rcStruct[1].iPrevQ+4)qn=rcStruct[1].iPrevQ+4;

      dctx->iQParam=qn;
      /*
      //if(b>=3){dctx->iQParam=qn;if(dctx->iQParam>42)dctx->iQParam=42; dctx->iMaxQParam=100;}
      if(mmabs(qn-dctx->iQParam)<3)dctx->iQParam=qn;
      else if(b>=3){dctx->iQParam=(dctx->iQParam+qn*7)>>3;}
      else if(b==0 && qn-dctx->iQParam>6){qn=dctx->iQParam+6;dctx->iQParam=qn;}//4179,333
      else if(b==0 && dctx->iQParam-qn>6){qn=(dctx->iQParam-qn-3)>>1;dctx->iQParam=qn;}//4179,333
      //else if(b==0)dctx->iQParam=(dctx->iQParam+qn*2+1)/3;
      else if(mmabs(qn-dctx->iQParam)<8 && iFramesAfterRef>2)dctx->iQParam=qn;else  dctx->iQParam=(dctx->iQParam+qn+1)>>1;
      */
      int iMinQ=b>=3?(iMinQval-4):iMinQval;
      if(iMinQ<0)iMinQ=0;
      if(dctx->iQParam>iMaxQval)dctx->iQParam=iMaxQval;
      if(b>=3 && dctx->iQParam+4>iMaxQval)dctx->iQParam=iMaxQval-4;
      if(dctx->iQParam<iMinQ)dctx->iQParam=iMinQ;

      //else if(b<3 || qn+3<dctx->iQParam )dctx->iQParam=(dctx->iQParam+qn)>>1;
   }
   static int iPrevQ2;
   static int iPrevQTmp=dctx->iQParam;
   if(b!=1)iPrevQ2=iPrevQ;else {if(iPrevQ2<dctx->iQParam)dctx->iQParam=iPrevQ2;}
  // if(dctx->iQParam<12)dctx->iQParam=12;
   iPrevQ=dctx->iQParam;
#else
   iFramesLeft=50;
   //key ar q=2 ir ok
//   dctx->iIsB=0;
   //dctx->iQParam=8;//894
#if 1
   //static int gghh;gghh++;
   dctx->iQParam=iVideoKbps;//1178
#else
   dctx->iQParam=b==1?(iVideoKbps-2):iVideoKbps;//1178
   if(b==1)b=0;
   dctx->iIsB=dctx->iThisWasB=0;
#endif
   //static int iFCx=0;iFCx++;if(iFCx<100)dctx->iQParam=iFCx/3;
#endif
   dctx->iMaxQParam=100;
   //if(b==2){b=0;dctx->iQParam=12;dctx->iIsReferenceFrame=0;}
  //  if(b==2){b=0;dctx->iQParam=24;dctx->iIsReferenceFrame=0;}

   //dctx->iQParam-=(iFramesAfterRef>>4);dctx->iQParam+=4;
   //if(dctx->iQParam<8)dctx->iQParam=8;





//   if(dctx->iQParam>dctx->iMaxQParam)dctx->iQParam=dctx->iMaxQParam;
   if(dctx->iQParam>40)dctx->iQParam=40;
//   rcStruct[b>2?RC::RC_key:RC::RC_dif].iPrevQ=dctx->iQParam;

   static int iPrevLastFrameDif[2];
   int iThisWasB=0;
   
   if(dctx->iIsB && (iLastFrameDif>2 || iLastFrameDif>iPrevLastFrameDif[b==1])){//  && iLastFrameDif>2 && (iLastFrameDif*3>iPrevLastFrameDif+5 ||  iLastFrameDif>4)){
      dctx->iThisWasBX=1;//1;
      dctx->iThisWasB=0;dctx->iIsB=0; iThisWasB=1;
      //if(dctx->iQParam>16)dctx->iQParam=16;
   }else dctx->iThisWasBX=dctx->iThisWasB=0;
   //---------------------if(b<2){dctx->iIsB=1;dctx->iThisWasBX=dctx->iThisWasB=0;}
   q=getQUV(b,dctx);
   iPrevLastFrameDif[b==1]=iLastFrameDif;
//if(b==0)dctx->iIsB=1;
   if(dctx->iIsB|dctx->iThisWasB|iThisWasB){
      q*=5;q>>=3;q&=~3;
   }
   dctx->iQValIn=q;
   if(dctx->iQParam<-7)dctx->iQParam=-7;

//   dctx->iThisWasB=0;dctx->iIsB=0; iThisWasB=0;
//   if(dctx->iSkipId==0 && b!=1)debugsi("dctx->iQParam",dctx->iQParam);

   static int ret=0;
   if(!q)q++;
   int l=dctx->encF(pCur,pRef,w,h,q,pOut);
  // debugsi("-----l------",l);
   //dctx->iQParam=iPrevQTmp;
   ret+=l;
   if(!l){
      {
       //  debugsi("sz",ret);
         if(b==1)prevIsB=1;else prevIsB=0;
         static int iKeyFrames;
         if( b>2)iKeyFrames++;
         else if(b!=1)iKeyFrames=0;
         if(b>2){
            void sleepAfterKey(int k);
            if(::iIsUDP)sleepAfterKey(iKeyFrames);
         }
      }
      if(b>2)iFramesAfterKey=0;else iFramesAfterKey++;
      iBytes+=ret;//(dctx->iLastYBits>>3);
      
      debugss("iLastYBits left",(dctx->iLastYBits+7)>>3,(iBytesNeeded-iBytes)>>10);
      if(b!=1 && b!=2){
         int kid=b>2?RC::RC_key:RC::RC_dif;
         rcStruct[kid].iPrevQ=dctx->iQParam;
         rcStruct[kid].iPrevRealSize=dctx->iLastYBits>>3;
         rcStruct[kid].iPrevRealSizeUV+=ret-(dctx->iLastYBits>>3);
         rcStruct[kid].iPrevRealSizeUV>>=1;
         int qlma=rcStruct[kid].qLimitMax;
         int qlmi=rcStruct[kid].qLimitMin;
       //  rcStruct[kid].iPrevRealSizeNeed-=(rcStruct[kid].iPrevRealSizeUV);
         if(rcStruct[kid].iPrevRealSize*11>rcStruct[kid].iPrevRealSizeNeed*12){
            if(rcStruct[kid].iPrevQ>rcStruct[kid].qLimitMax)rcStruct[kid].qLimitMax--;
         }
         else if(ret && rcStruct[kid].iPrevRealSize*4<rcStruct[kid].iPrevRealSizeNeed*3){
            if(rcStruct[kid].iPrevQ<rcStruct[kid].qLimitMin)rcStruct[kid].qLimitMin++;
         }
        // if(qlmi!=rcStruct[kid].qLimitMin || qlma!=rcStruct[kid].qLimitMax)

         if(qlma==rcStruct[kid].qLimitMax && rcStruct[kid].iPrevRealSize*6<rcStruct[kid].iPrevRealSizeNeed*5){
            if(rcStruct[kid].iPrevQ>rcStruct[kid].qLimitMax)rcStruct[kid].qLimitMax++;
         }
         else if(qlmi==rcStruct[kid].qLimitMin && rcStruct[kid].iPrevRealSize*4>rcStruct[kid].iPrevRealSizeNeed*5){
            if(rcStruct[kid].iPrevQ<rcStruct[kid].qLimitMin)rcStruct[kid].qLimitMin--;
         }

         static int iAvgLastCnt;
         static int iAvgLast32N;
         static int iAvgLast32R;
         int iFixed=0;
         if(b==0){
            iAvgLastCnt++;
            iAvgLast32N+=rcStruct[kid].iPrevRealSizeNeed;
            iAvgLast32R+=rcStruct[kid].iPrevRealSize;
            if(iAvgLastCnt==32){
               iAvgLastCnt=0;
               //iAvgLast32N>>=5;
               //iAvgLast32R>>=5;
               if(iAvgLast32N*4<iAvgLast32R*3){iFixed=1;if(qlmi==rcStruct[kid].qLimitMin)rcStruct[kid].qLimitMin++;if(qlma==rcStruct[kid].qLimitMax)rcStruct[kid].qLimitMax++;}
               else if(iAvgLast32N*3>iAvgLast32R*4){iFixed=1;if(qlmi==rcStruct[kid].qLimitMin)rcStruct[kid].qLimitMin--;if(qlma==rcStruct[kid].qLimitMax)rcStruct[kid].qLimitMax--;}
               iAvgLast32N=iAvgLast32R=0;
            }
         }

         if(qlmi!=rcStruct[kid].qLimitMin || qlma!=rcStruct[kid].qLimitMax){
         }
         else if(!iFixed){
            if(ret && rcStruct[kid].iPrevRealSizeNeed>rcStruct[kid].iPrevRealSize*4){rcStruct[kid].qLimitMin++;}
            if(rcStruct[kid].iPrevRealSizeNeed*4<rcStruct[kid].iPrevRealSize){rcStruct[kid].qLimitMax--;}
         }


         if(rcStruct[kid].qLimitMin+2>=rcStruct[kid].qLimitMax){
            /*
            rcStruct[kid].qLimitMin=rcStruct[kid].qLimitMax-2;
            int av=(rcStruct[kid].qLimitMax+rcStruct[kid].qLimitMin);
            rcStruct[kid].qLimitMin=(av-8)>>1;
            rcStruct[kid].qLimitMax=(av+4)>>1;
            */
         }else if(0){
            int cc=(qlmi!=rcStruct[kid].qLimitMin)+(qlma!=rcStruct[kid].qLimitMax);
            if(cc==1){
               if(qlmi!=rcStruct[kid].qLimitMin){
                  rcStruct[kid].qLimitMax=rcStruct[kid].qLimitMin+12;
               }
               else if(qlma!=rcStruct[kid].qLimitMax){
                  rcStruct[kid].qLimitMin=rcStruct[kid].qLimitMax-12;
               }
            }
         }
         if(rcStruct[kid].qLimitMin>iMaxQval)rcStruct[kid].qLimitMin=iMaxQval;
         if(rcStruct[kid].qLimitMin<iMinQval)rcStruct[kid].qLimitMin=iMinQval;
         if(rcStruct[kid].qLimitMax>iMaxQval)rcStruct[kid].qLimitMax=iMaxQval;
         if(rcStruct[kid].qLimitMax<iMinQval)rcStruct[kid].qLimitMax=iMinQval;
/*
         if(qlmi!=rcStruct[kid].qLimitMin || qlma!=rcStruct[kid].qLimitMax){
            debugsi("min",rcStruct[kid].qLimitMin);
            debugsi("max",rcStruct[kid].qLimitMax);
         }
         else 
         */
         {
            //debugsi("need",rcStruct[kid].iPrevRealSizeNeed);
            //debugsi("real",rcStruct[kid].iPrevRealSize);
         }
         /*
         {
            static int iCnt[2];iCnt[kid]++;
            static int iAbsErr[2];
            int ae=abs(rcStruct[kid].iPrevRealSizeNeed-rcStruct[kid].iPrevRealSize);
            if(ae*iCnt[kid]>iAbsErr[kid]){
               ae=ret>>2;
            }
            iAbsErr[kid]+=ae;
            debugsi("ae",iAbsErr[kid]/iCnt[kid]);
         }
         */
         
      }

   }
   if(!l) {ret=0;iFramesLeft--;}
   return l;
}

int testDctX2(unsigned char *pCur, unsigned char *pRef, int w, int h, int q, unsigned char *pOut, int b){
   void testImgZ(unsigned char *pCur, unsigned char *pRef ,int w, int h);
   return testDctX2K(pCur, pRef, w, h,  q, pOut, b);
#if 0
   //testImgZ(pCur,pRef ,w, h);
   //memcpy(pCur,pRef,w*h*3);
   //if(b>2)memset(pCur,128,w*h*3);
   //if(b!=1)b=3;//else b=0;
   //if(b>2)b=0;
//   b=3;
   
   //if(b<2){if(b==1)b=0;else b=2;}
   //if(b>1)b=2;
  //--if(b>2)b=0;
  // if(b==1)b=0;
   //if(b<2)b=2;
   static int iQPrevX0=q;
   if(b>=2){
      q=iQPrevX0;
      //b=0;
   }
   if(b==0)iQPrevX0=q;
   //if(b==1 || b==2)b=0;
   //if(b==2)b=0;else if(b==0)
//  if(b==0)b=2;else if(b==1)b=0;
int qINR=q;
//if(b==0)b=2;else if(b==1)b=0;
//b=2;   
  // if(b==2)b=0;
   //if(b<2)return 0;
static int iFramesAfterKey;
   static int iStart=1;
      static int iKeys=0;
      //--if(b>2 && (iFramesAfterKey<150 &&  iFramesAfterKey!=0) &&  iLastFrameDif<40)b=0;
      //--if(b==2 && (iFramesAfterKey==0 || iFramesAfterKey>100) && iLastFrameDif>80)b=3;
      //if(iStart && iFramesAfterKey==4)b=3;
   if(b>2 && iStart){
      iKeys++;
      iFramesAfterKey=0;
   }
   else if(iStart)iFramesAfterKey++;
  // b=3;
   //b=0;
      //if(iKeys>2 && b>2)b=0;
  // if(b==0)b=1;

//   if(b!=1)b=0;
   //b=3;
//if(b==1)b=0   ;
   /*
    if( (hkernel32 = GetModuleHandle( _T("KERNEL32") ) ) )
    {
        ULONG (WINAPI* OurSetThreadExecutionState)( ULONG );

        OurSetThreadExecutionState = (ULONG (WINAPI*)( ULONG ))
            GetProcAddress( hkernel32, _T("SetThreadExecutionState") );

        if( OurSetThreadExecutionState )
            // Prevent monitor from powering off 
            OurSetThreadExecutionState( ES_DISPLAY_REQUIRED | ES_CONTINUOUS );
        else
            msg_Dbg( p_event, "no support for SetThreadExecutionState()" );
    }
   */
  // ::SetThreadExecutionState(ES_DISPLAY_REQUIRED | ES_CONTINUOUS );
 /*
   if(iStart){
      memset(pCur,127,w*h*3);
      //testImgZ(pCur,pRef ,w, h);;//memset(pCur,127,w*h*3);
//      return 0;
      }
      b=0;
      
*/
   //return 0;
   
  // debugss("enc",0,0);
//   q=76;if(b>1){q=80;b=0;}
//if(b==1)b=0;
   //return 0;
   //if(b==1 || b==2)b=0;dctx->iNextQ=dctx->iPrevQ=q;
//   b=3;
   //q=64;   if(b==2){b=0;q=68;}
   if(dctx==NULL)dctx=new TDCTX();
   dctx->iPartLimitSize=iIsUDP?(w*h>640*480?(dctx->iIsKey?20000:8000):850):20000;//850;
   memset(pOut,0,dctx->iPartLimitSize+200);
   setStatSZ(w,h,-1);

  // if(b==2)b=0;
#if 0
   //!defined(_WIN32_WCE) && !defined(__SYMBIAN32__)

   if(b==3){
      FILE *f=fopen("testfilter","r");

      iTestFilter=f?1:0;
      if(f)fclose(f);
   }
#endif

  // if(b==2)b=0;
   //if(b!=1)b=3;
   //iTestFilter=1;
 //  if(b>1)b=0;

   //if(b==3)q=40;else if(b==2){q=80;b=0;}else q=72;
   //filterUV(pRef, w, h);
/*
   static int retx=0;
   retx=!retx;
   if(retx==1)return 0;
   
   return tt(pOut,pCur,pRef,w,h,q,b==1);

  */ 
   dctx->iIsB=0;
   static int iDecRefQ=0;
   if(b==1 || b==0)iDecRefQ=0;

   int iWasRef=b==2;
   if(b==2 && iDecRefQ){
      //if(iDecRefQ==2)b=0;
      dctx->iDecRefQ=1;
   }
   else dctx->iDecRefQ=0;

//if(b==0 || b==2)b=1;
   static int iFrC=0;
   static int iFrCntRef0=0;
   
//   return dctx->encode(pCur,pRef,w,h,q,pOut,1);
//   dctx->iIsKey=1;return dctx->encF(pCur,pRef,w,h,q,pOut);
  // if(b==1)return 0;
    //b=3;
   //if(b!=3)b=2;
  // b=3;
//   if(b==0)b=2;
//debugss("ep",0,0);
      if(1){//1|| b==3 ||b==1){
    //  return 0;
      int iRateControl=1;
      static int iPrevWasKey;
      static int iNextQ=q;
      static int iFrameSize=0;
      static int iPrevKeySize=4000;
//if(b!=1)b=0;
      if(iStart && b==0){
//         if(iLastFrameDif==0){iNextQ+=4; if(iNextQ>92)iNextQ=92;}else
          if(iLastFrameDif>30){iNextQ-=4;if(iNextQ<12)iNextQ=12;}
          if(iLastFrameDif>50){iNextQ-=4;if(iNextQ<12)iNextQ=12;}
      }
      iStart=0;
      if(b==3)dctx->iPrevQ=q;
      //if(b==2 && iLastFrameDif>60)b=0;
      dctx->iIsKey=b==3 || b==4;
      dctx->iIsReferenceFrame=b==2;dctx->iIsB=b==1;
      static int qRef=q;
      static int qB=q;
      static int iMaxQNext=q;
      if(dctx->iIsReferenceFrame){
         //if(q<iNextQ)q=iNextQ+8;
         //else {q+=iNextQ+12;q>>=1;}
         q=(qB+iNextQ+q*2+12)>>2;
         if(q<iNextQ+4)q=iNextQ+4;
         if(q>96)q=96;
         qRef=q;
      }
      //if(dctx->iIsB)dctx->iIsKey=0;
      if(b==2 && iPrevWasKey)dctx->iIsKey=0;
      //|(dctx->iPrevQ-4)
      dctx->iLowQval=iRateControl==1 || (iFrCntRef0&7);
      if(dctx->iIsReferenceFrame){dctx->iLowQval=0;dctx->iIsKey=0;}
      if(dctx->iLowQval==0 && b==0)q+=4;
      static int iRepCnt=0;
/*
      int iLim=600;
      if(w>1500)iLim=40000;
      else if(w>1000)iLim=25000;
      else  if(w>800)iLim=12000;
      else  if(w>700)iLim=8000;
      else  if(w>600)iLim=4000;
      else if(w>350)iLim=2000;
      else if(w>300)iLim=1500;
      else if(w>220)iLim=1000;
      */
      //int iLim=((800*((w*32/176)+(h*32/144)))>>6);
      int iLim=((800*((w*32/(176))+(h*32/144)))>>6);
      iLim+=(800*w*h)/(176*144);iLim>>=1;
      //int iLim=((4000*((w*32/640)+(h*32/480)))>>6);
      //iLim=w*h/50; iLim=w*h/25;
      //--iLim*=(q);iLim>>=6;iLim*=(q);iLim>>=6;
      int iLimPR=iLim;
      //iLim+=1000000;
//--      if(q>60){iLim*=(q*q);iLim/=3600;}else{iLim*=(q);iLim/=60;}
      if(q>60){iLim*=(q*q);iLim/=3600;}else{iLim*=(q*q);iLim/=3600;iLim*=7;iLim+=iLimPR;iLim>>=3;}
      //iLim*=(q*q);iLim/=3600;
      //if(q>52){iLim*=(q*q);iLim/=52*52;}else{iLim*=(q);iLim/=52;}
      //iLim-=1000000;
      if(iLim*8<iLimPR)iLim=iLimPR/8;
      else if(iLimPR*6<iLim)iLim=iLimPR*6;
//iLim=12000;
   //iLim=1000;
      if(h*175<w*100){iLim*=5;iLim>>=2;iLim+=300;}
      iLim+=100*w*h/(176*144);
      //if(iLim<600)iLim=600;
      if(w<200)iLim+=150;
      //iLim*=5;iLim>>=3;
      static int iLastFrameSize=iLim;
      static int iFrameSizeAvg4=iLim;
      static int iFrameSizeAvg8=iLim;
      static int iFrameSizeAvg16=iLim;
      static int iFrameSizeAvg32=(iLim*5)>>2;
      static int iFrameSizeAvg64=(iLim*3)>>1;
//iLim+=3000;      
      dctx->iIncBitrate=0;
   static int iPrevQParam=15;
   static double l_loc_LastFrameSad;
   /*
   static const int qTabs[][3]={
      {4,2,12},{8,4,16},{12,8,24},{16,12,32},
      {24,16,40},{32,24,48}, {36,28,52},{40,28,56},
      {44,32,60},{48,36,64},{52,40,68},{56,44,72},
      {60,44,76},{64,48,80},{68,52,84},{72,56,88},
      {76,60,88},
      {80,64,92},
      {84,72,96},
      {88,76,96},
      {92,76,96},
      {96,80,96},
      {0,0,0}
   };
   */
   //iLim=3000;
   int iQParam=iPrevQParam;
#if 0
   if(b==0 && dctx->iSkipId==0){
      
      int dx=mmabs(iLastFrameSize-iLim);
      int dx8=mmabs(iFrameSizeAvg8-iLim);
      int dx4=mmabs(iFrameSizeAvg4-iLim);
      int dx32=mmabs(iFrameSizeAvg32-iLim);
      int iQ2Prev=iPrevQParam;
      if(dx*2>iLim || (dx4*4>iLim && dx*7>iLim)||  (dx8*12>iLim && dx*9>iLim) || (dx32*24>iLim && dx*4>iLim)){
         //(dx4*12>iLim && dx*6>iLim) || dx*3>iLim){
        // (dx8*6>iLim && dx*12>iLim) || (dx8*8>iLim  && dx*10>iLim) || (dx8*16>iLim && dx*2>iLim)){//
         //((iLastFrameSize*16<iLim*15 && iFrameSizeAvg4*6<iLim*5 && iFrameSizeAvg8<iLim) || (iLastFrameSize*15>iLim*16 && iFrameSizeAvg4*7>iLim*8)) || (iFrameSizeAvg16*5>iLim*4 && iLastFrameSize*2>iLim)){
   //memset(pCur,128,w*h*3);
         if(iFrameSizeAvg8<iLim &&  iFrameSizeAvg4*3<iLim*2  && iLastFrameSize*2<iLim)iPrevQParam++;
         else if(iFrameSizeAvg64*3<iLim && iPrevQParam<4 && iFrameSizeAvg8<iLim && iFrameSizeAvg4*4<iLim  && iLastFrameSize*3<iLim*2)iPrevQParam+=2;
         else if(iFrameSizeAvg64*4<iLim*3 && iPrevQParam>=6 && iFrameSizeAvg16*3<iLim*2 && iFrameSizeAvg8<iLim && iLastFrameSize<iLim && iFrameSizeAvg4*3<iLim*2)iPrevQParam++;
         //else if(iFrameSizeAvg64<iLim && iPrevQParam>=5 && iFrameSizeAvg16*3<iLim*2 && iFrameSizeAvg8<iLim && iFrameSizeAvg4*2<iLim)iPrevQParam++;
         else if(iFrameSizeAvg64*4<iLim*3 && iFrameSizeAvg16*4<iLim*3 && iFrameSizeAvg8*4<iLim*3 && iFrameSizeAvg4*3<iLim*2 && iLastFrameSize<iLim)iPrevQParam++;
         else if(iFrameSizeAvg32*2<iLim && iFrameSizeAvg16<iLim && iFrameSizeAvg8*2<iLim && iFrameSizeAvg4*3<iLim && iLastFrameSize<iLim)iPrevQParam++;
         else if(iPrevQParam<4 && iFrameSizeAvg16*3<iLim*2  && iFrameSizeAvg4*2<iLim && iLastFrameSize<iLim)iPrevQParam++;
   //      else if(iPrevQParam>5 && iFrameSizeAvg64*2>iLim  &&  iFrameSizeAvg4*3>iLim)iPrevQParam-=3;
         else if(iPrevQParam>6 && iFrameSizeAvg64>iLim &&  iFrameSizeAvg8*3>iLim*4  &&  iFrameSizeAvg4*2>iLim && iLastFrameSize*2>iLim*3)iPrevQParam-=2;
         else if(iPrevQParam && iFrameSizeAvg16>iLim && iFrameSizeAvg8*3>iLim*4  &&  iFrameSizeAvg4*2>iLim*3 && iLastFrameSize>iLim)iPrevQParam--;
         //else if(iPrevQParam && iFrameSizeAvg32>iLim  &&  iFrameSizeAvg4*4>iLim*3)iPrevQParam--;
         else if(iPrevQParam &&  iFrameSizeAvg32>iLim && iFrameSizeAvg8*2>iLim*3 &&  iFrameSizeAvg4*4>iLim*5 && iLastFrameSize>iLim)iPrevQParam--;
         else if(iPrevQParam &&  iFrameSizeAvg64>iLim && iFrameSizeAvg8*4>iLim*5 &&  iFrameSizeAvg4>iLim && iLastFrameSize>iLim)iPrevQParam--;
         else if(iPrevQParam &&  iFrameSizeAvg64*4>iLim*3 && iFrameSizeAvg8*8>iLim*7 &&  iFrameSizeAvg4>iLim && iLastFrameSize>iLim)iPrevQParam--;
         else if(iPrevQParam &&  iFrameSizeAvg32*2>iLim &&  iFrameSizeAvg4*6>iLim*5 && iLastFrameSize>iLim)iPrevQParam--;
         else if(iPrevQParam &&  iFrameSizeAvg4*6>iLim*5 && iLastFrameSize*2>iLim*3)iPrevQParam--;
         //if(iPrevQParam>18)iPrevQParam=18;
         if(iPrevQParam>36)iPrevQParam=36;
         //--if(iPrevQParam==18 && iFrameSizeAvg64*2>iLim)iPrevQParam=17;
      }
      //iPrevQParam;
    {
         iPrevQParam+=4;
         iPrevQParam *=(l_loc_LastFrameSad+80000);
         iPrevQParam /=(lLastFrameSad+80000);
         iPrevQParam-=4;

         if(iQ2Prev<iPrevQParam && iFrameSizeAvg8>iLim)iPrevQParam=iQ2Prev;// buus lielaaks
         else if(iQ2Prev>iPrevQParam && iFrameSizeAvg8<iLim && iLastFrameSize<iLim)iPrevQParam=iQ2Prev; // buus mazaak
      }

      static int iPrevInc=0;
      
      //if(iPrevQParam>8 && iQ2Prev>8 && ( iPrevQParam*3<iQ2Prev*2 || iPrevQParam*2>iQ2Prev*3))iPrevQParam=(iPrevQParam+iQ2Prev*3+2)>>2;
      int qDif=mmabs(iQ2Prev-iPrevQParam);
      if(qDif>4){
         if(iQ2Prev>iPrevQParam)iPrevQParam=iQ2Prev-4;
         else if(iQ2Prev<iPrevQParam)iPrevQParam=iQ2Prev+4;
      }
      if(iPrevQParam==iQ2Prev && iFrameSizeAvg4>iLim*2)iPrevQParam-=2;
      if(iPrevInc && iQ2Prev<iPrevQParam)iPrevQParam=iQ2Prev;
      iPrevInc=iQ2Prev<iPrevQParam;
      
      
      //iPrevQParam*=(iLastFrameSize+50000);
      //iPrevQParam/=(iLim+50000);

      
      debugss("q",lLastFrameSad,iPrevQParam);
      

      //l_loc_LastFrameSad=lLastFrameSad
      
      //debugss("64-32,",iFrameSizeAvg64,iFrameSizeAvg32);
    //  debugss("32-8,",iFrameSizeAvg16,iFrameSizeAvg8);
//      debugss("4-p,",iFrameSizeAvg4,iPrevQParam);
      

   }
   if((b==0 || b==2) && iLastFrameDif>105 && iFramesAfterKey>4){if(iStart)iPrevQParam--;b=3;dctx->iIsKey=1;dctx->iIsReferenceFrame=0;}
#else
   /*
   if(b>2 && dctx->iSkipId==0){// && (iLastFrameSize>iLim*2 || iLastFrameSize*5<iLim)){
      int iCoefCntX=cntACCoefs02(pCur, pRef,  w,  h,dctx,3)*2.1;
      static int iPrevCoefCntX=iCoefCntX;
      int iNewSize;
      int iTests=16;
      if(iLastFrameDif>50 && iPrevQParam>24)iPrevQParam=24;
      while(iTests>0){
         iTests--;
         int iD=(40-iPrevQParam);
         if(iD<1)iD=1;
         //static int t_iD[]={4,5,6,7,8,9,10,11,12}
         iNewSize=iCoefCntX/iD;
         long long lNewSize=(((long long)iPrevKeySize* (long long)iCoefCntX/(long long)iPrevCoefCntX)*7+(long long)iPrevKeySize)>>3;
         iNewSize=(lNewSize*3+iNewSize)>>2;


         if(iNewSize>iLim*4){
            iPrevQParam--;
            if(iPrevQParam<=0)break;
            continue;
         }
         else if(iNewSize<iLim*3){
            iPrevQParam++;
            if(iPrevQParam>=24)break;
            continue;
         }
         break;
      }
      iPrevCoefCntX=iCoefCntX;

      if(iPrevQParam<0)iPrevQParam=0;
      else if(iPrevQParam>24)iPrevQParam=24;
      //iPrevKeySize
      
      debugss("newS-q",iNewSize,iPrevQParam);
   }
   */
   static int iPrevAvgDev=0;
 //  if(dctx->iSkipId==0)debugss("avg dev--",iPrevAvgDev,iLastFrameAvgDev);
   goto fastSk;
   if(iPrevAvgDev && b>2 && iPrevAvgDev*4+500<iLastFrameAvgDev*3 && dctx->iSkipId==0){
      int iRM=min(dctx->iMaxQParam,iPrevQParam);
      if(iPrevAvgDev*4<iLastFrameAvgDev)iPrevQParam=iRM-18;
      else if(iPrevAvgDev*2<iLastFrameAvgDev)iPrevQParam=iRM-12;
      else iPrevQParam=iRM-8;
   }
   else if(iPrevAvgDev && b>2 && iPrevAvgDev*2>iLastFrameAvgDev*3+500 && dctx->iSkipId==0){
      iPrevQParam+=6;
   }
   else if((b==0 || b==2  || ((iPrevAvgDev*31>iLastFrameAvgDev*32+500 || iPrevAvgDev*32+500<iLastFrameAvgDev*31)&&  b>2 && iLastFrameDif>50)) && dctx->iSkipId==0 && b!=1){
      static int iPrevPrevFrameSize;
      static int iPrevCoefCntX=0;
      static int iPrevPrevCoefCntX=0;
      static int iPrevIsRef=0;
      int iCoefCntX=cntACCoefs02(pCur, pRef,  w,  h,dctx,iFramesAfterKey<3 && b==2?0:b)+1;
      if(iPrevCoefCntX){

         double d1=(double)iCoefCntX/(double)(iPrevCoefCntX+2);
         double d2=(double)iCoefCntX/(double)(iPrevPrevCoefCntX+2);
         double lNewSize=(((double)iLastFrameSize* d1)*7+(double)iLastFrameSize)/8;
         double lNewSizePP=(((double)iPrevPrevFrameSize* d2)*7+(double)iPrevPrevFrameSize)/8;
         int iNewSize=lNewSize+0.5;
         int iNewSizePP=lNewSizePP+0.5;
         if(iPrevPrevCoefCntX){
            if(iPrevIsRef){iNewSize=(iNewSizePP*3+iNewSize)>>1;}
            else {iNewSize*=3;iNewSize+=iNewSizePP;iNewSize>>=2;}
         }

         //int iD=(36-iPrevQParam);
         int iD=(48-iPrevQParam)/1.5;
         if(iD<1)iD=1;
         if(abs(iNewSize-iNewSizePP)*6>(iNewSizePP+iNewSize)){
            iNewSize*=3;
            iNewSize+=iCoefCntX/iD;
            iNewSize>>=2;
         }
         else{
            iNewSize*=7;
            iNewSize+=iCoefCntX/iD;
            iNewSize>>=3;
         }
         if(b>2)iNewSize>>=2;
         //????if(iLastFrameSize==0 && iNewSize>iLim*50)iNewSize=iLim/2;
         int iDifSize=abs((int)iNewSize-iLim);
         int iDifLastSize=abs(iLastFrameSize-iLim);
         int iDifSize4=abs((iFrameSizeAvg4*3+(int)iNewSize)/4-iLim);
         int iDifSize16=abs((iFrameSizeAvg16*15+(int)iNewSize)/16-iLim);
         static int iPrevChanged=0;
         if(b<3 || iNewSize>iLim){
         if((b!=2 || (iDifSize>iLim && iNewSize*4>iLim*5)) &&  (iDifLastSize*12>iLim || (iDifSize*2>iLim && iNewSize>iLim))){
            if((iDifSize*5>iLim && iDifSize4*9>iLim && iDifSize16*12>iLim) 
               ||  iDifSize*3>iLim 
               || (iDifSize*4>iLim && iDifSize4*5>iLim)
               || (iDifSize*6>iLim && iDifSize16*8>iLim)){
               //double d=iNewSize>iLim?((iNewSize*2+iNewSize4+iLim+iLim+iLim)/(iLim*2+iLim+iLim+iLim+iLim)):((iLim*2+iLim+iLim+iLim+iLim)/(iNewSize*2+iNewSize4+iLim+iLim+iLim));
               double d=0;
               if(iDifSize*4>iLim || iLastFrameSize>iLim*2){
                  d=iNewSize>iLim?((double)(iNewSize+iLim)/(double)(iLim*2+1)):((double)(iLim*2)/(double)(iNewSize+iLim+1));
               }
               else{
                  d=(iFrameSizeAvg16+iNewSize)>iLim*2?((double)(iNewSize+iFrameSizeAvg16+iLim+1)/(double)(iLim*3)):((double)(iLim*3)/(double)(iNewSize+iFrameSizeAvg16+iLim+1));
                  if(d>1.5)d=1.5;
               }
               d-=0.9;
               //d==2 -> 5
               //d==1 -> 1
              // d/=3;
               //d/=2;
               //if(d<0.5)d=0.5;
               int iRemFrom=iPrevQParam>dctx->iMaxQParam?dctx->iMaxQParam:iPrevQParam;
               if(d>3)d=3;
                  iPrevChanged=1;
               if(iNewSize>iLim){
                  iPrevQParam=iRemFrom-d*3;
               }
               else 
                  if(b==0 || iPrevQParam<10){/*if(b>2)b=2;*/iPrevQParam+=d*3;}
               if(iNewSize>iLim*5)iPrevQParam=iRemFrom-6;
               else if(iNewSize>iLim*3 && iLastFrameSize>iLim*4)iPrevQParam=iRemFrom-3;
               if(iPrevQParam<0)iPrevQParam=0;else if(iPrevQParam>36)iPrevQParam=36;

            }
            else if(b==0 && iPrevChanged==0){
               if(iLastFrameSize*2<iLim){
                  iPrevQParam++;
                  iPrevChanged=1;
               }
               else if(iLim*2<iLastFrameSize){iPrevQParam--;iPrevChanged=1;}
            }
            else if(b==0)iPrevChanged=0;
         }
         else if(b==0)iPrevChanged=0;
         
         //debugss("NewSZ q",iNewSize,iPrevQParam);
         //debugss("pred-coefs-size",iPrevCoefCntX,iLastFrameSize);
         }else if(b==0)iPrevChanged=0;
      }
      iPrevIsRef=b>1;
      if(b<3){
      if(b!=2 || !iPrevCoefCntX){
         if(iPrevCoefCntX>1 && iLastFrameSize){
           iPrevPrevFrameSize=iLastFrameSize;
           iPrevPrevCoefCntX=iPrevCoefCntX;
         }
        iPrevCoefCntX=iCoefCntX;
      }
      }
   }
   if(dctx->iSkipId==0 && b!=1)iPrevAvgDev=iLastFrameAvgDev;
#endif

rep_q:
   //iPrevQParam=24;
//labi 
//iPrevQParam=12;
//if(b==1)b=0;
  // iPrevQParam=15;
   //iPrevQParam=17;
   //iPrevQParam=36;
   //iPrevQParam=36;if(b!=1){b=3;dctx->iIsKey=1;dctx->iIsB=dctx->iIsReferenceFrame=0;}
   
fastSk:
   if(dctx->iSkipId==0 && (b!=1 && b!=2)){//  || ((iPrevAvgDev*31>iLastFrameAvgDev*32+500 || iPrevAvgDev*32+500<iLastFrameAvgDev*31)&&  b>2 && iLastFrameDif>50)) && dctx->iSkipId==0 && b!=1){
      int l2=iLim;
      if(b>1 && iLastFrameDif<30)l2*=4;else if(b>1)l2*=2;
      //int qp1=rc(pCur, pRef, w,  h,l2);
     int qp1=rc(pCur, pRef, w,  h,l2+((iLim-iFrameSizeAvg32)>>2)+((iLim-iFrameSizeAvg4)>>3)+((iLim-iLastFrameSize)>>4)+((iLim-iFrameSizeAvg8)>>3),b);
     if(b<3 || qp1-6>iPrevQParam){ iPrevQParam+=qp1;iPrevQParam>>=1;}
   }
   if(iLastFrameDif>90 && b==2){b=0;dctx->iIsReferenceFrame=0;}


   if(iPrevQParam>36)iPrevQParam=36;

   if(qINR>64 && iPrevQParam<4)iPrevQParam=4;
   if(qINR>76 && iPrevQParam<8)iPrevQParam=8;
   if(qINR>80 && iPrevQParam<10)iPrevQParam=10;
   if(qINR>84 && iPrevQParam<12)iPrevQParam=12;
   if(qINR>88 && iPrevQParam<14)iPrevQParam=14;
  
  // iPrevQParam=0;
//iPrevQParam=(q)/3;
if(b==0)dctx->iMaxQParam=24;//36-9;//qINR/4+10;


//dctx->iMaxQParam=32;
//if(iPrevQParam<20)iPrevQParam=20;
//iPrevQParam=0;

if(dctx->iSkipId==0 && b==0 && iLastFrameSize>iLim*2 && iPrevQParam>dctx->iMaxQParam)iPrevQParam=dctx->iMaxQParam-4;
if(iPrevQParam<0)iPrevQParam=0;
//if(iPrevQParam<22)iPrevQParam=22;
//dctx->iMaxQParam=iPrevQParam=32;

dctx->iQParam=iPrevQParam;

if(b==2 && iFramesAfterKey<12 && iLastFrameDif>20){dctx->iIsReferenceFrame=0;dctx->iQParam+=(iDecRefQ?1:4);}
int qpm=iPrevQParam;
if(qpm>dctx->iMaxQParam){qpm=(qpm*3+dctx->iMaxQParam)>>2;}

if(b==2){qpm+=8;}

if(qpm>39)qpm=39;
if(qpm<0)qpm=0;
   static const int qTabsb0[]={
      4,8,12,16,20,
      24,28,28,32,32,
      36,36,40,40,44,
      48,48,52,52,56,
      56,60,64,64,68,
      68,72,72,76,80,
      80,84,84,88,88,
      88,92,92,92,96,
   };

/*
   if(qpm&1)
     dctx->iQValIn=(qTabs[qpm/2+1][bq]+qTabs[qpm/2][bq]+1)>>1;
   else 
      dctx->iQValIn=qTabs[qpm/2][bq];
   q=qTabs[qpm/2][bq];
*/
   q=qTabsb0[qpm];
/*
   {
      int i;
      int t0=dctx->tab_y_b[(b==1)*16];
      int t2=dctx->tab_y_b[(b==1)*16+1];
      int tabT[512];
      int iBestQ=4;
      int iBestD=1000;
      for(i=4;i<96;i+=4){
         initTabZ(i,&tabT[0],&j2_cb_quant_tbl[0],1,b==1,0);
         int d=mmabs(tabT[2]*2-t2)+mmabs(tabT[0]*4-t0);
         if(d<iBestD){iBestQ=i;iBestD=d;}
      }
      q=iBestQ;
   }
*/
  


   //dctx->iQValIn*=3;dctx->iQValIn+=96;dctx->iQValIn>>=2;
   //if(b>2){q>>=1;}
   //else {q*=7;q+=96;q>>=5;q++;q<<=2;}
   //dctx->iQValIn+=8;  
   //q-=4;
  // dctx->iQValIn=q=92;
//   dctx->iQValIn+=12;  q-=4;

   //q=qINR;
//q=96;   
   //q=qTabs[iPrevQParam][2];
   //q=88;
   //q=qINR;
   if(b>2){q*=3;q>>=2;}
if(q>96)q=96;
   if(dctx->iIsKey && q<4)q=4;
//   q=4;
//   q=88;if(b>1)q=92;
//   q=48;
   //q=4;
   
   static int iPrevLastFrameDif=0;
      dctx->iFramesAfterKey=iFramesAfterKey;
      /*
   if(//(iFramesAfterKey!=1) && 
      dctx->iIsB && ((iLastFrameDif*3>iPrevLastFrameDif+15 && iLastFrameDif>15) || iLastFrameDif>25)){
      dctx->iThisWasB=1;dctx->iIsB=0;b=0;q*=3;q>>=2;
   }else dctx->iThisWasB=0;
*/
      int iThisWasB=0;
      if(dctx->iIsB  && iLastFrameDif>3 && (iLastFrameDif*3>iPrevLastFrameDif+5 ||  iLastFrameDif>4)){
      //
         //dctx->iThisWasB=1;dctx->iIsB=0;
         dctx->iThisWasBX=1;
    dctx->iThisWasB=0;dctx->iIsB=0; dctx->iQParam-=6;iThisWasB=1;
   }else dctx->iThisWasBX=dctx->iThisWasB=0;
   if(dctx->iIsB|dctx->iThisWasB|iThisWasB){
      q*=5;q>>=3;q+=3;q&=~3;
   }
   dctx->iQValIn=q;
   
   //q=dctx->iThisWasB||dctx->iIsB?60:92;

   iPrevLastFrameDif=iLastFrameDif;
#if 0
   if(dctx->iSkipId==0 && b==0 && !dctx->iPrevWasKey){
      int retx=0;
      dctx->iPartLimitSize=1000000;
      static unsigned char *bufT=NULL;
      static int iPrevWH=0;;
      if(iPrevWH!=w*h*3){
         iPrevWH=w*h*3;
         bufT=new unsigned char [iPrevWH];
      }
      memcpy(bufT,pCur,iPrevWH);
      int ch[40];
      memset(ch,0,sizeof(ch));
      int iLim2=(iLim*7)>>3;
      if(b==2 || (b==0 && dctx->iPrevWasKey)){iLim2*=3;}
      else if(b>2){iLim2*=3;}
      int iCntReps=0;
      int iMaxCnt=3;//2;
      int iMaxLimD=2;//8;
      int iRepsD[]={3,1,1,1};
      do{
         iCntReps++;
         
         if(iPrevQParam&1)
           dctx->iQValIn=(qTabs[iPrevQParam/2+1][0]+qTabs[iPrevQParam/2][0]+1)>>1;
         else 
            dctx->iQValIn=qTabs[iPrevQParam/2][0];
         dctx->iIsFirstPass=1;
         retx=dctx->encF(pCur,pRef,w,h,q,pOut);if(retx)dctx->encF(pCur,pRef,w,h,q,pOut);
         dctx->iIsFirstPass=1;
         //if(iCntReps==2 && !retx)break;

         ch[iPrevQParam]=retx+1;
         //if(retx==0){retx=dctx->vlc.getBytePos();}
         debugss("iLim",retx,iLim2);
//         if(iLim*2<retx){iPrevQParam-=2;if(iPrevQParam<0)iPrevQParam=0;}


         memcpy(pCur,bufT,iPrevWH);

  //       break;
         if(iCntReps>=iMaxCnt)break;
         int d=mmabs(retx-iLim2);


         if(d*iMaxLimD<iLim2)break;

         int iDelta=(iMaxLimD-iLim2/d);//iMaxLimD

         if(iDelta<1)iDelta=1;if(iRepsD[iCntReps-1]>iDelta)iDelta=iRepsD[iCntReps-1];
         if(retx==0 && iCntReps==1)iDelta=4;
         int iNewQ=iPrevQParam;
         if(retx>iLim2)iNewQ-=iDelta;
         else iNewQ+=iDelta;
         if(iNewQ<0 || iNewQ>36){if(iDelta==1)break;}

         if(retx>iLim2)iNewQ+=iDelta;
         else iNewQ-=iDelta;
         if(retx>iLim2)iNewQ-=1;
         else iNewQ+=1;

         if(iNewQ<0 || iNewQ>36){break;}

         iPrevQParam=iNewQ;
         dctx->iQParam=iPrevQParam;
         if(ch[iPrevQParam])break;
      }while(1);

      int d2=mmabs(iLim2-ch[iPrevQParam]);

      for(int z=0;z<40;z++){
         if(ch[z]<2)continue;
         int dc=mmabs(((iLim+iLim2+1)>>1)-ch[z]);
         if(dc<d2){dctx->iQParam=iPrevQParam=z;d2=dc;}
      }
      if(!ch[iPrevQParam])return 0;

      dctx->iPartLimitSize=w*h>640*480?(dctx->iIsKey?20000:8000):850;
      memset(pOut,0,dctx->iPartLimitSize+200);
   }
#endif
   int ret=0;
   /*
   if(dctx->iIsKey && dctx->iSkipId==0){
      dctx->iPartLimitSize=100000;
      dctx->iQParam=8;
      ret+=dctx->encF(pCur,pRef,w,h,q,pOut);
      ret+=dctx->encF(pCur,pRef,w,h,q,pOut);
      dctx->iIsKey=0;
      dctx->iIsReferenceFrame=1;
      dctx->iFramesAfterKey=1;
      dctx->iQParam=8;
    //  return ret;
   }
   else dctx->iIsKey=0;
   */
   if(dctx->iQParam<0)dctx->iQParam=0;
      ret+=dctx->encF(pCur,pRef,w,h,q,pOut);
//if(!ret)debugss("gain",iBitsG,iBitsG>>3);
      static int iKeyFrames;
      if(!ret && b>2)iKeyFrames++;
      else if(!ret && b!=1)iKeyFrames=0;
      if(!ret && b>2){
         void sleepAfterKey(int k);
         if(::iIsUDP)sleepAfterKey(iKeyFrames);
      }
      if(iWasRef)b=2;
      //debugss("rep",ret,b*1000+q);
      /*
      if(ret==0){
         debugss("rep",iPicBitsPred>>3,0);
         iPicBitsPred=0;
      }
      */
//if(ret==0 && b==0 && dctx->iSkipId<1) debugss("q",q,iFrameSizeAvg4);
      if(iRepCnt==1 && ret){
        // debugss("rep",ret,dctx->iQVal);
      }
      /*
      if(ret==0){
         double getPSNR(unsigned char *p ,unsigned char *o, int w, int h, int step);
         double dd=getPSNR(pCur,pRef,w,h,3);
         debugss("psnr",(int)(dd+0.5f),0);
      }
*/
//      return ret;
      iFrameSize+=ret;
      //if(ret && b==0 && iFrameSize>iLim && dctx->iSkipId*2<(w*h>>8) && dctx->iSkipId*4<(w*h>>8)*3){iPrevQParam--;if(iPrevQParam<0)iPrevQParam=0;}
      if(ret && b==2){
         int blocks=w*h>>8;
         if((dctx->iLastYBits>>3)>iLim*4 || (dctx->iSkipId*3<blocks && (dctx->iLastYBits>>3)>iLim*2) || (dctx->iSkipId*6<blocks && (dctx->iLastYBits>>3)>iLim)){
            iDecRefQ=1;
            if((dctx->iLastYBits>>3)>iLim*4)iDecRefQ=2;
         }
         else if(iDecRefQ){
            if((dctx->iLastYBits>>3)<iLim*2 && dctx->iSkipId*2<blocks) iDecRefQ=0;

         }
         
             
      }
      int iQMin=(q*5)>>3;
      int iQMax=(q*10)>>3;
      if(iQMax>qRef-4)iQMax=qRef-4;

     // iLim=q*100;
      //iLim=3000;
      //iLim=1000;

      if(iRateControl && ret && b==0 && iRepCnt==0){
         if(iFrameSize*6>iLim*5)iNextQ-=4;
         if(iNextQ<iQMin)iNextQ=iQMin;
      }
      int iNoFrameLost=0;
      if(iNoFrameLost){
      if(ret==0 && b==3)iPrevWasKey=1;
      if(ret==0 && b==2)iPrevWasKey=0;
      }
      if(b>2){
         rcStruct[RC::RC_key].iPrevQ=dctx->iQParam;
         rcStruct[RC::RC_key].iPrevRealSize=dctx->iLastYBits>>3;
      }
     if(ret==0 && iRateControl){
         int iFS=iFrameSize?((dctx->iLastYBits>>3)*9)>>3:0;
      //   iFS*=7;iFS>>=3;;

         if(b>2){
            iPrevKeySize=iFS;
         }
         if(b==0 && !dctx->iThisWasB && !iThisWasB){
            l_loc_LastFrameSad=lLastFrameSad;
            if(dctx->iPrevWasKey){iFS>>=1; iFS+=iFrameSizeAvg4;iFS>>=1;}
         iFrameSizeAvg4*=3;iFrameSizeAvg4+=iFS;iFrameSizeAvg4>>=2;
         iFrameSizeAvg8*=7;iFrameSizeAvg8+=iFS;iFrameSizeAvg8>>=3;
         iFrameSizeAvg16*=15;iFrameSizeAvg16+=iFS;iFrameSizeAvg16>>=4;
         iFrameSizeAvg32*=31;iFrameSizeAvg32+=iFS;iFrameSizeAvg32>>=5;
         iFrameSizeAvg64*=63;iFrameSizeAvg64+=iFS;iFrameSizeAvg64>>=6;
         iLastFrameSize=iFS;
         rcStruct[RC::RC_dif].iPrevQ=dctx->iQParam;
         rcStruct[RC::RC_dif].iPrevRealSize=dctx->iLastYBits>>3;
         //debugss("fs",iFrameSize,b*1000+q);
         //debugss("fsize",iFS,b*1000+q);
         }
         iRepCnt=0;
         iFrameSize=0;
         dctx->iIsFirstPass=1;

         iFrC++;
      }
      if(ret==0 && b==0)iFrCntRef0++;
      if(b==2 || b==3)iFrCntRef0=0;
      //debugss("ret=",ret,b);
      if(0&&ret==0){
         iStart=1;
         static int iPrevGX[3];
         debugss("bit Dif X",(iBitGainX)>>3,(iBitGainX-iPrevGX[0])>>3);
         debugss("bit Dif X1",(iBitGainX1)>>3,(iBitGainX1-iPrevGX[1])>>3);
         debugss("bit Dif XNZ",(iBitGainXNZ)>>3,(iBitGainXNZ-iPrevGX[2])>>3);
         debugss("iBlockXCnt",iBlockXCnt,(1+iBitGainX1)*100/(1+iBlockXCnt));
         
         iPrevGX[0]=iBitGainX;
         iPrevGX[1]=iBitGainX1;
         iPrevGX[2]=iBitGainXNZ;
    //     testImgZ(pCur,pRef,w,h);
      }
//debugss("ep-0k",ret,b);
      return ret;
//return dctx->encF(pCur,pRef,w,h,q,pOut);
   }
#if 0
   if(b==4)b=3;

  // doVlcTest();
      //void decSizeXTimes(int cx, int cy, int iTimes, unsigned char *pIn, unsigned char *pOut);
      //void incSize2x(unsigned char *in, unsigned char *out, int cx, int cy);
  //    if(b==3)
   //return dctx->predKey(pCur,pRef,w,h,pOut,q);

      //return 0;
  //    decSizeXTimes(w,h,2,pRef,(unsigned char *)&dctx->img_ri[0]);
   //tt((unsigned char *)&dctx->img_ri[0],(unsigned char *)&dctx->img_ri[0],w,h);
    //  tt(pCur,pRef,w,h);
  // incSize2x((unsigned char *)&dctx->img2[0],pCur,w/2,h/2);
 // if(b!=3) return 0;
  // static 

  // static int iCntX=0;
   int aaa;
   //b=3;
   if(b==3){canSkip<1,0>(NULL,NULL,8,w*3,aaa,NULL,NULL);}
  // iCntX++;
   if(b!=2){
   //memcpy(pCur,pRef,w*h*3);
  // return 0;
   }
  // return 0;

//int stride=w*3;
//memcpy(pCur+w*h*3,pCur+w*(h-1)*3,stride);

   //   int qNext[3]={q,q,q};
   //if(qNext[b]>90)qNext[b]=90;else if(qNext[b]<6)qNext[b]=6;
   //--------------------------------------
//if(b!=3)return 0;
//b=2;
   //if(b==1)b=0;
//b=0;
//-----------<<<<<<<<<<<<<<<<<<<<<<<<<<
//b=2;
//b=2;
//b=3;

   //if(b==2 || b==1)b=0;
//if(b==1)return 0;
//   if(b==0)b=2;
   if(b==3 || b==2){iFrC=0;iFrCntRef0=1;}
   //if((iFrC&15)){
      if(decodeAllFramesParts()==3 && b==0)b=1;
   //}
    //if(b==2)b=0;
    //  if(b<2)b=2;
   //if(b<2)b=1;
//if(b==0)b=2;
      if(0&&b==0){
        dctx->iLowQval=iFrCntRef0&7;
        if(dctx->iLowQval){
           dctx->iLowQval=0;
           //dctx->iPrevQ=96;
         dctx->iIsKey=b==3;
         dctx->iIsReferenceFrame=b==2;
         int qThis=(dctx->iNextQ+76)/2;
         dctx->iIsB=0;//b==1;
         if(dctx->iIsKey || dctx->iIsReferenceFrame)qThis=q;
         //int ret2= dctx->encF(pCur,pRef,w,h,(dctx->iPrevQ+q+1-4)>>1,pOut);
         int ret2= dctx->encF(pCur,pRef,w,h,qThis,pOut);
         if(ret2==0)iFrC++;
         if(ret2==0 && b==0)iFrCntRef0++;
         return ret2;

        }
      }
      else dctx->iLowQval=0;
      //b=0;
   //if(b!=1)b=3;

   if(b==3){dctx->iIsKey=1;b=2;}else dctx->iIsKey=0;
 //b=2;
   if(0 && dctx->iIsKey){
      dctx->iIsKey=0;
      b=2;
      dctx->iEncPicOnly=2;
   }
   else dctx->iEncPicOnly=0;
   
   
//   dctx->iIsKey=0;

   //b=2;
   dctx->iIsB=dctx->iIsKey==0 && b==1;
  // if(dctx->iIsB)return 0;
   int iQIn=q;
   static int qPrev=q;
   if(b==1)q=qPrev;
   int l;
   //filterUV(pCur,w,h);
   if(!b)qPrev=iQIn;
 
   
   //dctx->iIsB=0;
   //b=2;//2;

  // return dctx->encode(pCur,pRef,w,h,iQIn,pOut,!b && !dctx->iIsKey?1:0);
#if 0
   static int iNextQ=iQIn;
   static int iFrSize;
   

   int qx=iNextQ;
   if(b==2){qx*=9;qx+=4;qx>>=3;}//+=4;
   l=dctx->encode(pCur,pRef,w,h,qx,pOut,b==1?0:1);

   static int last[24*4];
   
   
   static int iPrevIsNotNull;
   if((l==0 && iPrevIsNotNull) || (!iPrevIsNotNull && l==0)){
      iPrevIsNotNull=0;
      int sz=0;
      for(int i=0;i<24*4+1;i++){last[i]=last[i+1];sz+=last[i];}
      static int iFrameId;
      if(dctx->iIsKey)iFrSize>>=1;
      last[24*4]=iFrSize;sz+=iFrSize;
      

      iFrameId++;
      if(iFrameId>24 && b!=2 && (iFrameId&3)==0){// &&(iFrameId&3)==0){
         //if(iFrameId>24*16)sz>>=4;else 
         //if(iFrameId>24*8)sz>>=3;else
          if(iFrameId>24*4)sz>>=2;
         else if(iFrameId>48)sz>>=1;

         int lim=1500*24;//32000;//

         if(sz>lim*2)iNextQ-=8;//15
         else if(sz>lim)iNextQ-=4;
         else if(sz<((lim*31)>>5))iNextQ+=4;
         else if(sz<(lim>>2))iNextQ+=4;//8;

         if(iNextQ<16)iNextQ=16;
         if(iNextQ>96)iNextQ=96;

      }
      debugss("iNextQ",iNextQ,sz);
      
      iFrSize=0;
   }
   else iPrevIsNotNull=1;

   iFrSize+=l;
   return l;
#endif
  // return dctx->encTest(pCur,pRef,w,h,q,pOut,3000);
   //b=1;
   if((/*b==0 ||*/ b==2) && !dctx->iIsKey)
   {
      int qt=dctx->iPrevQ+8>=iQIn?(iQIn+4):iQIn;
      l=dctx->encode(pCur,pRef,w,h,qt,pOut,b==2?0:1);
   }
   else if(!b && !dctx->iIsKey)
   {
     // l=dctx->encode(pCur,pRef,w,h,dctx->iIsKey?iQIn:dctx->iPrevQ,pOut,1);
     l=dctx->encTest(pCur,pRef,w,h,q,pOut,3000);//,1);
   }
   else 
   {
      if(0){//dctx->iIsKey){
         static unsigned char *tmp;
         if(tmp==NULL){
            tmp=new unsigned char[w*h*3/4];
            //void decSizeXTimes(int cx, int cy, int iTimes, unsigned char *pIn, unsigned char *pOut);
            //decSizeXTimes(w,h,2,pRef,tmp);
         }
         l=dctx->encode(tmp,tmp,w/2,h/2,iQIn,pOut,1);
         if(l==0){delete tmp;tmp=NULL;}

      }
      else{
      //l=dctx->encode(pCur,pRef,w,h,q,pOut,1);
      
     // dctx->iEncValues=l=1;//
      //dctx->iPrevQ=80;
      int qt=dctx->iIsKey?iQIn:(dctx->iPrevIsLowQval? (dctx->iPrevQ-4):(dctx->iPrevQ-8));
      if(qt>iQIn)qt=iQIn;
      l=dctx->encode(pCur,pRef,w,h,qt,pOut,1);
      }
      
/*
      
      void decSizeXTimes(int cx, int cy, int iTimes, unsigned char *pIn, unsigned char *pOut);
      void incSize2x(unsigned char *in, unsigned char *out, int cx, int cy);
      decSizeXTimes(w,h,2,pRef,(unsigned char *)&dctx->img_ri[0]);
      //img_ri


      dctx->iIsKey=1;
      int q2=q+50;if(q2>90)q2=90;
      l=dctx->encode((unsigned char *)&dctx->img2[0],(unsigned char *)&dctx->img_ri[0],w/2,h/2,q2,pOut,1);
      incSize2x((unsigned char *)&dctx->img2[0],pCur,w/2,h/2);
      dctx->iIsKey=0;
      dctx->iSkipDct=0;
      dctx->iPrevQ=q;

      int z=dctx->iEncValues;
      l+=dctx->encode(pCur,pRef,w,h,dctx->iPrevQ>iQIn || dctx->iIsKey?iQIn:dctx->iPrevQ,pOut,1);
      dctx->iEncValues+=z;
      dctx->iSkipDct=0;
  */    
   }
      //void tblock(unsigned char *pic, int w, int h, int a, int b);
      //tblock(pCur,w, h,63,20);
   
/*
   int iLimit[2]={1200,300};
   int dif=ABS(dctx->iEncValues-iLimit[b]);
   if(dif*10>iLimit[b])
   {
      if(dctx->iEncValues<iLimit[b]){
         qNext[b]=((qNext[b]*17)>>4)+1;
         if(b && qNext[b]>qNext[!b])qNext[b]=qNext[!b];
      }
      else{
         qNext[b]=((qNext[b]*7)>>3)-1;
         if(!b && qNext[b]>qNext[!b]){qNext[b]=((qNext[!b]*3)>>2)-2;}
      }
   }
  */
   iGain=0;
   if(l==0)
   {
      if(b==0)debugss("bit2x2 gain ",b==0?dctx->iNextQ:0,dctx->iBitsGain2x2_test_better);
      iGain=dctx->iBitsGain2x2_test>>3;
      dctx->iBitsGain2x2_test_better=dctx->iBitsGain2x2_test=0;
   }
   else{
      //debugss("psnr sk send Y",dctx->iSStartSkipedPsnr[0],dctx->iBSendPsnr[0]);
      //debugss("psnr sk send UV",dctx->iSStartSkipedPsnr[1],dctx->iBSendPsnr[1]);

   }
   if(0 && l){
      dctx->iEncValues=l;
      char dd[128];
      sprintf(dd,"send %d, q=%d,KY=%d",l,dctx->iPrevQ,dctx->iKeyYLen);
      debugss(dd,-123456789, -123456789);
      //debugss("x",l,dctx->iEncValues);
      //if(b!=1)debugss("q,lim",dctx->iPrevQ,dctx->iPrevRefSize);
      //else if(b==2)debugss("ref,lim",iQIn,dctx->iPrevRefSize);
      //double getPSNR(unsigned char *p ,unsigned char *o, int w, int h, int step);int psnr=(int)getPSNR(pCur,pRef,w,h,3); debugss("psnr",psnr,0);
      /*
      int iLenR=dctx->iRangeLen*2+1024;
      rangeEncode(&dctx->img_ri[0],dctx->iRangeLen,(unsigned char *)&dctx->img2[0],iLenR);
      int iLenR2=encAritm((unsigned char *)&dctx->img2[0] ,&dctx->img_ri[0],dctx->iRangeLen);
      debugss("xr",iLenR+dctx->iSkipValues,iLenR2);
      */

      //debugss("lr",dctx->iMaxLev,dctx->iMaxLen);
   }

//memcpy(pCur,pRef,w*h*3);
#else
int l=0;
#endif
   
//   iGain=0;//l-dctx->iEncValues;
  // *(int*)&pOut[l]=l;//dctx->iEncValues;
/*
   if(l){
      unsigned char r=5;
      int zz;
      for(zz=0;zz<l;zz++)r+=pOut[zz];
      pOut[zz]=r;
      l++;

   }
  */ 
if(l==0)iFrC++;
if(l==0 && b==0)iFrCntRef0++;

   return l;
#endif
}
#if 0
int fillBlockV(unsigned char *pCur, unsigned char *pRef, int stride){
   unsigned char *rowT=pCur-stride;
   unsigned char *rowB=pCur+stride*16;
   int i,j;
   for(j=0;j<16;j++){
      int a=1;
      for(i=0;i<48;i+=3){
         int sqa=a*a;
         int x=(rowB[i]*(sqa)+rowT[i]*(256-sqa)+128)>>8;
         pCur[i]=x;
         a++;
      }
      pCur+=stride;
      pRef+=stride;
      
   }
   return 0;
}

int fillBlockH(unsigned char *pCur, unsigned char *pRef, int stride){
   int i,j;
   for(j=0;j<16;j++){
      int a=1;
      int iColL=pRef[-3];
      int iColR=pRef[48];
      for(i=0;i<48;i+=3){
         int sqa=a*a;
         int x=(iColR*(sqa)+iColL*(256-sqa)+128)>>8;
         pCur[i]=x;
         a++;
      }
      pCur+=stride;
      pRef+=stride;
      
   }
   return 0;
}

int fillBlockA(unsigned char *pCur, unsigned char *pRef, int stride){
   int i,j;
   int dc=0;
   pCur+=stride*12;
   pRef+=stride*12;
   for(j=12;j<16;j++){
      for(i=36;i<48;i+=3){
         pCur[i]=pRef[i];
         dc+=pCur[i];
      }
      pCur+=stride;
      pRef+=stride;

   }
   return dc>>4;
}
void fillBlockB(unsigned char *pCur, unsigned char *pRef, int stride){
int i,j;
int sqa,sqj;
   unsigned char *rowT=pRef-stride;
   unsigned char *rowB=pRef+stride*12;
   
   for(j=0;j<12;j++)
   {
      sqj=(j+1)*(j+1);
         for(i=36;i<48;i+=3){
            int x=(rowB[i]*(sqj)+rowT[i]*(144-sqj)+72)/144;
            pCur[i]=x;
         }
      
      pCur+=stride;
      pRef+=stride;
   }
   for(j=12;j<16;j++)
   {
      
         int iColL=pRef[-3];
         int iColR=pRef[36];
         int a=1;
         for(i=0;i<36;i+=3){
            sqa=a*a;
            int x=(iColR*(sqa) + iColL*(144-sqa)+72)/144;
            pCur[i]=x;
            a++;
         }
      
      pCur+=stride;
      pRef+=stride;
   }
   //int fillBlockA(unsigned char *pCur, unsigned char *pRef, int stride)
   fillBlockA(pCur-stride*4,pRef-stride*4,stride);
   fillBlockA(pCur-stride*8,pRef-stride*8,stride);
   fillBlockA(pCur-stride*12,pRef-stride*12,stride);

   fillBlockA(pCur-12,pRef-12,stride);
   fillBlockA(pCur-24,pRef-24,stride);
   fillBlockA(pCur-36,pRef-36,stride);
   
}

void fillBlockC(unsigned char *pCur, unsigned char *pRef, int stride){
   int i,j;
   
   unsigned char *rowT=pCur-stride;
   unsigned char *rowB=pCur+stride*12;
   for(j=0;j<12;j++)
   {
         int sqa,sqj;
         sqj=(j+1)*(j+1);
      
         int iColL=pCur[-3];
         int iColR=pCur[36];
         int a=1;
         for(i=0;i<36;i+=3){
            sqa=a*a;
            int x=(rowB[i]*(sqj)+rowT[i]*(144-sqj) +iColR*(sqa) + iColL*(144-sqa)+144)/288;
            pCur[i]=x;
            a++;
         }
      
      pCur+=stride;
      pRef+=stride;
   }
}

void fillBlockD(unsigned char *pCur, unsigned char *pRef, int stride, int dc){
   int i,j;
   
   unsigned char *rowT=pCur-stride;
   for(j=0;j<12;j++)
   {
         int sqa,sqj;
         sqj=(j+1)*(j+1);
      
         int iColL=pCur[-3];
         int a=1;
         for(i=0;i<48;i+=3){
            sqa=a*a;
            int x=(rowT[i]*(256-sqj) + iColL*(256-sqa)+256+dc*(sqj+sqa))>>9;
            pCur[i]=x;
            a++;
         }
      
      pCur+=stride;
      pRef+=stride;
   }
   for(j=12;j<16;j++)
   {
         int sqa,sqj;
         sqj=(j+1)*(j+1);
      
         int iColL=pCur[-3];
         int a=1;
         for(i=0;i<36;i+=3){
            sqa=a*a;
            int x=(rowT[i]*(144-sqj) + iColL*(144-sqa)+144+dc*(sqj+sqa))/288;
            pCur[i]=x;
            a++;
         }
      
      pCur+=stride;
      pRef+=stride;
   }
}
void testImgZ(unsigned char *pCur, unsigned char *pRef ,int w, int h){
   int i,j,stride=w*3;
   int idc=0;
   for(j=0;j<h;j+=16){
      for(i=0;i<w;i+=16,idc++){
         if((idc&1)==0)continue;
         if(i==0 || j==0)continue;
        // 
         /*
         fillBlockB(pCur+i*3, pRef+i*3,stride);
         fillBlockC(pCur+i*3, pRef+i*3,stride);
        // int dc=fillBlockA(pCur+i*3, pRef+i*3,stride);
         //fillBlockD(pCur+i*3, pRef+i*3,stride,dc);
         fillBlockA(pCur+i*3, pRef+i*3,stride);
         */
         fillBlockH(pCur+i*3,pRef+i*3,stride);
         int iSadH=::sadGainUU_16(pCur+i*3,pRef+i*3,stride,dctx->t_d1);;
         fillBlockV(pCur+i*3,pRef+i*3,stride);
         int iSadV=::sadGainUU_16(pCur+i*3,pRef+i*3,stride,dctx->t_d1);;
         if(iSadV>iSadH){
            fillBlockH(pCur+i*3,pRef+i*3,stride);
            fillBlockH(pCur+i*3+1,pRef+i*3+1,stride);
            fillBlockH(pCur+i*3+2,pRef+i*3+2,stride);
         }


      }
      pCur+=stride*16;
      pRef+=stride*16;
   }
}


#endif
#if 0
template <int iDec>
 static int fastT_enc_dec_skip(TDCTX *ed, unsigned char *pCur, unsigned char *pRef,int w, int h,int  iIsB){

//   int s;
   int stride=w*3;
   int i,j;//,xc,yc;
   int k,ofs;
//   int iCoefsOut,iMaxCoef;
   //xc=w/8;yc=h/8;
   //int sk=iDec?ed->vlc.getVlc():0;
   int iBitPos=ed->vlc.iBitPos;
   int iEnc=0;
   //static unsigned char *pRest=NULL;
  // if(!pRest && !iDec)pRest=new unsigned char [16000];

   iResetCnt=1;
   int iEncTmp;
   int iIsBigCost;
   int iBitsGain=0;
   int iIsKey=ed->iIsKey;
//   if(iDec && !iIsKey && !ed->iVisDecoder)return 0;
   
   int iIsHada=0;
   int iCheckNextNonDif=!iIsB;

   int id=0;
   int iHasQuant=0;
   iHasQuant=1;
   int aQ=16,bQ=32,cQ=64,uvQ=16;
   int iLossless=0;
   int iPosBeforeSkipID=0;
  
   int iCanRestore=1;
   
   if(iDec){
      ed->iDCQuant=ed->vlc.getVlc();
      iHasQuant=ed->vlc.getB();
      if(iHasQuant){
         aQ=ed->vlc.get_L_Val(3)*2;
         bQ=ed->vlc.get_L_Val(3)*2;
         cQ=ed->vlc.get_L_Val(3)*2;
         uvQ=ed->vlc.get_L_Val(2)*2;
         if(aQ>1500)return -3;
         if(bQ>3000)return -3;
         if(cQ>5000)return -3;
         if(uvQ>8000)return -3;
        // debugss("ab",aQ,bQ);
        // debugss("c-uv",cQ,uvQ);
      }
      //
      ed->iSkipId=ed->vlc.getVlc();
   }
   else{
      int qx=42-ed->iQParam;
      int iqxMax=42-ed->iMaxQParam;
      int qJ=6;
     // qx=37-ed->iQParam;
      

int iIsUDP=1;
      //qx=12;
      //qx=(102-ed->iQVal)>>1;
      int iDec_aQcQ=0;
      ed->iPrevWasKey=0;
      static int iPrevWasKey=0;
      if(ed->iIsB || ed->iThisWasB){
         iqxMax+=qJ/2;
         if(iPrevWasKey==1)iPrevWasKey=0;
         if(iPrevWasKey==3)iPrevWasKey=4;
//         qx+=7;
         qx+=qJ;
         if(qx<5)qx=5;
         if(qx>42)qx=42;
      }
      else  
      if(ed->iIsReferenceFrame ){
         if(iLastFrameDif>80){
         }
         else if(ed->iDecRefQ){
            qx-=1;
         }
         else{
         iDec_aQcQ=2;
         iqxMax-=2;
  
#if 1
         
         int iqxRem=qJ*3>qx?((qx)/3+1):(qJ-1);
         //if(iLastFrameDif && (ed->iFramesAfterKey>3 || iLastFrameDif>40)){iqxRem>>=1;iqxRem++;}

         if(iLastFrameDif>36)iqxRem-=4;
         if(iLastFrameDif>24)iqxRem-=3;
         else if(iLastFrameDif>12)iqxRem-=2;
         else if(iLastFrameDif>4)iqxRem-=1;
         if(iqxRem<2)iqxRem=2;
         //qx-=4;//
         qx-=iqxRem;
         
#endif
         }

         iPrevWasKey=0;
         //qx--;
         
         //qx-=4;
         if(qx<0)qx=0;
         if(qx>36)qx=36;
      }
      else if(ed->iIsKey){
         iqxMax+=2;

         if(iIsUDP){
            qx+=qJ;if(iLastFrameDif>40)qx+=(iLastFrameDif/10-2);
         }

         if(qx<16)qx=16;
         iPrevWasKey=2;
         if(qx>40)qx=40;

         //qx=24;
         
      }
      else if(iPrevWasKey &&  iLastFrameDif<8){

         
         if(iPrevWasKey==4 || iPrevWasKey==1){
            ed->iPrevWasKey=1;
            iPrevWasKey=1;
            iDec_aQcQ=1;
            if(qx<1)qx=1;
            iCanRestore=-1;
         }
         if(iPrevWasKey==2)iPrevWasKey=3;
         
         
         //??qx-=4;
         
      }
      else{
         if(qx<1)qx=1;
         if(qx>40)qx=40;
      }
      if(qx<iqxMax)qx=iqxMax;//rev qx=40-par;

      //if(qx<1)qx=1;aQ=48*(qx);bQ=102*qx;aQ>>=4;bQ>>=4; 

      //aQ=2;bQ=5;cQ=27;///max sq er 1
      //aQ=2;bQ=5;cQ=11;//er =0
     // bQ=32*5;
//      int iAQAdd=48;
      //int bQMinLim=ed->iIsReferenceFrame?16:24;
      //if(ed->iIsKey)bQMinLim=48;
     // bQMinLim*=32;
      /*
      for(int z=0;z<qx || bQMinLim>bQ;z++){
         bQ+=iAQAdd;
         if(z==1)bQ=32*12;
         else if(z==2)bQ=32*14;
         else if(z==3)bQ=32*16;
         iAQAdd+=9;//5
         if(iAQAdd>30*32)iAQAdd=30*32;
//         debugss("aQ",z,aQ>>5);
      }
      */
      //qx-=4;
      //const int qt[]={5,11,16,21,27,32};
     // static const int qt[]={5,11,16,22,27,32};
      bQ=(24*(6-(qx%6))+(qx%6)*48)*(1<<(qx/6));//(((2<<(qx/6)))*32+qt[qx%6]*(2<<(qx/6)))*3;
      //bQ=(25*(5-(qx%5))+(qx%5)*50)*(1<<(qx/5));
      //if(qx)bQ+=4*32;
//      const int qt[]={4,8,12,16,20,24,28,32};
  //    bQ=(((2<<(qx/8)))*32+qt[qx%8]*(2<<(qx/8)))*3;
      //const int qt[]={6,13,19,27,32};
      //bQ=(((2<<(qx/5)))*32+qt[qx%5]*(2<<(qx/5)))*3;
      if(ed->iIsKey && bQ<48*32)bQ=48*32;
      //if(ed->iIsKey && aQ<20*32)bQ=20*32;
      //if(bQ>300*32){bQ+=300*32;bQ>>=1;}
      //if(bQ>700*32){bQ+=700*32;bQ>>=1;}
      //if(bQ>1000*32){bQ+=1000*32;bQ>>=1;}
      //aQ=bQ/2.2;aQ>>=5;//silent labaaks
      
      aQ=bQ/1.875;aQ>>=5;bQ>>=5;
      //aQ=bQ/2.3;aQ>>=5;bQ>>=5;
      //aQ=bQ>>6;bQ>>=5;
      
      //aQ=bQ;bQ=aQ*1.875;bQ>>=5;aQ>>=5;
      
      
      if(iIsB && !ed->iSkipId){
//         for(int z=0;z<42;z++)debugss("z",z,(24*(6-(z%6))+(z%6)*48)*(1<<(z/6))>>5);
            
         
      }
      
      
      
      //aQ=4;bQ=8;cQ=10;
   //   debugss("aQ1",aQ,bQ);
//#endif 
//bQ=800;
      //ed->iDCQuant=((iHasQuant?aQ:ed->tab_y[128]))>>1;
      //if(!ed->iIsKey)if(aQ>24){aQ*=7;aQ+=24;aQ>>=3;}
      if(ed->iIsB || ed->iThisWasB){
         if(ed->iThisWasB)
            aQ+=48;
         else{
            aQ+=32;
            if(aQ<64)aQ=64;
         }
         bQ=aQ*2.229;
         bQ&=~3;
         aQ&=~3;
      }

      //TODO if is live max q bQ=45;aQ=bQ/2.3; cQ=bQ*3;
      //TODO if is live skip frames 80 ms  after key

      
      if(iDec_aQcQ==2){
         // aQ=bQ/2.3;

//          bQ=aQ*2;
//bQ=aQ*2;
      }
      else if(iIsUDP && !iIsB && ed->iPrevWasKey==1){
         //aQ*=6;aQ>>=3;bQ=aQ*1.5;     cQ=bQ*2;
        // aQ=bQ/2.3;
         
         // {aQ*=7;aQ>>=3;};//aQ-=4;   //bQ=aQ*2.1;  cQ=bQ*2;
          //aQ=bQ/3;
        // bQ=aQ*1.2;cQ=bQ*1.5;
      }
      else if(ed->iIsKey && iIsUDP){
         if(bQ<168)bQ=168;
//--------bQ=128;
         aQ=bQ/2.235;
         cQ=bQ*1.8+30;
         if(cQ&1)cQ--;
#ifdef T_USE_PRED16
         aQ=bQ/2.2;
         cQ=bQ*1.8+20;
#endif
    
      }
      else if(ed->iIsKey){
         aQ=bQ/2.2;
         cQ=bQ*1.8+20;
         if(cQ&1)cQ--;
      }
     //--- if(!ed->iIsKey && !ed->iIsB && !ed->iThisWasB)cQ=bQ*1.8+16;
      //if(!ed->iThisWasB && !iIsB)aQ=bQ/2.3;
     // cQ=bQ*2.1;
      //25700,46
      if(!ed->iIsKey){
         cQ=bQ*2.23;cQ=aQ*5;
         cQ=bQ*1.8+20;
         //if(bQ*2.1<cQ)cQ=bQ*2.1;

      }
      
      
      if(aQ<2)aQ=2;
      if(bQ<4)bQ=4;
      if(cQ<22)cQ=22;

      int uvB=ed->iIsB|ed->iThisWasB;

      uvQ=24+(uvB*64); 


      if(uvQ+aQ<144+uvB*72)uvQ=144+uvB*72-aQ;
      
      //uvQ+=16;
      if(uvQ+aQ>256+uvB*96){
         uvQ=256+uvB*96-aQ;
      }
      if(uvQ<uvB*64+64)uvQ=uvB*64+64;
      uvQ*=7; uvQ+=aQ;uvQ>>=3;
     // uvQ*=5;uvQ>>=2;
      if(ed->iIsKey && uvQ<128)uvQ=128;
     // uvQ=256;
//uvQ=aQ;
      

      //bQ=40;aQ=18;cQ=88;

      if(iHasQuant){
         if(aQ&1){
            if(bQ&1)bQ++;else bQ+=2;
         }
         else if(bQ&1){ cQ+=3;}
         aQ&=~1;cQ&=~1;bQ&=~1;
         uvQ&=~3;
      }
      if(aQ==2 && bQ==4)cQ=12;//LL
      else if(aQ==4 && bQ==4){aQ=2;cQ=22;}
      else if(aQ==4 && bQ==6)cQ=22;
      else if(aQ==6 && bQ==6)cQ=22;
      else if(aQ==4 && bQ==8)cQ=22;
      else if(aQ==6 && bQ==8)cQ=24;

  //--    if(ed->iIsReferenceFrame){aQ=12;bQ=26;cQ=60;}else if(ed->iIsB || ed->iThisWasB){aQ=48;bQ=105;cQ=240;}else {aQ=16;bQ=36;cQ=80;}
      

      /*
      else if(bQ>=8 && aQ>6 && bQ>60){
         cQ+=12;
         cQ/=25;cQ*=25;
         if(!cQ)cQ=12;else{
            if(cQ==25)cQ=22;
            else if(cQ==50)cQ-=4;
            else if(cQ==75)cQ-=9;
            else if(cQ==100)cQ-=12;
            else cQ-=15;//4=~ 25/6
         }
         //if(cQ<bQ*1)cQ+=25;
         cQ&=~1;
      }
      */

      
//aQ=8;bQ=16; cQ=32;
//(q=26),  52,  17   80,  26   80,  26  125,  41
      //aQ=52;bQ=80;cQ=125;
      //aQ=bQ*52/80;      cQ=bQ*125/80; //264
      //aQ=bQ*52/80;      cQ=bQ*125/80; //264
    //  aQ/=2;bQ/=2;cQ/=2;
//      aQ=80/2.4;bQ=80;cQ=bQ*2.5;
//bQ=aQ*1.37;cQ=aQ*1.8;
      //aQ=60;bQ=128;cQ=bQ*2.3;
      if(!ed->iIsKey){
         //to*1.5
//(t0*2+dcq)/2+128=t0,t0/2+dcq/2+128=t0, dcq=2*to-to-256
     //??--    if(iIsB){ed->iDCQuant=aQ*2-aQ-256;}else ed->iDCQuant=aQ*2;
//(t0*4+dcq)/4+128=t0*2,t0+dcq/4+128=t0*2, dcq=(to-128)*4

         //aQ=bQ/3;if(iIsB){ed->iDCQuant=aQ*4-512;}else ed->iDCQuant=aQ*4;
//(t0*4+dcq)/4+128=t0*1.5,t0+dcq/4+128=t0*1.5, dcq=(0.5to-128)*4
//--         if(iIsB){ed->iDCQuant=aQ*2-512;}else ed->iDCQuant=aQ*2;
         if(iIsB){ed->iDCQuant=aQ*2-512;}else ed->iDCQuant=bQ;
//(6*6-512)/4+128==6*1.5
         if(ed->iDCQuant<12 && aQ<8)ed->iDCQuant>>=1;
        
         ed->iDCQuant-=((aQ>>2)+(aQ>>3));
         
         //if(ed->iDCQuant>32){ed->iDCQuant+=32;ed->iDCQuant>>=1;}
         
      }
      else{
#ifdef T_USE_PRED16
         ed->iDCQuant=(aQ*(iIsUDP?3:2))>>1;// *2;//bQ*2;//aQ*2;//var aQ*12
#else
          ed->iDCQuant=aQ*(iIsUDP?12:12);
#endif
      }
      //if(!ed->iIsB && ed->iDCQuant<8)ed->iDCQuant=8;
      
      //?? if(!ed->iIsKey)ed->iDCQuant>>=1;
     //if(ed->iIsReferenceFrame)ed->iDCQuant=0;//
//??     if(!ed->iIsKey)ed->iDCQuant<<=1;
      //if(ed->iIsReferenceFrame)uvQ=16;else uvQ=32+(ed->iIsB*32);   if(uvQ+bQ<90+iIsB*60)uvQ=90+iIsB*60-bQ;
      if(ed->iDCQuant<0)ed->iDCQuant=0;

      if(ed->iIsKey){
         int dcqO=ed->iDCQuant;
         int iF=0;
         if(dcqO>128){
            int dcq;
            for(int z=0;z<18;z++){
               ed->iDCQuant=dcqO+z;
                  dcq=(aQ*3+ed->iDCQuant)>>2;
                  dcq++;dcq&=~1;
                  if((dcq&7)==0){iF=1;ed->iDCQuant=dcqO+z;break;}
               ed->iDCQuant=dcqO-z;
               if(ed->iDCQuant>=0){
                  dcq=(aQ*3+ed->iDCQuant)>>2;
                  dcq++;dcq&=~1;
                  if((dcq&7)==0){iF=1;ed->iDCQuant=dcqO-z;break;}
               }
            }
         }
         if(!iF){
            int dcq;
            for(int z=0;z<6;z++){
               ed->iDCQuant=dcqO+z;
                  dcq=(aQ*3+ed->iDCQuant)>>2;
                  dcq++;dcq&=~1;
                  if((dcq&3)==0){ed->iDCQuant=dcqO+z;iF=1;break;}
               ed->iDCQuant=dcqO-z;
               if(ed->iDCQuant>=0){
                  dcq=(aQ*3+ed->iDCQuant)>>2;
                  dcq++;dcq&=~1;
                  if((dcq&3)==0){ed->iDCQuant=dcqO-z;iF=1;break;}
               }
            }
         }

      }
      else{
         int dcqO=ed->iDCQuant;
         int dcq;
         for(int z=0;z<12;z++){
            ed->iDCQuant=dcqO+z;
            dcq=(aQ*4+ed->iDCQuant+8)>>2;
            dcq++;dcq&=~1;
            if((dcq&7)==0){ed->iDCQuant=dcqO+z;break;}
            if(ed->iDCQuant>=0){
            ed->iDCQuant=dcqO-z;
            dcq=(aQ*4+ed->iDCQuant+8)>>2;
            dcq++;dcq&=~1;
            if((dcq&7)==0){ed->iDCQuant=dcqO-z;break;}
            }
         }
      }
      
      if(iHasQuant){
         if(aQ&1){
            if(bQ&1)bQ++;else bQ+=2;
         }
         else if(bQ&1){ cQ+=3;}
         aQ&=~1;cQ&=~1;bQ&=~1;
         uvQ&=~7;
      }
      if(ed->iDCQuant<0)ed->iDCQuant=0;

      if(ed->iIsKey){
         int dcqO=ed->iDCQuant;
         int iF=0;
         if(dcqO>128){
            int dcq;
            for(int z=0;z<18;z++){
               ed->iDCQuant=dcqO+z;
                  dcq=(aQ*3+ed->iDCQuant)>>2;
                  dcq++;dcq&=~1;
                  if((dcq&7)==0){iF=1;break;}
               ed->iDCQuant=dcqO-z;
               if(ed->iDCQuant>=0){
                  dcq=(aQ*3+ed->iDCQuant)>>2;
                  dcq++;dcq&=~1;
                  if((dcq&7)==0){iF=1;break;}
               }
            }
         }
         if(!iF){
            int dcq;
            for(int z=0;z<6;z++){
               ed->iDCQuant=dcqO+z;
                  dcq=(aQ*3+ed->iDCQuant)>>2;
                  dcq++;dcq&=~1;
                  if((dcq&3)==0){iF=1;break;}
               ed->iDCQuant=dcqO-z;
               if(ed->iDCQuant>=0){
                  dcq=(aQ*3+ed->iDCQuant)>>2;
                  dcq++;dcq&=~1;
                  if((dcq&3)==0){iF=1;break;}
               }
            }
         }

      }
      else{
         int dcqO=ed->iDCQuant;
         int dcq;
         for(int z=0;z<12;z++){
            ed->iDCQuant=dcqO+z;
            dcq=(aQ*4+ed->iDCQuant+8)>>2;
            dcq++;dcq&=~1;
            if((dcq&7)==0){break;}
            if(ed->iDCQuant>=0){
            ed->iDCQuant=dcqO-z;
            dcq=(aQ*4+ed->iDCQuant+8)>>2;
            dcq++;dcq&=~1;
            if((dcq&7)==0){break;}
            }
         }
      }

      if(ed->iDCQuant<0)ed->iDCQuant=0;
      ed->vlc.toVLC(ed->iDCQuant);
      ed->vlc.addB(iHasQuant);

      if(iHasQuant){
         /*
         if(aQ&1){
            if(bQ&1)bQ++;else bQ+=2;
         }
         else if(bQ&1){cQ+=3;}
         aQ&=~1;cQ&=~1;bQ&=~1;
         uvQ&=~1;
         */
         ed->vlc.toL_Val(aQ>>1,3);
         ed->vlc.toL_Val(bQ>>1,3);
         ed->vlc.toL_Val(cQ>>1,3);
         ed->vlc.toL_Val(uvQ>>1,2);
         
      }
      //
      iPosBeforeSkipID=ed->vlc.iBitPos;
      ed->vlc.toVLC(ed->iSkipId);
     // debugss("aQ3",aQ,bQ);
   }
   
   if(iHasQuant){
     //--- if(aQ<8)debugss("aQ",aQ,iHasQuant);
      initQ4x4(&ed->tab_y[0], 0 , iIsB, aQ,bQ, cQ);
      if(!ed->iIsReferenceFrame && !iDec && !ed->iIsKey)initQ4x4_SkipLast(&ed->tab_y_b[0],iIsB|ed->iThisWasB, aQ,bQ, cQ);
      initQ4x4(&ed->tab_uv[0], 1 , iIsB, aQ+uvQ,bQ+uvQ, cQ+uvQ);
   }
   if(!iDec){
      if(!iIsB && ed->iSkipId==0){
         //debugss("aQ,bQ",aQ,bQ);
         //debugss("cQ,uvQ",cQ,uvQ);
      }
      if(ed->iSkipId==0){
         ed->iLastYBits=0;
      }
      ed->initTabSK();
      ed->calc4x4SQErr();
      while(ed->vlc.iBitPos&7)ed->vlc.addB(1);
   }
   else{
      ed->vlc.iBitPos+=7;ed->vlc.iBitPos>>=3;ed->vlc.iBitPos<<=3;//byteAlign
   }
   int iPosToEncodedCnt=ed->vlc.iBitPos;

   if(iDec){
      iEnc=ed->vlc.pBitBuf[iPosToEncodedCnt>>3]<<8;
      iEnc+=ed->vlc.pBitBuf[(iPosToEncodedCnt>>3)+1];
      
   }

   ed->vlc.iBitPos+=16;
   
   int iSkiped=0;
   ENC_BL_CTX ctx;
   ctx.h=h;
   ctx.w=w;
   ctx.mb=NULL;
   int iUseDct8x8=0;
   static int iUse8x8=0;
   static int iCheckPic=1;

   static int iPrevWorstPsnr[3];
   if(!iDec && ed->iSkipId==0){
      //debugss("abc",aQ,bQ);      debugss("c-dc",cQ,ed->iDCQuant);
      if(!iIsB){
         iUse8x8++;
         iCheckPic=!iCheckPic;
         if(iUse8x8==3)iUse8x8=0;
         if(ed->iIsReferenceFrame){iUse8x8=0;iCheckPic=1;}
         if(ed->iIsKey){iCheckPic=1;}
      }
      ctx.iThisWorstPsnr[0]=4400;
      ctx.iThisWorstPsnr[1]=4400;
      ctx.iThisWorstPsnr[2]=4400;
      ctx.iWorstPsnr[0]=iPrevWorstPsnr[0];
      ctx.iWorstPsnr[1]=iPrevWorstPsnr[1];
      ctx.iWorstPsnr[2]=iPrevWorstPsnr[2];
   }
   int iLastNBit=0;
   const int iBlocksPerRow=w>>4;
   

   
   for(k=0;k<3;k++){
      //if(iDec && k)break;
      ed->iPredDC=0;
      if(iDec && ed->vlc.getB()){

         id+=(h>>4)*(w>>4);
         continue;
      }
      if(!iDec)ed->vlc.addB(0);

      int iBitPosK=ed->vlc.iBitPos;

//iIsKey=1;
      if(!iDec)iIsHada=iLossless || (((ed->iIsReferenceFrame && iLastFrameDif<30)|| iLastFrameDif<10) && !k && !iIsKey);;
      iUseDct8x8=0;//!iIsHada && k ?iUse8x8:0;if(iLastFrameDif>70-(iIsB|ed->iThisWasB)*20){iUseDct8x8=1;iIsHada=0;}
//      iUseDct8x8=k?1:0;
      iIsHada=k==0;// && !iIsKey;// && iLastFrameDif<80;
  //    iUseDct8x8=iUse8x8;if(iUse8x8)iIsHada=0;
      if(iIsHada && iUseDct8x8)iUseDct8x8=0;
      if(k){iUseDct8x8=2;iIsHada=0;}
#ifdef T_USE_PRED16
      if(ed->iIsKey){iIsHada=1;iUseDct8x8=0;}

#endif 
      //--??--iIsHada=1;iUseDct8x8=0;
      if(iDec)iIsHada=ed->vlc.getB();
      else ed->vlc.addB(iIsHada);

      if(iDec){
         iUseDct8x8=ed->vlc.getVlc();
         if(iUseDct8x8>2)return -5;
      }
      else ed->vlc.toVLC(iUseDct8x8);
      ctx.iIsHada=iIsHada;

      int iSkipedCnt=0;

//      int iMaxDifBitsChk=iIsHada?120:180;


      iEncTmp=iEnc;
      iLastNBit=ed->vlc.iBitPos;
if(!iDec && !iIsKey )ed->vlc.toVLC(iSkipedCnt);
else if(iDec && !iIsKey)iSkipedCnt=ed->vlc.getVlc();
     int idc=0;   
      for(j=0;j<h-15;j+=16){
         //ofs=j*w*3+(k?(k==2?(k+3):(k-3)):k);
         ofs=j*w*3+k;
         for(i=0;i<w-15;i+=16,ofs+=48,id++,idc++){
      //      if(idc&1)continue;
            //if(i==0 || j==0 || j+16>=h || i+16>=w)continue;
            ctx.i=i;ctx.j=j;
            ctx.iIsPic=0;
            
            if(iDec){
               if(id<ed->iSkipId)continue;
               int r;
               if(iIsKey){
                  iEnc--;
                  /*
#ifdef T_USE_PRED16
                  if(k==0)pred16Key<iDec>(&ctx,ed,pCur+ofs,pRef+ofs, stride);
if(ed->vlc.getB())continue;                  
#endif
*/
                  if(iIsHada)r=encMB16<iDec,1>(&ctx,ed,pCur+ofs,pRef+ofs, stride,k,iIsB,0,iIsBigCost);
                  else  r=encMB16_DCT<iDec,1>(&ctx,ed,pCur+ofs,pRef+ofs, stride,k,iIsB,0,iIsBigCost);
                  if(r<0)return r;
                  if(iEnc==0){
                     i=w;j=h;k=3;
                     break;
                  }
                  continue;
               }
               //--if(ed->vlc.getB())continue;

               if(iSkipedCnt){
                  iSkipedCnt--;
                  continue;
               }               
  
               iEnc--;
               
               if(!iIsB && ed->vlc.getB()){
                  if(iIsHada){
                     r=encMB16<iDec,1>(&ctx,ed,pCur+ofs,pRef+ofs, stride,k,iIsB,0,iIsBigCost);
                  //   if(k==1)encMB16<iDec,1>(ed,pCur+ofs+1,pRef+ofs+1, stride,k+1,iIsB,0,iIsBigCost);
                  }
                  else {
                     r=encMB16_DCT<iDec,1>(&ctx,ed,pCur+ofs,pRef+ofs, stride,k,iIsB,0,iIsBigCost);
                    // if(k==1)encMB16_DCT<iDec,1>(ed,pCur+ofs+1,pRef+ofs+1, stride,k+1,iIsB,0,iIsBigCost);
                  }
               }
               else{ 
                  if(iUseDct8x8==1 || (iUseDct8x8==2 && ed->vlc.getB()))
                     r=encMB16_DCT<iDec,0>(&ctx,ed,pCur+ofs,pRef+ofs, stride,k,iIsB,0,iIsBigCost);
                  else
                     r=encMB16<iDec,0>(&ctx,ed,pCur+ofs,pRef+ofs, stride,k,iIsB,0,iIsBigCost);
               }
               if(r<0)return r;

               if(iEnc==0){
                  i=w;j=h;k=3;
                  break;
               }
               iSkipedCnt=ed->vlc.getVlc();

            }
            else {
               if(id<ed->iSkipId)  continue;

               if(ed->vlc.getBytePos()>ed->iPartLimitSize){
                  i=w;j=h;k=3;
                  ed->iSkipId=id;
                  iSkiped=1;
               //   if(!iIsKey){ed->vlc.iBitPos=iLastNBit;ed->vlc.toVLC(iSkipedCnt);}
                  break;
               }
               ctx.mb=&ed->mb16_2[idc];
               if(iIsKey){
                  iEnc++;
                  /*
#ifdef T_USE_PRED16
if(k==0)pred16Key<iDec>(&ctx,ed,pCur+ofs,pRef+ofs, stride);
int e;
int iBPos=ed->vlc.iBitPos;
ed->vlc.addB(0);
#endif            
*/
                  if(iIsHada) encMB16<iDec,1>(&ctx,ed,pCur+ofs,pRef+ofs, stride,k,iIsB,0,iIsBigCost);
                  else  encMB16_DCT<iDec,1>(&ctx,ed,pCur+ofs,pRef+ofs, stride,k,iIsB,0,iIsBigCost);
                  /*
#ifdef T_USE_PRED16
if(!e){ed->vlc.iBitPos=iBPos;ed->vlc.addB(1);}
#endif
*/
                  iLastNBit=ed->vlc.iBitPos;
                  continue;
               }
 
               int iBPos=ed->vlc.iBitPos;
               //----ed->vlc.addB(0);
               int iBitPosAfterSkip=ed->vlc.iBitPos;
               
               {
                  if(!iIsB)ed->vlc.addB(0);
                  int e;
                  int iDev=-1;
                  int iUVMode=5;
                  ctx.iHasUVMode=0;
                  if(iUseDct8x8==2 && k){
                     iUVMode=getUVMode(&ctx,ed, pCur+ofs, pRef+ofs, stride, k, iIsB);
                  }
                  else if( iUseDct8x8==2){
                     iDev=getMBParamDev(i>>3, j>>3, w);
                  }
                  if(iUVMode!=5){
                     int iPrevUVM=iUVMode;
                     
                     if(iUVMode==4){
                        //pRest[idc]=0;
                        ctx.mb->col[k].iType=MB16_2::eDif4x4;
                        pEncStat->iBlocksDifSent[k]++;
                        iEnc++;
                        iSkipedCnt=0;
                        iLastNBit=ed->vlc.iBitPos;ed->vlc.toVLC(iSkipedCnt);
                        ctx.mb->col[k].iSkip=MB16_2::eNotSkiped;
                        setSkip_STAT(ctx.i>>4,ctx.j>>4,k,ctx.w,ctx.mb->col[k].iSkip);
                        continue;
                     }
                     if(iUVMode==1){
                        ed->vlc.addB(0);//iUseDct8x8
                        e=encMB16<iDec,0>(&ctx,ed,pCur+ofs,pRef+ofs, stride,k,iIsB,1,iIsBigCost);
                       // debugss("muv1",k,e);
                        if(e==0)iUVMode=0;
                        else if(e==7)iUVMode=3;
                        else{
                           ctx.mb->col[k].iType=MB16_2::eDif4x4;
                           pEncStat->iBlocksDifSent[k]++;
                        }
                     }
                     else if(iUVMode==2){
                        ed->vlc.addB(1);//iUseDct8x8
                        e=encMB16_DCT<iDec,0>(&ctx,ed,pCur+ofs,pRef+ofs, stride,k,iIsB,1,iIsBigCost);
                   //     debugss("muv2",k,e);
                        if(e==0)iUVMode=0;
                        else if(e==7)iUVMode=3;
                        else{
                           pEncStat->iBlocksDifSent[k]++;
                           ctx.mb->col[k].iType=MB16_2::eDif4x4;
                        }
                     }
                     if(iUVMode==3){
                     //   debugss("muv3",k,e);
                        ed->vlc.iBitPos=iBitPosAfterSkip;//iBPos+1;
//                        int tmp=ed->vlc.iBitPos;
                        ed->vlc.addB(1);
                        if(iIsHada) e=encMB16<iDec,1>(&ctx,ed,pCur+ofs,pRef+ofs, stride,k,iIsB,0,iIsBigCost,0);
                        else  e=encMB16_DCT<iDec,1>(&ctx,ed,pCur+ofs,pRef+ofs, stride,k,iIsB,0,iIsBigCost,0);
                        ctx.mb->col[k].iType=MB16_2::ePic4x4;
                        pEncStat->iBlocksPicSent[k]++;
                     }
                     if(iUVMode==0){
                        //debugss("muv0",k,e);
                        ed->vlc.iBitPos=iBPos;
                        
                        int iTr2=0;
                        
                        if((ctx.iHasUVMode && ctx.iDCDifAbs>2+iIsB) && iPrevUVM==2){
                        //   ed->vlc.addB(0);
                           if(!iIsB)ed->vlc.addB(0);
                           iTr2=tryEncDCOnly(ctx.iDCDif,&ctx,ed,pCur+ofs, pRef+ofs,stride,k,iIsB);
                           if(iTr2==0)ed->vlc.iBitPos=iBPos;
                        }
                        
                        if(iTr2==0){
                           //----ed->vlc.addB(1);
                           iCheckNextNonDif=0;
                           iSkipedCnt++;ed->vlc.iBitPos=iLastNBit;ed->vlc.toVLC(iSkipedCnt);
                           

                           ctx.mb->col[k].iType=MB16_2::eSkiped;
                           setSkip_STAT(ctx.i>>4,ctx.j>>4,k,ctx.w,ctx.mb->col[k].iSkip);
                           continue;
                        }
                     }
                     iSkipedCnt=0;
                     iEnc++;
                     //pRest[idc]=0;
                     iLastNBit=ed->vlc.iBitPos;ed->vlc.toVLC(iSkipedCnt);
                     ctx.mb->col[k].iSkip=MB16_2::eNotSkiped;
                     setSkip_STAT(ctx.i>>4,ctx.j>>4,k,ctx.w,ctx.mb->col[k].iSkip);
                     continue;
                  }
                  //
                  if(iUseDct8x8==1 || (iDev!=-1 && iDev<(k?16000:4000))){
                     if(iUseDct8x8==2)ed->vlc.addB(1);
                     e=encMB16_DCT<iDec,0>(&ctx,ed,pCur+ofs,pRef+ofs, stride,k,iIsB,1,iIsBigCost);
                  }
                  else{
                     ctx.iUVPsnr=0;
                     if(iUseDct8x8==2)ed->vlc.addB(0);
                     e=encMB16<iDec,0>(&ctx,ed,pCur+ofs,pRef+ofs, stride,k,iIsB,iCanRestore, iIsBigCost);
                     /*
                     if(e==0 && (!ed->iIsB || ed->iThisWasB)){
                        if(ctx.iUVPsnr && (iLastFrameDif && ctx.iUVPsnr<::iLastFrameDif-ed->iThisWasB*200-200))
                           e=7;
                     }
                     */
                  }
                //  if(k==1)pRest[id]=e;
                  if(!e){
                     ed->vlc.iBitPos=iBPos;
                     //----ed->vlc.addB(1);
                     //if(k==0)pRest[idc]=5;
                     //else if(k==1 && pRest[idc]==5)pRest[idc]=6;
                     //else pRest[idc]=0;
                     iCheckNextNonDif=0;
                     ctx.mb->col[k].iType=MB16_2::eSkiped;
                     iSkipedCnt++;ed->vlc.iBitPos=iLastNBit;ed->vlc.toVLC(iSkipedCnt);
                  }
                  else {
                     iSkipedCnt=0;
                     ctx.mb->col[k].iSkip=MB16_2::eNotSkiped;
                     ctx.mb->col[k].iType=MB16_2::eDif4x4;
                     int iUV=k?1:0;
                     //pRest[idc]=0;
                     iEnc++;
                     int iDifBits=ed->vlc.iBitPos-iBPos;
                     static int iAvgDifBits16[2];
                     static int iAvgPicBits2[2];
                     if(e==7){
                        
                        ed->vlc.iBitPos=iBitPosAfterSkip;
                        int tmp=ed->vlc.iBitPos;
                        ed->vlc.addB(1);
                        if(iIsHada) e=encMB16<iDec,1>(&ctx,ed,pCur+ofs,pRef+ofs, stride,k,iIsB,0,iIsBigCost,0);
                        else  e=encMB16_DCT<iDec,1>(&ctx,ed,pCur+ofs,pRef+ofs, stride,k,iIsB,0,iIsBigCost,0);
                        pEncStat->iBlocksPicSent[k]++;
                        ctx.mb->col[k].iType=MB16_2::ePic4x4;
                        iCheckNextNonDif=1;
                        int iPicBits=ed->vlc.iBitPos-tmp;
                        iAvgPicBits2[iUV]*=7;iAvgPicBits2[iUV]+=iPicBits;iAvgPicBits2[iUV]>>=3;
                        if(iAvgDifBits16[iUV]>iPicBits)iAvgDifBits16[iUV]=iPicBits;
                     }
                     else{
                        pEncStat->iBlocksDifSent[k]++;
                        if(!iCheckNextNonDif && idc>=iBlocksPerRow && ctx.mb[-iBlocksPerRow].col[k].iType==MB16_2::ePic4x4)iCheckNextNonDif=1;
                        if((ed->iIsFirstPass  && !iIsB && (iIsBigCost || (k && iCheckNextNonDif)))){
                           int tmp=ed->vlc.iBitPos;
                           //e=encMB16_DCT<iDec,1>(ed,pCur+ofs,pRef+ofs, stride,k,iIsB,0,iIsBigCost);
                           //debugss("test pic",k*10000+iDifBits,ctx.mb[0].col[k].iStartPsnr);
                           if(iIsHada){
                              int sz=iDifBits;//((iDifBits*14+ed->iIsReferenceFrame*8)>>4)+(ed->iIsReferenceFrame?(k?15:40):8);
                              //if(iIsBigCost)sz+=(k?8:25);
                              //if(iDifBits>sz+60)sz=iDifBits+60;
                              e=encMB16<iDec,1>(&ctx,ed,pCur+ofs,pRef+ofs, stride,k,iIsB,0,iIsBigCost,sz);

                           }else  e=encMB16_DCT<iDec,1>(&ctx,ed,pCur+ofs,pRef+ofs, stride,k,iIsB,0,iIsBigCost,((iDifBits*3+ed->iIsReferenceFrame+iUseDct8x8*4)>>3)+8);
                           iCheckNextNonDif=0;
                           if(e>0){
                              int iPicBits=ed->vlc.iBitPos-tmp;
                              if(iAvgDifBits16[iUV]>iPicBits)iAvgDifBits16[iUV]=iPicBits;
                              iAvgPicBits2[iUV]+=iPicBits;iAvgPicBits2[iUV]>>=1;
                              iCheckNextNonDif=iPicBits<(iDifBits+20);
                              ed->vlc.iBitPos=iBitPosAfterSkip;
                              ed->vlc.addB(1);
                              int z=0;
                              //if(!k)debugss("bits-Y",iPicBits,iDifBits);          else debugss("bits-UV",iPicBits,iDifBits);
                              ctx.mb->col[k].iType=MB16_2::ePic4x4;
                              /// TODO vlc.addBFrom(int pos);
                              for(z=0;z<iPicBits;z++){ed->vlc.addB(ed->vlc.showBit(tmp));tmp++;}
                              iDifBits=iPicBits;
                              pEncStat->iBlocksPicSent[k]++;
                              pEncStat->iBlocksDifSent[k]--;
                              

                              if(k==1){
                                // pRest[id]=2;
                              }
                              //encMB16<iDec,1>(ed,pCur+ofs,pRef+ofs, stride,k,iIsB,k<2 || (k==2 && pRest[id]),iIsBigCost);
                           }
                           else ed->vlc.iBitPos=tmp;
                        }
                        if(ctx.mb->col[k].iType!=MB16_2::ePic4x4){
                           iAvgDifBits16[iUV]*=15;iAvgDifBits16[iUV]+=iDifBits+8;iAvgDifBits16[iUV]>>=4;
                        }
                     }
                     pEncStat->iAvgSize[k]+=iDifBits;

                     iLastNBit=ed->vlc.iBitPos;ed->vlc.toVLC(iSkipedCnt);

                        

                  }
                  if(!iDec){
                     setSkip_STAT(ctx.i>>4,ctx.j>>4,k,ctx.w,ctx.mb->col[k].iSkip);
                  }
               }
               
            }
            
         }
      }
      if(!iDec && iEncTmp==iEnc){
         ed->vlc.iBitPos=iBitPosK-1;
         ed->vlc.addB(1);
      }
      if(!iDec){
         //debugss("encC",k,(ed->vlc.iBitPos-iBitPosK+7)>>3);
      //   if(iBitsGain>0)debugss("gain -----",(iBitsGain+7)>>3,0);
         iBitsGain=0;
      }
   }
   
   if(!iDec && !iEnc){ed->vlc.iBitPos=iBitPos;ed->iSkipId=0;}
   if(!iDec){
      ed->vlc.pBitBuf[iPosToEncodedCnt>>3]=(iEnc>>8);
      ed->vlc.pBitBuf[(iPosToEncodedCnt>>3)+1]=iEnc-((iEnc>>8)<<8);
/*
      if(iLastNBit)ed->vlc.iBitPos=iLastNBit;

      while(ed->vlc.iBitPos&7){
         ed->vlc.addB(1);
      }
*/

      /*
      if(iLastNBit){
         ed->vlc.addB(1);ed->vlc.addB(1);ed->vlc.addB(1);ed->vlc.addB(1);ed->vlc.addB(1);ed->vlc.addB(1);ed->vlc.addB(1);
         ed->vlc.iBitPos=((iLastNBit+7)>>3)<<3;
      }
      */

      if(!iSkiped )ed->iSkipId=-1;;
      iBitsGain=0;
      if(!iIsB){iPrevWorstPsnr[0]=ctx.iWorstPsnr[0];iPrevWorstPsnr[1]=ctx.iWorstPsnr[1];iPrevWorstPsnr[2]=ctx.iWorstPsnr[2];}
   }
   if(!iDec && ed->iSkipId==-1){
      debugT(pEncStat,0);
      debugT(pEncStat,1);
      debugT(pEncStat,2);
   }
   if(g_iDeblock && !iDec && (!iIsB && !ed->iThisWasB)  && (ed->iSkipId==-1)){// || ed->iSkipId>3*(w*h>>8))-8) {
      void deblock_yuv(unsigned char *p ,int w, int h, int stride, int iEnc);
      deblock_yuv(pCur,w,h,stride, !iDec);
   }

   return ed->vlc.getBytePos();


}
#endif
#else
unsigned char *getCropTbl(){return (unsigned char*)0;}
#endif
